<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 学习——关键字 | creat's HomePage</title><meta name="author" content="creat"><meta name="copyright" content="creat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="static 前置🧀   在学习 static 之前，我们应该知道以下的知识点：  变量的作用域 (scope)：表明一个变量是否能够被访问。它包含了两大部分：  局部或块作用域 (Local or Block Scope)。 全局作用域 (Global Scope)。  变量的持续时间 (duration)：表明一个变量何时创建以及何时销毁。它也包含了两大部分：  自动存储持续时间 (Auto">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习——关键字">
<meta property="og:url" content="https://ardbr.github.io/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/index.html">
<meta property="og:site_name" content="creat&#39;s HomePage">
<meta property="og:description" content="static 前置🧀   在学习 static 之前，我们应该知道以下的知识点：  变量的作用域 (scope)：表明一个变量是否能够被访问。它包含了两大部分：  局部或块作用域 (Local or Block Scope)。 全局作用域 (Global Scope)。  变量的持续时间 (duration)：表明一个变量何时创建以及何时销毁。它也包含了两大部分：  自动存储持续时间 (Auto">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ardbr.github.io/img/avatar.gif">
<meta property="article:published_time" content="2024-11-28T07:31:04.000Z">
<meta property="article:modified_time" content="2024-12-19T08:58:51.415Z">
<meta property="article:author" content="creat">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ardbr.github.io/img/avatar.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ardbr.github.io/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":10,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":"mac"},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 学习——关键字',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4746832_eb25gdpzci6.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" alt="Logo"><span class="site-name">creat's HomePage</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 学习——关键字</span></a></span><div id="music-bar"><div id="music-cover-container"><div id="music-cover"></div></div><div id="music-button-container"><div id="music-button-container-top"><span class="music-icon iconfont icon-shangyishou" id="music-prev"></span><span class="music-icon iconfont icon-bofang" id="music-playOrPause"></span><span class="music-icon iconfont icon-xiayishou" id="music-next"></span><span class="music-icon iconfont icon-liebiaoxunhuan" id="music-mode"></span></div><div id="music-button-container-bottom"><div id="music-progressBar"><span id="music-currentProgress"></span><span id="music-dot"></span></div><span id="music-progressText">00:00 / 00:00</span></div></div><div id="music-name-container"><span id="music-name"></span></div><div id="music-lyric-container"><span id="music-lyric"></span></div></div><div id="menus"><div id="toggle-menu"><span class="site-page"></span><i class="fas fa-bars fa-fw"></i></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 学习——关键字</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-28T07:31:04.000Z" title="发表于 2024-11-28 15:31:04">2024-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-19T08:58:51.415Z" title="更新于 2024-12-19 16:58:51">2024-12-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="static"><code>static</code></h2>
<h3 id="前置">前置🧀</h3>
<p>  在学习 <code>static</code> 之前，我们应该知道以下的知识点：</p>
<ol type="1">
<li><strong>变量的作用域
(scope)：</strong>表明一个变量是否能够被访问。它包含了两大部分：
<ol type="1">
<li><strong>局部或块作用域 (Local or Block Scope)</strong>。</li>
<li><strong>全局作用域 (Global Scope)</strong>。</li>
</ol></li>
<li><strong>变量的持续时间
(duration)：</strong>表明一个变量何时创建以及何时销毁。它也包含了两大部分：
<ol type="1">
<li><strong>自动存储持续时间 (Automatic Storage
Duration)</strong>（对于具有本地或块作用域的变量，出了这个作用域后就会自动销毁）。</li>
<li><strong>静态存储时间 (Static Storage
Duration)</strong>（对于具有全局作用域的变量或带有静态说明符的局部变量（在函数或代码块中））。</li>
</ol></li>
<li><strong>链接
(linkage)：</strong>确定变量是否可以在另一个文件中访问（或链接）。它有两种类型：
<ol type="1">
<li><strong>内部链接 (Internal
Linkage)</strong>（对于具有块作用域和全局作用域 / 文件作用域 /
全局命名空间作用域的变量）。</li>
<li><strong>外部链接 (Enternal Linkage)</strong>（对于仅具有全局作用域 /
文件作用域 / 全局命名空间作用域的变量）</li>
</ol></li>
</ol>
<p>  <code>static</code> 既可以修饰变量，也可以修饰函数。接下来我们的
<code>static</code> 关键字将从以下几个部分讲解：</p>
<h3 id="在结构体或类的外部使用">在结构体或类的外部使用</h3>
<h4 id="static-修饰的全局变量"><code>static</code> 修饰的全局变量</h4>
<p>  对于全局变量而言，未使用 <code>const</code> 修饰的变量的链接
(linkage) 属性默认是
<code>Enternal Linkage</code>。也就是说默认其他的翻译单元 (translation
unit) 是可以访问的，例如如下的代码：</p>
<div class="note info flat"><p><strong>翻译单元 (translation unit)</strong>:</p>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样，我们使用 <code>extern</code> 可以使 <code>main.cpp</code>
访问 <code>other.cpp</code> 中的 <code>a</code>。而若此时，我们把
<code>other.cpp</code> 中的 <code>a</code> 变量加上 <code>const</code>
关键字修饰，这时候在 <code>main.cpp</code>
中就不能再进行访问了，会报错<strong>找不到 <code>a</code>
的符号定义</strong>，因为加入 <code>const</code>
修饰之后变量的链接属性就变成了
<code>Internal Linkage</code>，无法在其他翻译单元中访问。但如果我们就是想要访问
<code>const</code> 变量修饰的 <code>a</code> 呢？我们就要使用
<code>extern</code> 关键字来强制改变 <code>a</code> 的链接属性。于是
<code>other.cpp</code> 修改为以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p>注意，对于非常量定义的全局变量，使用 <code>extern</code>
关键字来表明它是可以在其他翻译单元访问是多余的，因为这是默认的 (Enteral
Linkage)。例如对于上述 <code>other.cpp</code> 中，可以直接指定
<code>int a = 2</code>，而不需要 <code>extern int a = 2</code>。但对于
<code>const int a = 2</code> 来说，<code>extern</code>
就是必不可少的了！ 同理，对于 <code>const</code>
修饰的全局变量，如果我们不想让它在外部翻译单元被访问，也无需显性指定
<code>static const a = 2</code>，因为对于 <code>const</code>
来说这也是默认的 (Internal Linkage).</p>
</div>
<p>  因此，对于全局变量而言，<code>static</code>
关键字的作用就是改变变量的链接属性。我们有了一个非 <code>const</code>
修饰的全局变量，并且不想让它在其他翻译单元中访问，我们就可以使用
<code>static</code> 进行修饰。这一点上功能与 <code>extern</code>
关键字相对。</p>
<h4 id="static-修饰的局部变量"><code>static</code> 修饰的局部变量</h4>
<p>  局部静态变量一般都是在函数中使用（在一般的匿名代码块中使用不常见。因为匿名代码块只会在当时执行，后续无法再调用执行，且其内部的静态变量无法在代码块外部使用（作用域限制），因此一般无意义）。
  还记得前面说过，局部变量是自动存储持续时间，出了相应的作用域之后就会销毁。而如果我们在这个时候使用了
<code>static</code>
关键字对其进行了修饰，那么就会改变它的持续时间属性，使其变为静态存储时间。<strong>其生命周期是程序的整个持续时间，这意味着它具有固定的内存位置，其值仅在程序启动之前初始化一次，如
<a hred="https://en.cppreference.com/w/c/language/static_storage_duration">cpp
reference</a> 中所述（初始化不应与赋值混淆）。</strong>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_static_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到，<code>f_a</code> 每次都是一个新的
<code>int a = 0</code>，每次都是 <code>a++</code>
后打印，所以每次输出的结果都是 <code>1</code>。而
<code>f_static_a</code> 仅在第一次进入函数的时候声明定义 1
次，拥有固定的内存位置，而不是像 <code>f_a</code>
只是在当前的函数栈上分配内存。之后不会再重新初始化，所以每次调用，都是在前面基础上自增。</p>
<p>  此外，局部静态变量也常用在创建单例模式的类中，例如如下的代码是在类中使用静态成员变量创建单例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *instance; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton *instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note danger flat"><p><strong>一个很有意思的问题：</strong>
<strong>不知道你有没有发现上述代码的一个致命
<code>bug</code>——这里我们初始化了
<code>instance = nullptr</code>，后续使用了 <code>Get()</code>
解引用得到了该单例 <code>*instance</code>，并且随后调用了
<code>Hello()</code> 这个成员函数。我们仿佛做了 <code>*nullptr</code>
这样一件事情。而众所周知这样做程序应该会崩溃，并报错
<code>Segmentation fault</code>。但如果运行后你会发现它能够正常打印
<code>Hello</code>，看似一切正常？你知道这是为什么吗？其实答案已经藏在了
<code>C++ 学习</code> 的某一篇文章中了 :-)</strong></p>
</div>
<p>可以看到，这种做法是比较繁琐的。如果我们使用静态局部变量，就可以用更少的代码实现相同的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p><strong>全局 <code>static</code> 变量和局部 <code>static</code>
变量的区别：</strong>全局静态变量虽然无法被其他的翻译单元访问，但在同一个翻译单元内部，任意的地方都能够对其进行访问。局部的静态变量只有在函数的内部有效，在函数外面无法访问，相当于比全局的静态变量还要多了一层访问权限。可以想到，既然同一个翻译单元都不一定能够访问到局部静态变量，那更不用说不同的翻译单元之间了。</p>
</div>
<h4 id="static-修饰的函数"><code>static</code> 修饰的函数</h4>
<p>  不考虑 <code>lambda</code> 表达式，一般函数而言都是全局的，因此对于
<code>static</code>
修饰的函数，行为与全局变量类似，修改的是它的链接属性。一般而言，函数的链接属性是
<code>Enternal Linkage</code>，也就是可以被其他翻译单元被访问。于是，我们可以使用
<code>static</code> 关键字修饰，使其限制在本翻译单元内部。</p>
<h3 id="在结构体或类的内部使用">在结构体或类的内部使用</h3>
<h4 id="static-修饰的成员变量"><code>static</code> 修饰的成员变量</h4>
<p>  静态成员变量在所有的实例中只有一份，也就是所有的实例共享这一个静态成员变量，对其中任意一个进行修改，都会对所有的实例的该变量产生影响。例如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    e<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">    e<span class="number">1.</span>y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    e.<span class="built_in">Print</span>();  <span class="comment">// 5 8</span></span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 5 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出的结果是 <code>e</code> 和 <code>e1</code> 的 <code>x</code> 和
<code>y</code> 都是 <code>5</code> 和 <code>8</code>。
  <strong>在前面的例子中，<code>static</code> 成员（包括
<code>public</code> 和 <code>private</code>）都是非常量。ISO
标准禁止在类中初始化非常量静态成员。因此我们必须在类定义之后初始化它们，并注意需要省略
<code>static</code> 关键字。而对于 <code>const</code>
成员变量来说，它符合其他 <code>const</code> 成员变量初始化的约定，即类的
<code>const</code>
静态成员变量可以在声明时初始化，也可以在类声明结束时初始化，但需要注意的是，在类定义后初始化时，需要将关键字
<code>const</code>
添加到静态成员中。推荐在声明的同时进行初始化！</strong></p>
<div class="note danger flat"><p>注意我们在类或者结构体中写下的成员变量只能算<font color="red"><strong>声明</strong></font>而非定义。<font color="red"><strong>声明</font>是让编译器知道这个变量的存在以及类型</strong>。而我们需要在类或结构体的外面<font color="red"><strong>定义</strong></font>这个变量，<strong>以便在此处分配实际的内存</strong>。因此，我们需要在类或结构体的外面写下类似
<code>int Entity::x</code> 这样的语句。</p>
</div>
<p>  其实严谨来说，上述代码虽然没有报错，但并不合适。实际上静态成员变量可以看作不属于任何一个实例，因为尽管没有创造实例
<code>e</code> 和 <code>e1</code>，我们依旧可以访问 <code>x</code> 和
<code>y</code>，因为我们在外部初始化定义了
<code>int Entity::x</code>，而不是像普通成员变量一样要依靠实例来进行初始化。例如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line">    std::cout &lt;&lt; Entity::x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Entity::y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  因此，之前的代码可以写成下列的形式，这样更有助于我们理解静态成员变量在所有的实例中共享，修改其中一个会影响其余的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    Entity::x = <span class="number">2</span>;</span><br><span class="line">    Entity::y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="static-修饰的成员函数"><code>static</code> 修饰的成员函数</h4>
<p>  与普通的成员函数不同，静态成员函数与实例无关，即它不属于任何实例，<strong>因此它没有
<code>this</code>
指针</strong>。如果要深入剖析原理的话，对于普通的成员函数，例如前面的
<code>e.Print()</code>，编译器编译过后会变成
<code>Print(e)</code>，也就是会把调用者作为第一个参数传进成员函数中，因此
<code>this</code> 就会指代
<code>e</code>，也因此成员函数中可以任意使用类中的变量，因为它都会由第一个参数，也就是调用者这个类实例提供。而对于静态成员函数来说，它不与任何实例有关系，即使没有实例，也是可以调用静态成员函数的，因此它没有
<code>this</code> 指针，尽管仍然可以使用例如 <code>e.function</code>
这种形式调用（严格来说要以 <code>className::staticFunc()</code>
这种形式调用）。
  由于即使没有实例，我们也可以调用静态函数，因此我们可以推断出，<font color="red"><strong>在静态成员函数中，我们不能使用普通的成员变量。</strong></font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;    <span class="comment">// declaration</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;      <span class="comment">// defination</span></span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">Print</span>();    <span class="comment">// 5 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="auto"><code>auto</code></h2>
<p>  <code>auto</code>
可以帮助我们自动填补该变量的类型，而不需要我们手动指定，我们只需要在变量前面使用
<code>auto</code> 即可，例如 <code>auto a = 5</code>。对于迭代器或
<code>&lt;chrono&gt;</code>
时间库等一些类型名十分冗长的数据类型来说，<code>auto</code>
十分好用，可以直接为我们指定出应有的类型。
  当然，它是一把双刃剑，也会有不好的一面。考虑如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,  world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = name.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代码可以正常运行并输出，<code>name</code> 的类型是
<code>std::string</code>。但是考虑如果我们把 <code>getName()</code>
的返回类型改为
<code>char *</code>，这个时候事情就不一样了。<code>name</code>
的类型被改为了 <code>char *</code>，而后面的 <code>name.size()</code> 是
<code>std::string</code> 才有的成员函数，因此就会报错！
  而若我们使用的是
<code>std::string name = getName()</code>，这里就没问题了。因为最坏的情况下你修改了函数的返回值，类型不兼容会报错，我们修改成对应的类型即可。但好的情况编译器会为我们做隐式类型转换，将
<code>char *</code> 转为 <code>std::string</code>，程序依旧能正常运行。
  并且 <code>auto</code>
使用过多后我们不方便知道一个变量到底是什么类型，例如上方，我们可能要去查看
<code>getName()</code> 的返回类型，之后才能确定 <code>name</code>
的类型，当然现在大多数的代码编辑器支持鼠标悬停查看类型。但始终也不如直接显性规定变量类型，一眼看上去就知道要来的快。
  下面再举一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;<span class="built_in">getDeivce</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> dm;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; dm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DeviceManager *dm = <span class="keyword">new</span> DeviceManager;</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;d = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> d2 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;d3 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> deviceType = std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;;</span><br><span class="line">    <span class="type">const</span> deviceType &amp;d4 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; deviceType2;</span><br><span class="line">    <span class="type">const</span> deviceType2 &amp;d5 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看到，这个 <code>dm</code>
的类型是一个很长很长的类型，我们有以上的几种方法可以来实现对类型的声明。第一种就是正常的写法，全部写出来。第二种和第三种使用
<code>auto</code> 关键字自己确定。第四种使用 <code>using</code>
起类型别名。而第五种则是用 <code>typedef</code> 起类型别名。</p>
<div class="note danger flat"><p><strong>注意，使用 <code>auto</code> 关键字内部并不会给你自动指定
<code>const</code> 和引用
<code>&amp;</code>，尽管你函数的返回值表明了常量引用。因此上述第二种仅仅只是声明了这个类型，并没有加
<code>const &amp;</code>，第三种才是 <code>auto</code>
的正确写法！</strong></p>
</div>
<h2 id="宏-macros">宏 <code>macros</code></h2>
<p>  宏的本质就是替换，在正式执行编译之前，编译器会进行预处理操作，把所有的宏替换成你所在后面定义的语句。这个过程就是纯文本的查找与替换。例如如下例子就能很好的说明这一点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_CURLY &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> OPEN_CURLY</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上述代码依旧能够正常编译运行。在这段代码中，我们做了一个很疯狂的操作，我们用宏
<code>OPEN_CURLY</code> 来代替左花括号
<code>&#123;</code>，因此，之后在任何能够使用到 <code>&#123;</code>
的地方，我们都可以把它替换成 <code>OPEN_CURLY</code>。</p>
<p>  当然，这不是宏的正确打开方式！宏至少有以下的几种用法：</p>
<ul>
<li>将常用的函数用宏来代替，减少了代码量。注意最好是一些可读性较强的代码，替换成宏之后意义依旧十分明确，否则还要去跟踪宏的定义看看到底实现的是什么功能。因此这一用法尽量少用！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning flat"><p><strong>一般来说，定义的宏值后面的代码语句不要添加
<code>;</code>，而是在实际使用时在宏的后面添加。</strong>例如
<code>LOG("");</code>。因为如果在定义宏的时候添加了
<code>;</code>，那么后续使用的时候如果不加，是正确的做法，但是对于
<code>C++</code> 来说，一般所有的代码语句都要以 <code>;</code>
结尾。因此一个宏后面没有
<code>;</code>，就会显得很突兀。而如果加了的话，就相当于一个语句后面有 2
个 <code>;</code>，造成了一个空语句。</p>
</div>
<ul>
<li>与 <code>#if</code> 配合食用用于快速注释多行代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这样的话，<code>#if 0</code> 和 <code>#endif</code>
之间的所有代码都不会被执行。</p>
<ul>
<li>切换程序的运行版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PRO_DEBUG == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PRO_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  我们希望在程序的调试阶段，打印一些运行信息来观察程序执行是否有误。而在发行版本中，就不要打印任何信息。我们可以利用宏来快速完成这一点。也就是说在
<code>DEBUG</code> 阶段，<code>LOG()</code> 函数被定义成一个
<code>std::cout</code> 的实现，而在 <code>RELEASE</code> 下，我们让
<code>LOG()</code> 为空，不要执行任何功能即可。</p>
<p>  使用
<code>g++ -std=c++17 -DPRO_DEBUG=1 main.cpp -o main &amp;&amp; ./main</code>
来运行上述代码，可以观察到打印出了信息。而当我们使用
<code>g++ -std=c++17 -DPRO_RELEASE main.cpp -o main &amp;&amp; ./main</code>，程序就不会有任何输出。而如果我们不定义这两者之一，程序就会报错，因为找不到
<code>LOG</code> 宏定义。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main &amp;&amp; ./main              </span><br><span class="line">main.cpp:14:5: error: use of undeclared identifier &#x27;LOG&#x27;</span><br><span class="line">    LOG(&quot;Hello, world&quot;);</span><br><span class="line">    ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>使用 <code>g++</code> 时，通过
<code>-D&lt;MACROS&gt;=&lt;VALUE&gt;</code>
的参数可以为我们在编译执行代码的时候往程序里添加一个或多个宏定义。其中
<code>=&lt;VALUE&gt;</code>
部分可选，即我们可以只定义该宏，而不指定其为任何值。</p>
</div>
<h2 id="模板-template">模板 <code>template</code></h2>
<h3 id="模板的概念">模板的概念</h3>
<p>  模板 <code>template</code> 指 <code>C++</code>
程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。<code>C++</code>
的标准库提供许多有用的函数大多结合了模板的观念，如 <code>STL</code> 以及
<code>IO Stream</code>。
  例如对于如下的代码，如果我们不使用模板，而我们想对不同的类型，例如
<code>int</code>、<code>std::string</code> 以及 <code>double</code>
写一个函数进行打印，那么就得写多个 <code>Print</code>
函数，其接收的参数不同，因此可以对其进行重载。
  可以看到，这种方式要多写很多的代码，明明每个函数内部的代码都是相同的，仅仅是接收的参数类型不同而已。我们能不能将参数的数据类型也指定成为一个参数
<code>T</code>，然后编译的时候由 <code>Print()</code>
函数接收的参数的数据类型对这个参数 <code>T</code> 进行填值，生成对应的
<code>Print</code> 函数呢？答案是可以的，模板就是来干这个的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">double</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板的使用">模板的使用</h3>
<p>  我们首先需要在要定义的函数前面声明这是一个模板函数，通过
<code>template &lt;typename T&gt;</code> 可以做到这一点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用模板要注意的地方">使用模板要注意的地方</h3>
<p>  <font color="darkred"><strong>注意，如果并没有调用
<code>Print()</code> 函数，那么 <code>Print()</code>
函数并不会被创建出来。只有调用的时候，编译器才会将对应参数类型的
<code>Print</code> 函数创建出来。例如我们调用了
<code>Print(5)</code>，那么 <code>void Print(int value) &#123;&#125;</code>
这个函数就会被创建出来。而不调用 <code>Print("hello")</code>
之前，<code>void Print(const char *value) &#123;&#125;</code>
是不存在的！</strong></font></p>
<p>  要证明这一点，我们可以通过如下的代码验证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  很明显 <code>void Print(T value)</code> 函数内部有错误，我们把
<code>value</code> 故意改成了
<code>val</code>，如果这个函数在编译阶段被创建出来了的话，那么编译器会因为找不到
<code>val</code>
变量而报错的。但是我们编译执行，发现并没有错误！因为我们没有任何调用
<code>Print</code> 的地方，因此这个函数并不会被创建出来。</p>
<div class="note warning flat"><p><strong>注意，普通函数即使不被调用，如果函数内部实现有错误，编译器仍然会报错，因为普通函数即使没有被调用，但也是会被创建出来的。</strong></p>
</div>
<p>  因此，模板的实现原理就是：我们有了一个被标记为模板函数的函数，编译器执行到这里的时候并不会将其进行创建，因为编译器也不知道要创建接收什么数据类型的函数。直到我们后续的函数中有了一个使用这个模板函数的地方，编译器便会对传入的参数进行类型推断，比如推断出
<code>5</code> 是一个
<code>int</code>，因此，它会回去<strong>由模板函数创建出一个接收参数为
<code>int</code> 类型的普通函数</strong>。之后又遇见了接收
<code>"hello"</code> 的模板函数，它推断 <code>"hello"</code> 是一个
<code>const char *</code>，因此就会创建一个
<code>void Print(const char *)</code> 的普通函数。</p>
<p>  由上述我们可以发现，我们传入的参数都是由编译器自己进行推断的。这在大多数情况下都很方便，但有些时候可能与我们所设想的不同。例如，之前我们所传入的
<code>"hello"</code> 我们可能希望它是一个 <code>std::string</code>
而不是 <code>const char *</code>，因为我们可能想在函数内部调一些例如
<code>.size()</code> 等只有 <code>std::string</code>
这些类才有的成员函数。因此，我们可以显性指定要用什么类型的模板函数，只要像
<code>Print&lt;int&gt;(5)</code>、<code>Print&lt;std::string&gt;("hello")</code>
这样写即可。</p>
<h3 id="在类中使用模板">在类中使用模板</h3>
<p>  在 <code>C++</code> 中，以下的代码是不被允许的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>因为在普通函数中定义数组时，<code>size</code>
可以是编译时常量或允许的动态大小，视编译器和语言标准而定。而在类中，数组的大小必须<font color="red">在编译时已知</font>，不能使用非静态成员变量来定义，因此需要采用其他方法来管理动态大小数组。</strong></p>
<p>  例如，以下是几种解决方法：</p>
<ul>
<li>动态分配内存：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] array; <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>std::vector</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; array; <span class="comment">// 使用 std::vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">array</span>(size) &#123;&#125; <span class="comment">// 初始化 vector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  而在这一节，我们要提出第三种方法，那就是使用模板。因为前面说了，在类中定义数组的时候，其大小必须是编译时可以确定大小的数据。而前前面我们又说了，模板就是在编译期间确定其具体的数据类型。<strong>因此两者完美契合！！！</strong>这里我们可以引申一下，因为模板不仅可以通过
<code>&lt;typename T&gt;</code>
来将数据类型作为参数在编译期间确定，也可以将一些常用类型的变量具体值作为参数。例如
<code>template &lt;int N&gt;</code>，我们就指定了一个 <code>int</code>
类型的变量 <code>N</code>，其大小会编译期间确定下来。所以，我们的
<code>Array</code> 可以像如下代码这样定义和使用（我们同时将
<code>array</code> 的数据类型也从 <code>int</code> 变为模板
<code>T</code>，因此可以接收 <code>std::string</code>
等的类型！此外还实现了一些小功能，例如支持下标索引，打印数组元素等）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[] (<span class="type">int</span> index) &#123; <span class="keyword">return</span> array[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T array[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Array&lt;std::string, <span class="number">5</span>&gt; arr1;</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    arr1[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    arr1[<span class="number">4</span>] = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main -Wall &amp;&amp; ./main</span><br><span class="line">hello , world ! ? </span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="explicit"><code>explicit</code></h2>
<p>  使用 <code>explicit</code>
指定构造函数或转换函数（<code>C++11</code>
起）是显式的，也就是说，它不能用于隐式转换和拷贝初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125;      <span class="comment">// converting constructor</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) &#123;&#125; <span class="comment">// converting constructor (C++11)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK: copy-initialization selects A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects A::A(int)</span></span><br><span class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK: copy-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) &#123; &#125;    <span class="comment">// OK: A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK: copy-initialization selects A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects B::B(int)</span></span><br><span class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // error: copy-list-initialization does not consider B::B(int, int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) &#123; &#125;    <span class="comment">// OK: B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line">    [](...)&#123;&#125;(a4, a5, na1, na2, b5, nb2); <span class="comment">// suppresses “unused variable” warnings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info flat"><ul>
<li><code>if (b2) { }</code>
语句是合法的，因为条件语句中的表达式可以使用显式转换运算符
<code>operator bool()</code>。<code>C++</code> 语言允许在控制流语句（如
<code>if</code>）中使用显式转换，因为这是一种上下文相关的转换。尽管
<code>operator bool()</code> 是显式的，但在 <code>if</code>
语句的上下文中，编译器会尝试调用它。</li>
<li>而 <code>bool nb1 = b2;</code>
这一行代码会导致编译错误。原因是赋值操作中使用了拷贝初始化。拷贝初始化是指编译器尝试将
<code>b2</code> 转换为 <code>bool</code> 类型，但由于
<code>operator bool()</code> 是显式的，编译器不会在这里进行调用。为了从
<code>B</code> 转换到 <code>bool</code>，必须使用显式转换。</li>
</ul>
</div>
<h2 id="const"><code>const</code></h2>
<h3 id="常规用法">常规用法</h3>
<p>  对于常规的变量来说，使用 <code>const</code>
关键字修饰后，就表示你自己做了承诺，这个值将不会被修改，后续都会作为一个常值被使用。例如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针中的用法">指针中的用法</h3>
<p>  对于指针来说，会有两种意义的
<code>const</code>。因为我们可以想到：</p>
<ul>
<li>一方面，<strong>指针的指向是可变的，我可以让它指向这块内存，也可以让它指向另一块内存。</strong></li>
<li>此外，<strong>对于指向的某一块具体内存，其指向的内容也是可变的，我们可以通过解引用来修改地址中存储的值。</strong></li>
</ul>
<p>  因此，这种用法的 <code>const</code>
根据其修饰的位置不同，会有两种完全不同的意义。</p>
<p>  如果我们想要其<strong>指针的指向固定不变</strong>，我们要在
<code>*</code> 的后面添加 <code>const</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这句代码仍然是正确的</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时下面的代码是错误的，因为它试图改变指针的指向</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>  而如果我们想要指向的内存中的内容数据是固定不变的，我们要在
<code>*</code> 的前面添加
<code>const</code>，例如如下的两种方法都是可以的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为它试图修改内存中的数据</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>   <code>const</code> 大杂烩：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的 3 个 const 分别用 0), 1), 2) 从左往右进行表示</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> <span class="title">get_ptr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m_ptr = 0x2;        // 2) 处的 const 错误——试图在标记为 const 的成员函数内修改成员变量的值</span></span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="comment">// int *p = e.get_ptr();       // 0) 处的 const 错误——试图用 const int * 初始化 int *，这会丢失 const 限定符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p = e.<span class="built_in">get_ptr</span>();</span><br><span class="line">    <span class="comment">// *p = 20;                    // 1) 处的 const 错误，试图对内存数据进行修改，int * const 保证内存数据不可被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  一点有意思的事情：我们可以声明定义一个常量，例如
<code>const int a = 10;</code>，此时，我们直接修改 <code>a</code>
是会报错的。但我们可以取 <code>a</code> 的地址，然后用普通的
<code>int *</code> 来接收它。但这时候还是会报错，因为
<code>&amp;a</code> 是 <code>const int *</code> 类型，无法用
<code>int *</code>
接收。于是我们可以硬着头皮强制转换！然后转成了普通指针，这个时候就能修改
<code>p</code> 指向的内存的数据，也就是 <code>a</code>
的值了？这种行为是未定义的行为！说不准会有什么现象，取决于不同的编译器以及一些优化策略。例如，下面是我在
<code>MacOS</code> 上用 <code>g++</code>（其实本质还是
<code>Clang</code>）的代码和运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(&amp;a) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out                               </span><br><span class="line">0x16b1872c8</span><br><span class="line">0x16b1872c8</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>  可以看到，<code>a</code> 的地址和 <code>p</code> 是相同的，但解引用
<code>p</code> 可以得到修改后的 <code>20</code>，但是这个时候打印
<code>a</code>，仍然会得到
<code>10</code>。神奇诶！emmm…还是不要这么做了——<span
style="font-size: 20px; color: red"><strong><em>You’re treading
dangerous
waters…</em></strong></span>这里有一篇<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/771100/changing-the-value-of-a-const-pointer">帖子</a>就是说这个事情的。</p>
<h3 id="类中的用法">类中的用法</h3>
<p>  在类中使用，多在成员函数中使用。如果我们想要标记一个成员函数，它的内部不会修改成员变量的值，那么就可以在这个函数的参数列表之后添加
<code>const</code> 关键字。多用于 <code>getter</code> 函数中使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> data)</span> : m_data(data) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_entity</span><span class="params">(<span class="type">const</span> Entity &amp;e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">get_data</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_entity</span>(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  但一般来说建议提供 <code>getter()</code> 函数的 <code>const</code>
和非 <code>const</code> 两种版本。因为比如对于上面的
<code>print_entity(const Entity &amp;e)</code>
函数，它接收的是常量引用类型的传入参数，这个时候，如果它的内部调用了
<code>e.get_data()</code>，那么这个 <code>get_data()</code>
函数必须是要被标记为 <code>const</code>
的！！否则，就会出现以下的问题：我明明在参数列表中承诺这个函数接收的是
<code>const &amp;</code> 类型，也就是我内部是不会修改 <code>e</code>
以及它的成员变量的。但是！如果你内部的成员函数没有承诺这一点，而利用自己的非
<code>const</code>
属性修改了成员变量……事情就会变得令人困惑了——我这个函数
<code>print_entity()</code> 确实没修改
<code>e</code>，但是我内部调用的其他函数 <code>e.get_data()</code>
修改了 <code>e</code>。因此，为了避免这一情况发生，请给
<code>const &amp;</code> 传入参数 <code>e</code> 调用的成员函数都加上
<code>const</code> 修饰！</p>
<h2 id="mutable"><code>mutable</code></h2>
<p>  <code>mutable</code>
关键字用来显性指定一个变量或者函数的内部的某些变量是可以 “被修改”
的。一般来说，<code>mutable</code> 关键字有两种用法。</p>
<ul>
<li>一种是在类中。我们知道，类中的成员函数如果声明了 <code>const</code>
关键字，那么它内部是不可以对成员变量的值进行修改的。有些时候，我们确实需要某些成员变量是可以被修改的，而其他的变量不应该被修改。因此，问题就变成了<strong>如何在仍然保持函数实现是
<code>const</code>
的情况下，允许某些变量是可以被修改的？</strong>通过在我们想要修改的成员变量前添加
<code>mutable</code> 关键字就可以做到这一点！</li>
<li>第二种是在 <code>lambda</code> 表达式中。这一点可以详见 《C++
学习——内存》 部分的函数指针章节。在最后我们拓展出了 <code>lambda</code>
表达式，并在那里说明了一些问题，使用到了 <code>mutable</code>
关键字。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Ardbr.github.io">creat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ardbr.github.io/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/">https://ardbr.github.io/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Ardbr.github.io" target="_blank">creat's HomePage</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/11/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%954%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E9%83%A8%E5%88%86/" title="Hexo-butterfly 魔改记录4——主页部分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hexo-butterfly 魔改记录4——主页部分</div></div><div class="info-2"><div class="info-item-1">副标题一言   用了一段时间的 "https://v1.hitokoto.cn" 的一言 API，感觉不是很适合我的风格，还是更喜欢一些网抑云系列的 QAQ。因此，查看了 butterfly 的关于 subtitle 部分的源代码，决定修改一下，不如不调用 API 了，我自己整个语录集放在本地，每次随机抽一个打印出来好了，这样都是我自己收集的，百分百合我自己的胃口😋   源码有 1/2/3 3 个选项，选择调用不同的 API 获取一言。那我们再写一个 4 的分支就好啦。稍微看懂一下源码，直接 Ctrl C+V 复制修改一下就搞定了。   找到 subtitle.pug，在相应的 JS 代码段添加 when 4 的判断语句（目前不是很想写这随机抽取调用部分的代码，先留个小坑，暂时用这固定的一句很喜欢的文案代替一下～）： 12345678910111213when 4script.    function subtitleType () &#123;        if (!&#123;effect&#125;) &#123;            //- const from...</div></div></div></a><a class="pagination-related" href="/2024/11/27/Unix-1-shell/" title="Unix-1-shell"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unix-1-shell</div></div><div class="info-2"><div class="info-item-1">Shell 查看当前系统下的 shell 1cat etc/shells 查看当前使用的 shell 1echo $SHELL 常用的快捷键    快捷键 功能     Ctrl + p 显示上一条命令，同方向键上   Ctrl + n 显示下一条命令，同方向键下   Ctrl + b 光标向后移动一格，同方向键左   Ctrl + f 光标向前移动一格，同方向键右   Ctrl + a 将光标置于最开始的位置   Ctrl + e 将光标置于末尾的位置   Ctrl + u 清空当前写下的命令   Ctrl + d 删除后面的一个字符，同 delete    123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public:    vector&lt;int&gt; closestRoom(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, vector&lt;vector&lt;int&gt;&gt;&amp;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++ 学习——一些新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-22</div><div class="info-item-2">C++ 学习——一些新特性</div></div><div class="info-2"><div class="info-item-1">结构化绑定   这是在 C++17 中新引入的特性，用于处理函数多返回值的问题。在旧版本的 C++ 中，如果我们想要处理一个函数具有多返回值，而且返回值的类型可能不同时，我们可以通过结构体、pair 或者 tuple 的形式，但他们都十分地繁琐，不管是对于函数返回类型还是接收部分处理。以下是一个使用 tuple 的简单示例： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;tuple&gt;std::tuple&lt;std::string, int&gt; createPerson() &#123;    return &#123;&quot;Cherno&quot;, 24&#125;;&#125;int main(void) &#123;    std::tuple&lt;std::string, int&gt; person = createPerson();    std::string name =...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/" title="C++ 学习——内存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——内存</div></div><div class="info-2"><div class="info-item-1">多维数组的创建及删除 1 维数组的动态分配内存   直接使用 new 关键字进行分配，指令为 int *arr = new int[50]，这会分配一块连续的 50 个 int 大小的内存空间，并且返回这块内存的首地址给到 arr，arr 的类型为 int *。 2 维数组的动态内存分配   首先我们需要分配一块内存空间 a，这块内存空间中的每一个值都是一个地址，指向另一块内存空间 b_i 的首地址，这样，我们便实现了二维数组的创建。例如，对于一个二维数组 arr2d[i][j]，首先，我们取 a[i] 中的值，这便是一个地址，我们顺着这个地址就能够找到第 i 块内存 b_i，之后我们锁定了这块内存。而由二维数组可知，这一块内存中每个里面存的便是具体的数据内容了。具体取哪个数据，便取决于 j 啦！ 3 维数组的动态内存分配   对于三维内存，此处就不再赘述了，无非是 arr3d[i][j][k]，由 i 锁定第 i 个内存块，不同于二维数组，这个内存块上存的仍然是其他内存块的首地址，也就是还是一个指针。我们再在这个基础上锁定其第 j 个的地址，顺着找到第...</div></div></div></a><a class="pagination-related" href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/" title="C++学习——杂项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-23</div><div class="info-item-2">C++学习——杂项</div></div><div class="info-2"><div class="info-item-1">C++ 的参数计算顺序 123456789101112#include &lt;iostream&gt;int sum(int a, int b) &#123;    std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; (a + b) &lt;&lt; std::endl;&#125;int main(void) &#123;    int value = 0;    sum(value++, value++);    return 0;&#125;   运行结果： 12345678910(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o mainmain.cpp:5:1: warning: non-void function does not return a value...</div></div></div></a><a class="pagination-related" href="/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" title="C++ 学习——命名空间"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">C++ 学习——命名空间</div></div><div class="info-2"><div class="info-item-1">命名空间 namespace   在 C 中，我们只能通过给函数名称前加上独有的前缀来避免命名冲突，例如对于 GLFW 库，这是一个 C 库，其中的所有函数都是以 GLFW 开头，例如 GLFWInit()。同样的还有 OpenGL 库，例如 glInit() 等。   在 C++ 中，我们可以通过命名空间来解决多个相同函数名命名冲突的问题。   using namespace 只在当前作用域中有效。尽量不要乱用，可以仅在一个 if 语句中使用，实在不行再考虑加到源文件的开头，但永远不要用在头文件中！ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;namespace apple &#123;    namespace function &#123;        void print2(const std::string &amp;str) &#123;            std::cout &lt;&lt; str &lt;&lt; std::endl;       ...</div></div></div></a><a class="pagination-related" href="/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/" title="C++ 学习——算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-26</div><div class="info-item-2">C++ 学习——算法</div></div><div class="info-2"><div class="info-item-1">算法部分 排序算法   C++ 内部集成了排序算法，即 std::sort()，时间复杂度为 \(O(NlogN)\)。具体的使用见下面的例子。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;int main(void) &#123;    // case 1    std::vector&lt;int&gt; vec = &#123;1, 4, 6, 2, 5, 3&#125;;    std::sort(vec.begin(), vec.end());      // output: 1, 2, 3, 4, 5, 6    for (const int v : vec)        std::cout &lt;&lt; v;    std::cout &lt;&lt; std::endl;   ...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="C++ 学习——基本数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——基本数据类型</div></div><div class="info-2"><div class="info-item-1">string literal 字符串字面量   C++ 中形如 "hello world" 的字符串即为字符串字面量（常量）。与之对比的是字符串变量，也即字符数组，形如 char arr[] = "hello world"。两者在用法上有很多相似之处，但两者的存储属性是截然不同的。   字符串字面量和字符数组有一个很重要的差别：前者是只读的，若程序试图修改字符串字面量，那么结果是未定义的；后者是可读可写的（除非主动使用const修饰）。 1234567891011121314151617#include &lt;iostream&gt;int main(void) &#123;    // 使用指针，尽管没有声明 const 关键字，但仍是字符串字面量，因此不可修改字符串中的字符    char *str = &quot;hello, world!&quot;;    // 下面的做法是错误的！！    str[2] = &#x27;h&#x27;;    // str2 使用数组声明，只要没有声明 const 关键字限定，就是可变的    char str2[] =...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">creat</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ardbr"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Ardbr" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">希望每天都能输出一点新知识😌</div></div><div class="card-widget card-countdown"><div class="countdown-mask"><div class="text-container"><p>2026 年已经过去</p><span class="countdown-number">xx</span><span class="countdown-unit">天</span></div><div class="current-time-container"> <span class="current-time"></span></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">前置🧀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%96%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">在结构体或类的外部使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">static 修饰的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">static 修饰的局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">static 修饰的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%96%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">在结构体或类的内部使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">static 修饰的成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">static 修饰的成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F-macros"><span class="toc-number">3.</span> <span class="toc-text">宏 macros</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-template"><span class="toc-number">4.</span> <span class="toc-text">模板 template</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">模板的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">模板的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">4.3.</span> <span class="toc-text">使用模板要注意的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.4.</span> <span class="toc-text">在类中使用模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">5.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">6.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">常规用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">指针中的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">类中的用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable"><span class="toc-number">7.</span> <span class="toc-text">mutable</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/22/notes/reinforcement_learning/reinforcement-learning-Ch01/" title="reinforcement_learning Ch01">reinforcement_learning Ch01</a><time datetime="2026-02-22T09:17:33.552Z" title="更新于 2026-02-22 17:17:33">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/14/notes/flow_matching/flow-matching-Ch02/" title="flow_matching Ch02">flow_matching Ch02</a><time datetime="2026-02-22T09:09:27.296Z" title="更新于 2026-02-22 17:09:27">2026-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/15/notes/diffusion/diffusion-Ch04/" title="diffusion Ch04">diffusion Ch04</a><time datetime="2026-02-15T15:08:41.405Z" title="更新于 2026-02-15 23:08:41">2026-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/12/notes/flow_matching/flow-matching-Ch01/" title="flow_matching Ch01">flow_matching Ch01</a><time datetime="2026-02-15T02:43:06.395Z" title="更新于 2026-02-15 10:43:06">2026-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/11/notes/diffusion/diffusion-Ch03/" title="diffusion Ch03">diffusion Ch03</a><time datetime="2026-02-15T02:42:57.148Z" title="更新于 2026-02-15 10:42:57">2026-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2026 By creat</div><div class="footer_custom_text">很高兴你能看到这里！</div></div></footer></div><div id="leftside-fps"><span id="leftside-fps-text"></span></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src=/js/sakuraPlus.js></script><script src=/js/parseLyric.js></script><script src=/js/music.js></script><script src=/js/getFps.js></script><script src=/js/countdown.js></script><script src=/js/mathjax.js></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>