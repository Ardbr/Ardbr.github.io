<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 学习——内存 | creat's HomePage</title><meta name="author" content="creat"><meta name="copyright" content="creat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多维数组的创建及删除1 维数组的动态分配内存&emsp;&emsp;直接使用 new 关键字进行分配，指令为 int *arr &#x3D; new int[50]，这会分配一块连续的 50 个 int 大小的内存空间，并且返回这块内存的首地址给到 arr，arr 的类型为 int *。 2 维数组的动态内存分配&emsp;&emsp;首先我们需要分配一块内存空间 a，这块内存空间中的每一个值都是一个地址，">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习——内存">
<meta property="og:url" content="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="creat&#39;s HomePage">
<meta property="og:description" content="多维数组的创建及删除1 维数组的动态分配内存&emsp;&emsp;直接使用 new 关键字进行分配，指令为 int *arr &#x3D; new int[50]，这会分配一块连续的 50 个 int 大小的内存空间，并且返回这块内存的首地址给到 arr，arr 的类型为 int *。 2 维数组的动态内存分配&emsp;&emsp;首先我们需要分配一块内存空间 a，这块内存空间中的每一个值都是一个地址，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ardbr.github.io/img/avatar.gif">
<meta property="article:published_time" content="2024-11-20T09:03:51.000Z">
<meta property="article:modified_time" content="2024-12-01T04:07:05.232Z">
<meta property="article:author" content="creat">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ardbr.github.io/img/avatar.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":10,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":"mac"},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 学习——内存',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4746832_eb25gdpzci6.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" alt="Logo"><span class="site-name">creat's HomePage</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 学习——内存</span></a></span><div id="music-bar"><div id="music-cover-container"><div id="music-cover"></div></div><div id="music-button-container"><div id="music-button-container-top"><span class="music-icon iconfont icon-shangyishou" id="music-prev"></span><span class="music-icon iconfont icon-bofang" id="music-playOrPause"></span><span class="music-icon iconfont icon-xiayishou" id="music-next"></span><span class="music-icon iconfont icon-liebiaoxunhuan" id="music-mode"></span></div><div id="music-button-container-bottom"><div id="music-progressBar"><span id="music-currentProgress"></span><span id="music-dot"></span></div><span id="music-progressText">00:00 / 00:00</span></div></div><div id="music-name-container"><span id="music-name"></span></div><div id="music-lyric-container"><span id="music-lyric"></span></div></div><div id="menus"><div id="toggle-menu"><span class="site-page"></span><i class="fas fa-bars fa-fw"></i></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 学习——内存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-20T09:03:51.000Z" title="发表于 2024-11-20 17:03:51">2024-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-01T04:07:05.232Z" title="更新于 2024-12-01 12:07:05">2024-12-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="多维数组的创建及删除"><a href="#多维数组的创建及删除" class="headerlink" title="多维数组的创建及删除"></a>多维数组的创建及删除</h2><h3 id="1-维数组的动态分配内存"><a href="#1-维数组的动态分配内存" class="headerlink" title="1 维数组的动态分配内存"></a>1 维数组的动态分配内存</h3><p>&emsp;&emsp;直接使用 <code>new</code> 关键字进行分配，指令为 <code>int *arr = new int[50]</code>，这会分配一块<strong>连续的</strong> 50 个 <code>int</code> 大小的内存空间，并且返回这块内存的首地址给到 <code>arr</code>，<code>arr</code> 的类型为 <code>int *</code>。</p>
<h3 id="2-维数组的动态内存分配"><a href="#2-维数组的动态内存分配" class="headerlink" title="2 维数组的动态内存分配"></a>2 维数组的动态内存分配</h3><p>&emsp;&emsp;首先我们需要分配一块内存空间 <code>a</code>，这块内存空间中的每一个值都是一个地址，指向另一块内存空间 <code>b_i</code> 的首地址，这样，我们便实现了二维数组的创建。例如，对于一个二维数组 <code>arr2d[i][j]</code>，首先，我们取 <code>a[i]</code> 中的值，这便是一个地址，我们顺着这个地址就能够找到第 <code>i</code> 块内存 <code>b_i</code>，之后我们锁定了这块内存。而由二维数组可知，这一块内存中每个里面存的便是具体的数据内容了。具体取哪个数据，便取决于 <code>j</code> 啦！</p>
<h3 id="3-维数组的动态内存分配"><a href="#3-维数组的动态内存分配" class="headerlink" title="3 维数组的动态内存分配"></a>3 维数组的动态内存分配</h3><p>&emsp;&emsp;对于三维内存，此处就不再赘述了，无非是 <code>arr3d[i][j][k]</code>，由 <code>i</code> 锁定第 <code>i</code> 个内存块，不同于二维数组，这个内存块上存的仍然是其他内存块的首地址，也就是还是一个指针。我们再在这个基础上锁定其第 <code>j</code> 个的地址，顺着找到第 <code>j</code> 个内存块，这个内存块里面存的才是具体的数据内容，我们要取哪一个数据值呢？第 <code>k</code> 个！</p>
<h3 id="多维数组的删除"><a href="#多维数组的删除" class="headerlink" title="多维数组的删除"></a>多维数组的删除</h3><p>&emsp;&emsp;多维数组的创建我们是通过一层层 <code>new</code> 来实现的。同样的，删除我们也是要一层层来实现的。显然，我们正着创建多维数组，那么删除的时候就要倒着一层层来删除，否则，假设我们将前面的内存块给删了，由于他们保存着其他内存块首地址，删了他们我们就无法访问这些内存块了。因此，我们要先顺藤摸瓜，找到最根源的内存块，再一步步倒回来全部删干净。<br>&emsp;&emsp;而删除一个内存块，我们可以使用 <code>delete[] arr</code> 来实现。</p>
<h3 id="C-的具体实现"><a href="#C-的具体实现" class="headerlink" title="C++ 的具体实现"></a><code>C++</code> 的具体实现</h3><p>&emsp;&emsp;具体的实现代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-D array</span></span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-D array</span></span><br><span class="line">    <span class="type">int</span> **arr2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr2d[<span class="number">0</span>][<span class="number">40</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-D array</span></span><br><span class="line">    <span class="type">int</span> ***arr3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr3d[i] = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; ++j) &#123;</span><br><span class="line">            arr3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr3d[<span class="number">40</span>][<span class="number">30</span>][<span class="number">20</span>] = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 1-D</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 2-D</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr2d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><p>&emsp;&emsp;由上述我们可以知道，每一个内存块内部的数据是连续的，<strong>但是，不同的内存块之间并不一定是连续的。</strong>这取决于操作系统的分配，很大程度上是不会连续的。因此，创建了多维数组之后，后续在索引具体某一个元素的值的时候，可能会出现 <code>cache miss</code>，也就是缓存不命中的情况，这会使得我们程序的运行速度变慢。因此，并不推荐使用多维数组。取而代之，我们可以将数组扁平化，例如使用一维数组来代替二维数组，这会使得所有的数据在内存中全部连续，大大加快了读写的速度。例如 <code>arr2d[i][j]</code> 可以写作 <code>arr[i * col + j]</code> 的形式。</p>
<h2 id="安全编程，关于智能指针与原始指针的使用"><a href="#安全编程，关于智能指针与原始指针的使用" class="headerlink" title="安全编程，关于智能指针与原始指针的使用"></a>安全编程，关于智能指针与原始指针的使用</h2><p>&emsp;&emsp;智能指针是对原始指针的包装，能够自动管理内存，在我们不再需要某一块内存时能够自动释放，减少了程序员的工作量，同时避免了因疏忽导致的内存泄漏问题。在进行一些大型或生产项目的时候，推荐使用智能指针进行内存管理。<br>&emsp;&emsp;但原始指针使用起来更加方便、简单，只需要一个小小的 <code>*</code> 即可。在写一些较小的项目、编程测试时，还是可以使用的。并且，使用原始指针能够让我们对内存管理等有更加清晰深刻的理解。</p>
<h2 id="跟踪内存分配的简单方法"><a href="#跟踪内存分配的简单方法" class="headerlink" title="跟踪内存分配的简单方法"></a>跟踪内存分配的简单方法</h2><p>&emsp;&emsp;无需借助外部工具，我们可以通过重载 <code>new</code> 和 <code>delete</code> 来实现跟踪内存分配与释放的情况。以下是一个简单的示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序运行结果：</p>
<div class="note info flat"><p><strong>注意在 <code>g++</code> 中，默认使用的 <code>delete</code> 函数是不带有第二个参数 <code>size_t size</code> 的，因为这一信息已经会被内部的内存管理器保留，无需再次传入。但我们要想探测内存释放的情况，还是有必要传入的。我们可以通过对编译时传入参数 <code>fsized-deallocation</code> 来使用这一个版本的 <code>delete</code> 函数。</strong></p>
</div>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">Allocating 32 bytes</span><br><span class="line">Allocating 12 bytes</span><br><span class="line">freeing 12 bytes</span><br></pre></td></tr></table></figure>

<p>我们可以进一步将其进行包装成一个类或结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics s_AllocationMetrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalAllocated += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalFreed += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintCurrentUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current Usage: &quot;</span> &lt;&lt; s_AllocationMetrics.<span class="built_in">CurrentUsage</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">        <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针的概念"><a href="#函数指针的概念" class="headerlink" title="函数指针的概念"></a>函数指针的概念</h3><p>&emsp;&emsp;“函数指针” 和 “指针函数” 是不同的概念，所谓的 “指针函数” 就是指一个返回类型是指针的函数，例如 <code>int *func(int a)</code> 返回类型是 <code>int *</code>，即一个指针，没啥好讲的，此处略过，重点来看 “函数指针”。</p>
<p>&emsp;&emsp;学过一点计算机体系结构或偏底层的汇编知识应该知道，函数名称其实就是一个地址。每次我们调用函数的时候，实际上就是保存当前帧 (frame) 的状态，将参数压栈，然后跳到函数名称所指的地址处，将传入的参数弹出使用，执行内部的代码。在 <code>C++</code> 中，我们可以额外定义变量，来调用使用其他的函数，具体的示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[value]: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>);</span><br><span class="line">    func_ptr = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr2)(<span class="type">int</span>) = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr2</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    <span class="type">void</span> *addr = (<span class="type">void</span> *)printValue;</span><br><span class="line">    ((<span class="built_in">void</span> (*)(<span class="type">int</span>))addr)(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addition</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;function address: &quot;</span> &lt;&lt; (<span class="type">void</span> *)printValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; printValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们定义了一个打印值的函数 <code>printValue(int)</code>，之后我们定义函数指针 <code>func_ptr</code>，我们要指定返回类型，以及参数列表。只要能和它这两者相匹配的，我们便可以对其赋值，并使用这个函数指针来调用函数。<br>&emsp;&emsp;<code>case 1</code> 是先定义，然后在后续再赋值使用；<code>case 2</code> 是在定义的时候就直接赋值使用了；而 <code>case 3</code> 则是我们可以强行取函数的地址，之后再将这个地址强制转成对应的函数指针类型，也是可以正常使用的，不过这样做除了装一下没啥实际意义。</p>
<div class="note danger flat"><p>注意，我们在取函数的地址的时候，一定要使用 <code>void *</code> 进行类型的强制转换，否则仅仅放一个函数指针的话，会执行内部的 <code>bool()</code> 运算符，将其转为一个布尔值，并且永远都是 <code>true</code>。<br>警告信息：<em><strong>warning: address of function ‘printValue’ will always evaluate to ‘true’ [-Wpointer-bool-conversion]</strong></em></p>
</div>

<p>&emsp;&emsp;<code>C++</code> 内部做了隐式转换，因此无论是下面代码中的哪两种，都是可以正常运行的。函数名在大多数的上下文里都会被隐式转成函数指针。函数名的签名为 <code>void printValue(int a)</code>，而函数指针的签名为 <code>void (*func_ptr)(int a)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func_ptr = printValue;</span><br><span class="line">func_ptr = &amp;printValue;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line">(*func_ptr)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数指针的应用场景"><a href="#函数指针的应用场景" class="headerlink" title="函数指针的应用场景"></a>函数指针的应用场景</h3><p>&emsp;&emsp;例如我们现在有了一个 <code>vector</code>，以及一个遍历函数 <code>forEach()</code>，我们可以在 <code>forEach()</code> 函数中传入一个函数指针，表明我们想在遍历的时候做什么操作，例如最简单的只是打印每个元素，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    forEach(vec, printVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶-——-lambda-表达式"><a href="#进阶-——-lambda-表达式" class="headerlink" title="进阶 —— lambda 表达式"></a>进阶 —— <code>lambda</code> 表达式</h3><p>&emsp;&emsp;<code>lambda</code> 表达式是一种创建函数的方式，可以使我们不必实际创建函数。也就是这个函数更像是一个变量，而非真正意义上的函数。<strong>在能够使用函数指针的地方，我们都可以使用 <code>lambda</code> 表达式。</strong><br>&emsp;&emsp;我们希望能够将一个函数传递给一个 <code>API</code>，以便在将来的某个时候，它能够为我们调用这个函数解决问题。此刻我们不这样做的原因是我们还没有函数执行所需要用到的数据，或者我们只是想推迟函数的执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line">    forEach(vec, lambda);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当捕获列表 <code>[]</code> 为空的时候，<code>C++</code> 内部会为我们调用转换函数 <code>ClosureType::operator ret(*)(params)()</code> 将 <code>lambda</code> 表达式转成不同的函数指针，但当捕获列表不为空的时候，我们就不能使用普通的函数指针了，这个时候就需要用到 <code>&lt;functional&gt;</code> 库。</p>
<p>&emsp;&emsp;下面举一个实际能够用到 <code>lambda</code> 表达式的例子。例如，我们调用 <code>std::find_if</code> 库，取得一个 <code>vector</code> 中第一个大于 3 的数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func_ptr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> val) &#123;<span class="keyword">return</span> val &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>lambda</code> 表达式的捕获列表形式如下表所示，节选自 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">cpp reference</a></p>
<table>
<thead>
<tr>
<th>syntax</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td><code>identifier</code></td>
<td>simple by-copy capture</td>
</tr>
<tr>
<td><code>identifier ...</code></td>
<td>simple by-copy capture that is a pack expansion</td>
</tr>
<tr>
<td><code>identifier initializer</code></td>
<td>by-copy capture with an initializer <font color="darkgreen"><strong>(since C++14)</strong></font></td>
</tr>
<tr>
<td><code>&amp; identifier</code></td>
<td>simple by-reference capture</td>
</tr>
<tr>
<td><code>&amp; identifier ...</code></td>
<td>simple by-reference capture that is a pack expansion</td>
</tr>
<tr>
<td><code>&amp; identifier initializer</code></td>
<td>by-reference capture with an initializer <font color="darkgreen"><strong>(since C++14)</strong></font></td>
</tr>
<tr>
<td><code>this</code></td>
<td>simple by-reference capture of the current object</td>
</tr>
<tr>
<td><code>* this</code></td>
<td>simple by-copy capture of the current object <font color="darkgreen"><strong>(since C++17)</strong></font></td>
</tr>
<tr>
<td><code>... identifier initializer</code></td>
<td>by-copy capture with an initializer that is a pack expansion <font color="darkgreen"><strong>(since C++20)</strong></font></td>
</tr>
<tr>
<td><code>&amp; ... identifier initializer</code></td>
<td>by-reference capture with an initializer that is a pack expansion <font color="darkgreen"><strong>(since C++20)</strong></font></td>
</tr>
</tbody></table>
<h2 id="栈-stack-vs-堆-heap"><a href="#栈-stack-vs-堆-heap" class="headerlink" title="栈 stack vs 堆 heap"></a>栈 <code>stack</code> vs 堆 <code>heap</code></h2><p>&emsp;&emsp;尽管堆和栈是不同的概念，但在物理层面，它们是相同的，都是一块 <code>RAM</code> 内存，只是我们认为将其进行了区分（<strong>因此栈内存分配并不是在 <code>CPU</code> 缓存上，而是在计算机的 <code>RAM</code> 上的</strong>）每个应用程序运行的时候，操作系统都会给我们分配一定区域的堆栈空间供我们使用。一般情况下，我们直接声明定义的变量都是在栈 <code>stack</code> 上的，只有调用 <code>new</code> 动态分配内存声明定义的变量才是在堆上的。<br>&emsp;&emsp;在栈上分配内存是十分快捷的，可以在一个指令时间内完成。因为我们所需要做的仅仅只是将栈顶指针指向的空间内赋予有效数据，然后再将栈顶指针进行移动即可。而在堆上分配就会十分的慢了，因为我们要使用 <code>new</code> 命令分配内存，然后 <code>new</code> 命令调用 <code>malloc</code> 函数询问相应的操作系统分配所需大小的内存空间，操作系统再通过查询空闲内存表来确定要分配哪一块内存。因此会涉及到许多的底层操作，分配起来就会很慢。<br>&emsp;&emsp;同时，访问速度上，由上述我们可以得知，栈上分配的内存一般都是连续的，因为我们的栈顶指针 <code>SP</code> 一直是在连续自增或自减的。因此，我们访问时一般所有的数据都是连续存放在一起的，访问一个数据的同时很容易就能访问到另一个数据，这在我们想要访问不同数据时可以加快访问的速度。对比之下，在堆上就不是这么一回事了，因为我们每次调用 <code>malloc</code>，都是取决于操作系统根据空闲内存表决定给我们分配哪一块内存，谁都不能保证两次调用的 <code>malloc</code> 返回的内存空间是连续在一起的。因此访问起来就会慢很多，涉及到 <font color="skyblue"><strong>缓存不命中 (cache missed)</strong></font> 问题。<br>&emsp;&emsp;因此，一般来说，我们尽可能要在栈上分配内存，除非我们<strong>想要一个变量的生命周期要比其所在的函数（作用域）长</strong>（因为栈上分配的内存的生命周期都在一个作用域内。例如我们在一个函数 <code>f</code> 内声明了一个变量，那么当这个函数结束返回的时候，栈顶指针便会直接恢复到之前调用 <code>f</code> 之前的位置，也就会造成 <code>f</code> 内的栈上变量无效，对应的生命周期结束），或者<strong>实在是有比较大的数据量</strong>，我们会想要在堆上分配内存。<br>&emsp;&emsp;总的来说，造成堆和栈区别的本质原因在于 “分配”。<br>&emsp;&emsp;文章推荐：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_47324800/article/details/134674765">堆和栈的效率比较</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Ardbr.github.io">creat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/">https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Ardbr.github.io" target="_blank">creat's HomePage</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="C++ 学习——数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++ 学习——数据结构</div></div><div class="info-2"><div class="info-item-1">vector优化部分&emsp;&emsp;分析下述代码，找出可以优化的地方： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Data &#123;public:    Data(int val = 0) : val(val) &#123;&#125;    int val = 0;&#125;;void printVector(std::vector&lt;Data&gt; vec) &#123;    for (int i = 0; i &lt; vec.size(); ++i) &#123;        std::cout &lt;&lt; vec[i].val &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;&#125;int main(void) &#123;    std::vector&lt;Data&gt; vec;    for (int i = 0; i &lt;...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/" title="C++ 学习——线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++ 学习——线程</div></div><div class="info-2"><div class="info-item-1">线程的基本使用&emsp;&emsp;线程的作用：优化程序，可以让程序在同一时间能够执行多个指令，加快程序的运行速度。&emsp;&emsp;要使用进程，首先需要引入头文件 #include &lt;thread&gt;  创建进程，使用 std::thread threadName(functionPointer)，需要传入一个函数指针，表示想要执行的操作的函数。 让某些指令需要在该线程执行完之后再执行，使用 threadName.join()，该函数后面的函数只有在这个进程结束后才会执行。 在一个进程中，可以使用 std::this_thread 来表示当前的进程，可用其中的 get_id() 函数来获取当前进程的 id，使用 sleep_for() 来将进程延时，防止某个进程单独消耗 CPU 过多的资源。  12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;thread&gt;static bool isFinished =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++ 学习——一些新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-22</div><div class="info-item-2">C++ 学习——一些新特性</div></div><div class="info-2"><div class="info-item-1">结构化绑定&emsp;&emsp;这是在 C++17 中新引入的特性，用于处理函数多返回值的问题。在旧版本的 C++ 中，如果我们想要处理一个函数具有多返回值，而且返回值的类型可能不同时，我们可以通过结构体、pair 或者 tuple 的形式，但他们都十分地繁琐，不管是对于函数返回类型还是接收部分处理。以下是一个使用 tuple 的简单示例： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;tuple&gt;std::tuple&lt;std::string, int&gt; createPerson() &#123;    return &#123;&quot;Cherno&quot;, 24&#125;;&#125;int main(void) &#123;    std::tuple&lt;std::string, int&gt; person = createPerson();    std::string name =...</div></div></div></a><a class="pagination-related" href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/" title="C++ 学习——关键字"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-28</div><div class="info-item-2">C++ 学习——关键字</div></div><div class="info-2"><div class="info-item-1">static前置🧀&emsp;&emsp;在学习 static 之前，我们应该知道以下的知识点：  变量的作用域 (scope)：表明一个变量是否能够被访问。它包含了两大部分： (1) 局部或块作用域 (Local or Block Scope)。 (2) 全局作用域 (Global Scope)。 变量的持续时间 (duration)：表明一个变量何时创建以及何时销毁。它也包含了两大部分： (1) 自动存储持续时间 (Automatic Storage Duration)（对于具有本地或块作用域的变量，出了这个作用域后就会自动销毁）。 (2) 静态存储时间 (Static Storage Duration)（对于具有全局作用域的变量或带有静态说明符的局部变量（在函数或代码块中））。 链接 (linkage)：确定变量是否可以在另一个文件中访问（或链接）。它有两种类型： (1) 内部链接 (Internal Linkage)（对于具有块作用域和全局作用域 &#x2F; 文件作用域 &#x2F; 全局命名空间作用域的变量）。 (2) 外部链接 (Enternal...</div></div></div></a><a class="pagination-related" href="/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" title="C++ 学习——命名空间"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">C++ 学习——命名空间</div></div><div class="info-2"><div class="info-item-1">命名空间 namespace&emsp;&emsp;在 C 中，我们只能通过给函数名称前加上独有的前缀来避免命名冲突，例如对于 GLFW 库，这是一个 C 库，其中的所有函数都是以 GLFW 开头，例如 GLFWInit()。同样的还有 OpenGL 库，例如 glInit() 等。&emsp;&emsp;在 C++ 中，我们可以通过命名空间来解决多个相同函数名命名冲突的问题。&emsp;&emsp;using namespace 只在当前作用域中有效。尽量不要乱用，可以仅在一个 if 语句中使用，实在不行再考虑加到源文件的开头，但永远不要用在头文件中！ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;namespace apple &#123;    namespace function &#123;        void print2(const std::string &amp;str) &#123;            std::cout &lt;&lt; str...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="C++ 学习——基本数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——基本数据类型</div></div><div class="info-2"><div class="info-item-1">string 字符串SSO（小字符串优化）&emsp;&emsp;众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用 const char *，也要尽量避免使用 std::string。C++ 意识到了这一点，因此对于小字符串做了一定的优化。&emsp;&emsp;具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是仅仅分配到缓冲区的栈上，借此来加快程序的运行。这个具体的内部给定参考值依据不同平台有所变化，可能是 15 或 23 或其他值。一旦严格超过了这个值，就会触发动态分配 Alloc 机制。 类型双关定义&emsp;&emsp;维基百科对类型双关的定义是这样：类型双关是计算机科学的术语，指任何编程技术能颠覆或者绕过一门程序设计语言的类型系统，以达成在形式语言内部难以甚至不可能实现的效果。 用法&emsp;&emsp;首先，下面的这种操作并不是类型双关。 12345678910#include &lt;iostream&gt;int main(void) &#123;    int a =...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="C++ 学习——数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——数据结构</div></div><div class="info-2"><div class="info-item-1">vector优化部分&emsp;&emsp;分析下述代码，找出可以优化的地方： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Data &#123;public:    Data(int val = 0) : val(val) &#123;&#125;    int val = 0;&#125;;void printVector(std::vector&lt;Data&gt; vec) &#123;    for (int i = 0; i &lt; vec.size(); ++i) &#123;        std::cout &lt;&lt; vec[i].val &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;&#125;int main(void) &#123;    std::vector&lt;Data&gt; vec;    for (int i = 0; i &lt;...</div></div></div></a><a class="pagination-related" href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/" title="C++学习——杂项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-23</div><div class="info-item-2">C++学习——杂项</div></div><div class="info-2"><div class="info-item-1">C++ 的参数计算顺序123456789101112#include &lt;iostream&gt;int sum(int a, int b) &#123;    std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; (a + b) &lt;&lt; std::endl;&#125;int main(void) &#123;    int value = 0;    sum(value++, value++);    return 0;&#125;  &emsp;&emsp;运行结果： 12345678910(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o mainmain.cpp:5:1: warning: non-void function does not return a value...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">creat</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ardbr"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Ardbr" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">静待春节ing 🥰🥰</div></div><div class="card-widget card-countdown"><div class="countdown-mask"><div class="text-container"><p>距离 2025 年春节: </p><span class="countdown-number">xx</span><span class="countdown-unit">天</span></div><div class="current-time-container"> <span class="current-time"></span></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%88%A0%E9%99%A4"><span class="toc-number">1.</span> <span class="toc-text">多维数组的创建及删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">1 维数组的动态分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2 维数组的动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.3.</span> <span class="toc-text">3 维数组的动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.</span> <span class="toc-text">多维数组的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">C++ 的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">注意的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%85%B3%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">安全编程，关于智能指针与原始指针的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">跟踪内存分配的简单方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">函数指针的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.</span> <span class="toc-text">函数指针的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-%E2%80%94%E2%80%94-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">进阶 —— lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88-stack-vs-%E5%A0%86-heap"><span class="toc-number">5.</span> <span class="toc-text">栈 stack vs 堆 heap</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%954%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E9%83%A8%E5%88%86/" title="Hexo-butterfly 魔改记录4——主页部分">Hexo-butterfly 魔改记录4——主页部分</a><time datetime="2024-12-11T09:13:04.000Z" title="发表于 2024-12-11 17:13:04">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/" title="C++ 学习——关键字">C++ 学习——关键字</a><time datetime="2024-11-28T07:31:04.000Z" title="发表于 2024-11-28 15:31:04">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/27/Unix-1-shell/" title="Unix-1-shell">Unix-1-shell</a><time datetime="2024-11-27T12:04:50.000Z" title="发表于 2024-11-27 20:04:50">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/" title="C++ 学习——算法">C++ 学习——算法</a><time datetime="2024-11-26T10:48:02.000Z" title="发表于 2024-11-26 18:48:02">2024-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/" title="C++学习——杂项">C++学习——杂项</a><time datetime="2024-11-23T08:03:56.000Z" title="发表于 2024-11-23 16:03:56">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By creat</div><div class="footer_custom_text">很高兴你能看到这里！</div></div></footer></div><div id="leftside-fps"><span id="leftside-fps-text"></span></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src=/js/sakuraPlus.js></script><script src=/js/parseLyric.js></script><script src=/js/music.js></script><script src=/js/getFps.js></script><script src=/js/countdown.js></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>