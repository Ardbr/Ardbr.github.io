<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ 学习——基本数据类型 | creat's HomePage</title><meta name="author" content="creat"><meta name="copyright" content="creat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="string 字符串SSO（小字符串优化）&emsp;&emsp;众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用 const char *，也要尽量避免使用 std::string。C++ 意识到了这一点，因此对于小字符串做了一定的优化。&emsp;&emsp;具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习——基本数据类型">
<meta property="og:url" content="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="creat&#39;s HomePage">
<meta property="og:description" content="string 字符串SSO（小字符串优化）&emsp;&emsp;众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用 const char *，也要尽量避免使用 std::string。C++ 意识到了这一点，因此对于小字符串做了一定的优化。&emsp;&emsp;具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ardbr.github.io/img/avatar.gif">
<meta property="article:published_time" content="2024-11-20T13:11:36.000Z">
<meta property="article:modified_time" content="2024-11-29T02:53:26.230Z">
<meta property="article:author" content="creat">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ardbr.github.io/img/avatar.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":10,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":"mac"},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 学习——基本数据类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4746832_eb25gdpzci6.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" alt="Logo"><span class="site-name">creat's HomePage</span></a><a class="nav-page-title" href="/"><span class="site-name">C++ 学习——基本数据类型</span></a></span><div id="music-bar"><div id="music-cover-container"><div id="music-cover"></div></div><div id="music-button-container"><div id="music-button-container-top"><span class="music-icon iconfont icon-shangyishou" id="music-prev"></span><span class="music-icon iconfont icon-bofang" id="music-playOrPause"></span><span class="music-icon iconfont icon-xiayishou" id="music-next"></span><span class="music-icon iconfont icon-liebiaoxunhuan" id="music-mode"></span></div><div id="music-button-container-bottom"><div id="music-progressBar"><span id="music-currentProgress"></span><span id="music-dot"></span></div><span id="music-progressText">00:00 / 00:00</span></div></div><div id="music-name-container"><span id="music-name"></span></div><div id="music-lyric-container"><span id="music-lyric"></span></div></div><div id="menus"><div id="toggle-menu"><span class="site-page"></span><i class="fas fa-bars fa-fw"></i></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><i class="fa-fw fas fa-book"></i><span> 学习资料</span></a></div><div class="menus_item"><a class="site-page" href="/link"><i class="fa-fw fas fa-globe"></i><span> 常用网站</span></a></div></div><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">C++ 学习——基本数据类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-20T13:11:36.000Z" title="发表于 2024-11-20 21:11:36">2024-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-29T02:53:26.230Z" title="更新于 2024-11-29 10:53:26">2024-11-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a><code>string</code> 字符串</h2><h3 id="SSO（小字符串优化）"><a href="#SSO（小字符串优化）" class="headerlink" title="SSO（小字符串优化）"></a>SSO（小字符串优化）</h3><p>&emsp;&emsp;众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用 <code>const char *</code>，也要尽量避免使用 <code>std::string</code>。<code>C++</code> 意识到了这一点，因此对于小字符串做了一定的优化。<br>&emsp;&emsp;具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是仅仅分配到缓冲区的栈上，借此来加快程序的运行。这个具体的内部给定参考值依据不同平台有所变化，可能是 15 或 23 或其他值。一旦<strong>严格超过</strong>了这个值，就会触发动态分配 <code>Alloc</code> 机制。</p>
<h2 id="类型双关"><a href="#类型双关" class="headerlink" title="类型双关"></a>类型双关</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;维基百科对类型双关的定义是这样：类型双关是计算机科学的术语，指任何编程技术能颠覆或者绕过一门程序设计语言的类型系统，以达成在形式语言内部难以甚至不可能实现的效果。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;首先，下面的这种操作并不是类型双关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = a;   <span class="comment">// equal to: double b = (double)a</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;    <span class="comment">// output: 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因为 <code>a</code> 和 <code>b</code> 本质是两段内存，而且里面存的数据并不一样，只是各自能够通过自己的类型解读成相同的数值 <code>50</code>。例如 <code>a</code> 在内存中占用 4 个字节，按小端序为 <code>32 00 00 00</code>，而 <code>b</code> 在另一段内存中占用 8 个字节，小端序为 <code>00 00 00 00 00 00 49 40</code>。</p>
<p>&emsp;&emsp;真正的“类型双关”是我能够让<strong>同一段数据</strong>既能够按照 <code>int</code> 类型进行读取，也能够按照 <code>double</code> 的类型进行读取，尽管不同读取方式读取出的内容可能不同。</p>
<p>&emsp;&emsp;那么如何做到这一点呢？使用指针！我们可以先把这个变量取地址，之后我们再对这个地址进行处理，我们让它按照另一个类型的方式取内存地址，之后再解引用，取得该变量的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = *(<span class="type">double</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此处 <code>b</code> 的值并不固定，因为 <code>a</code> 的类型是 <code>int</code>，而 <code>int</code> 一般是占用 4 个字节，而 <code>double</code> 一般占用 8 个字节，因此紧跟在 <code>a</code> 的内存后面还有 4 个字节会被使用到，而每次运行分配的内存不同，后面紧跟的内存中的值也会不同，因此 <code>b</code> 的值不确定。<strong>一般情况下由于引用了未分配定义的额外内存，会导致程序崩溃！</strong></p>
<p>&emsp;&emsp;掌握了这种方法，对于内存如果有更深刻的理解，我们可以做一些更加 crazy 的操作。例如对于一个结构体 <code>Pos</code> 做下述的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pos</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pos pos&#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.x</span></span><br><span class="line">    <span class="type">int</span> pos_x = *(<span class="type">int</span> *)&amp;pos;</span><br><span class="line">    <span class="type">int</span> pos_x2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">0</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_x2 &lt;&lt; std::endl;  <span class="comment">// output: 3, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.y</span></span><br><span class="line">    <span class="type">int</span> pos_y = *(<span class="type">int</span> *)((<span class="type">char</span> *)&amp;pos + <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> pos_y2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_y2 &lt;&lt; std::endl;  <span class="comment">// output: 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="联合体-Union"><a href="#联合体-Union" class="headerlink" title="联合体 Union"></a>联合体 <code>Union</code></h2><p>&emsp;&emsp;多个变量共用同一块内存，改变了其中一个变量的值，其他变量的值同样也会跟随变化。多个变量可以是不同的类型，这样读取的时候就相当于进行了类型双关的操作了。<del>经过 <code>g++</code> 编译器实测，两者的大小不同时也并不会报错，应该也是进行了内存越界访问，与类型双关类似。</del><strong>更正：<code>union</code> 的大小取决于其中最大的那个变量类型。</strong><br>&emsp;&emsp;一般来说 <code>union</code> 是匿名使用的，而匿名 <code>union</code> 不能够有成员函数。<br>&emsp;&emsp;例如对于如下的代码，我们发现其实 <code>Vector4</code> 是可以使用 <code>Vector2</code> 的打印函数 <code>print_vector2</code> 进行打印的，无非是将其分成两个 <code>Vector2</code> 类型即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, w, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么我们如何做到这一点呢？答案是使用 <code>union</code>，我们对 <code>Vector4</code> 内部可以声明一个别名，就是两个 <code>Vector2</code>，它们和正常的那 4 个 <code>int</code> 数据占用的是同一块内存，因此修改其中一方，另一方也会进行修改，并且没有引入额外的内存或副本。当然，我们也可以利用前面刚学习的类型双关技术，强制将 <code>Vector4</code> 转成两个 <code>Vector2</code> 进行读取，此处就不展开了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// form 1</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">int</span> x, y, w, v;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// form 2</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            Vector2 a, b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Vector4 vec4&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>w &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>v &lt;&lt; std::endl;</span><br><span class="line">    vec<span class="number">4.</span>x = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>a);</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意 <code>struct</code> 和 <code>union</code> 这些匿名使用的时候，只是作为了一种数据结构在使用，由于没有名称，在结构体或类的内部使用时也无法使用 <code>.name.member_var</code> 获取内部的成员变量，可以直接 <code>.member_var</code> 获取。例如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Union</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Union u = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>&emsp;&emsp;<code>C++</code> 是一种强类型语言，每一个变量必须对应有自己的数据类型，但不同的数据类型之间一般是可以进行类型转换的。早在 <code>C</code> 中，我们便可以使用例如如下的代码进行转换，我们称之为 <code>C-style</code> 类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a = <span class="number">5.4</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (int)a = 5</span></span><br><span class="line">    <span class="type">double</span> c = (<span class="type">int</span>)a + b;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;    <span class="comment">// output: 10.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而在 <code>C++</code> 中，我们共有四种类型转换的函数可供使用，分别是 <code>static_cast&lt;&gt;</code>、<code>reinterpret_cast&lt;&gt;</code>、<code>dynamic_cast&lt;&gt;</code>、<code>const_cast</code>。</p>
<div class="note info flat"><p><code>C++</code> 的这些不过只是语法糖，只能能做 <code>C-style</code> 能做的一切而已。它可能会做其他的事情，但实际的结果也只是一个成功的类型转换而已。</p>
</div>

<ul>
<li><code>static_cast&lt;&gt;</code> 为静态类型转换，是最一般的用法，它会做一些编译时检查，看看这种转换是否真的可能。</li>
<li><code>reinterpret_cast&lt;&gt;</code> 类似类型双关，是要将这一段内存重新解释为其他数据类型。</li>
<li><code>const_cast&lt;&gt;</code> 移除或添加变量的 <code>const</code> 限定。</li>
<li><code>dynamic_cast&lt;&gt;</code> 运行时检查某种转换是否能够发生。</li>
</ul>
<p>&emsp;&emsp;搞这么多 <code>cast</code> 的好处是，除了可能收到那些编译时检查之外，还可以在代码库中搜索它们，便于全部替换某种类型转换。同时，还能帮助我们减少在尝试类型转换的时候可能会意外犯的错误，例如类型不兼容。</p>
<p>&emsp;&emsp;对于如下代码，我们显然知道一个 <code>double</code> 数据是不能够转成一个我们自定义的类的，因此使用 <code>static_cast</code> 会直接在编译期间报错。而我们使用 <code>reinterpret_cast</code> 便可以以重新解读该内存的方式进行转换。<br>&emsp;&emsp;对于 <code>dynamic_cast</code>，这是在运行时进行类型检查，它与运行时类型信息 RTTI 紧密相关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">5.23</span>;</span><br><span class="line">    <span class="comment">// wrong</span></span><br><span class="line">    <span class="type">double</span> s = <span class="built_in">static_cast</span>&lt;AnotherDerived&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s2 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s3 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successs</span></span><br><span class="line">    <span class="type">double</span> s4 = <span class="built_in">reinterpret_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    Base *base = derived;</span><br><span class="line"></span><br><span class="line">    AnotherDerived *ad = <span class="built_in">dynamic_cast</span>&lt;AnotherDerived *&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (!ad) std::cout &lt;&lt; <span class="string">&quot;failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;convert successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;运行上述代码，最后的 <code>ad</code> 为空，输出 <code>failed.</code>。因为它是一个 <code>Derived</code> 类型，我们不能先用父类接收它，然后反手把它转成 <code>AnotherDerived</code> 的。这里并不会在编译阶段报错，我们需要在运行时手动捕获观察。</p>
<h2 id="dynamic-cast-再探"><a href="#dynamic-cast-再探" class="headerlink" title="dynamic_cast 再探"></a><code>dynamic_cast</code> 再探</h2><p>&emsp;&emsp;<code>dynamic_cast</code> 更像是一个函数，因为它不是在编译时检查，而是在运行时进行类型检查，因此有相关的运行成本。它是专门用于沿继承层次结构进行的强制类型转换，例如从子类到父类，或者从父类到子类的转换。如果是子类转成父类，过程相对简单，甚至不需要 <code>static_cast</code> 也可以隐式转换。但反过来就会有问题了。例如我有一个 <code>Entity</code> 实体类，表示游戏中的所有实体，<code>Enemy</code> 和 <code>Player</code> 都继承自它。那么我现在有一个 <code>Entity</code> 的指针，指向一个实体，我想把它转成 <code>Player</code> 类，是否可以做到？我们知道，这个 <code>Entity</code> 有 3 中可能，可能是 <code>Player</code>，也可能是 <code>Enemy</code>，还有可能是除这两者外的其他实体。因此我们需要判断是否能够进行转换，否则如果我们把一个 <code>Enemy</code> 转成了 <code>Player</code>，访问了 <code>Player</code> 的独有数据，就可能会造成程序的崩溃。</p>
<p>&emsp;&emsp;如果转换失败，那么会返回 <code>NULL</code>，否则，返回转换后指向这种类型的一个指针。</p>
<p>&emsp;&emsp;示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player *player = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it is easy to cast a derived class to base class.</span></span><br><span class="line">    Entity *e = player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong!!</span></span><br><span class="line">    <span class="comment">// Player *p = e;</span></span><br><span class="line"></span><br><span class="line">    Entity *actualEnemy = <span class="keyword">new</span> Enemy;</span><br><span class="line">    Entity *actualPlayer = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    Player *p1 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualEnemy);</span><br><span class="line">    Player *p2 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualPlayer);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (p1 == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (p2 == <span class="literal">nullptr</span>) &lt;&lt; std::endl;   <span class="comment">// output: 1, 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h2><p>&emsp;&emsp;<code>C++</code> 中可以为每一个类编写对应的类型转换操作符，考虑如下的代码场景。我们编写了 <code>ScopedPtr</code> 类，并且我们动态分配了内存给类内的指针 <code>m_Ptr</code> 成员变量。按照惯例，我们在分配之后都应该查看是否分配成功。对于一般的指针而言，我们可以直接写 <code>if (ptr) &#123;&#125;</code> 这类的判断语句。因为一个指针实际上就是一个整数，可以判断整数是否是 0 来做决定。但我们将指针包装进了一个类，对于类如何进行布尔判断，编译器并不知道应该怎么处理。我们当然可以编写 <code>bool isValid()</code> 函数，调用时写 <code>if (scopedPtr.isValid()) &#123;&#125;</code> 来判断。但这样太麻烦了，还要调用成员函数。能不能像之前那样只要把实例放进去就好了？答案是可以的，我们需要提供类的布尔运算符，这样后续有需要的话，就会自动调用该运算符将这个类转换成布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(T *ptr) : <span class="built_in">m_Ptr</span>(ptr) &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123; <span class="keyword">delete</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T *<span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ScopedPtr&lt;Entity&gt; e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    Entity *e2 = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左值-lvalue-和右值-rvalue"><a href="#左值-lvalue-和右值-rvalue" class="headerlink" title="左值 lvalue 和右值 rvalue"></a>左值 <code>lvalue</code> 和右值 <code>rvalue</code></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;<code>C++</code> 中的数据及表达式等还分为左值 <code>lvalue</code> 和右值 <code>rvalue</code>，但它们的定义并不是根据它们是在等号的左边还是右边，但大部分情况下也都是符合的。<strong>更多的人是这样认为的：左值是程序运行过程中在内存中明确有存储空间的，而右值则是临时变量，在内存中没有存储空间，使用后不久就会被销毁。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string firstName = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string lastName = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 4</span></span><br><span class="line">    std::string name = firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;例如对于上述代码：</p>
<ul>
<li><code>case 1</code> 中显然 <code>i</code> 是在内存有 <code>int</code> 型存储空间的，因此是左值，而右边的 <code>10</code> 则是个立即数，赋完值后就会消失。显然 <code>10 = i</code> 这种写法是大错特错的。</li>
<li><code>case 2</code> 中 <code>a</code> 和 <code>i</code> 都是左值，尽管 <code>i</code> 出现在等号的右边。</li>
<li><code>case 3</code> 中 <code>firstName</code> 和 <code>lastName</code> 都是左值，右边的字符串字面量都是右值。</li>
<li><code>case 4</code> 中，<code>firstName + lastName</code> 这个表达式整体是一个右值，取这两个左值的拼接字符串作为临时变量，用来初始化 <code>std::string name</code>。我们显然不会写出 <code>firstName + lastName = &quot;xxx&quot;</code> 这种语句。</li>
</ul>
<h3 id="与引用-的关系"><a href="#与引用-的关系" class="headerlink" title="与引用 &amp; 的关系"></a>与引用 <code>&amp;</code> 的关系</h3><p>&emsp;&emsp;<code>C++</code> 中有左值引用和右值引用。引用的原理就是取这块内存的地址，只不过不是指针的形式，而是包装成了仍使用原变量符号的形式。因此，我们不能有 <code>int&amp; a = 10</code> 这种操作，<strong>这会在编译期间报 “非常量引用的初始值必须为左值” 的错误。</strong>因为 <code>10</code> 本质上是没有内存空间的。但什么是 “非常量引用”？因为 <code>C++</code> 中允许我们对常量进行引用，这时候要用 <code>const int&amp; a = 10</code>，这时候就不会报错了，就像是你承诺了我虽然会引用这个数据，但是我不会对此进行修改，我不会把一个常量 <code>10</code> 变为 <code>1</code>，因为 <code>10</code> 就是 <code>10</code>。<br>&emsp;&emsp;常值引用的作用如下代码所述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;即我们有一个内存占用很大的对象，这里以 <code>string</code> 举例。我们要对其进行打印，要把它作为参数传入进去。我们知道由于对象很大，我们肯定不会选择拷贝一份用来打印，理想的方法是使用引用，这样可以避免拷贝复制。但这样就有问题了，这是一个非常量引用，它只能接收左值，例如上述代码，对于 <code>print(str)</code> 是可以正常运行的，但 <code>print(&quot;Hello, world)&quot;</code> 就不可以了，因为一个字符串字面量是右值。这时候，我们就可以修改 <code>print()</code> 函数的参数类型，改为 <code>const std::string &amp;</code>，这也是为什么大多数函数只要不是在内部修改参数的数据，都会选用 <code>const type &amp;</code> 的原因。</p>
<p>&emsp;&emsp;上述讲的都是左值引用，除此之外还有右值引用。一般来说，写函数的时候都会提供两个版本的函数，一个是 <code>const type &amp;</code> 常量引用版本的，用来处理左值引用，如有必要也可以处理右值引用。另一个版本是 <code>type &amp;&amp;</code>，这是专门用来处理右值引用的。那既然有了 <code>const type &amp;</code> 可以用来处理右值了，那为什么还要提供专门处理右值的版本呢？这主要在于程序的优化。如果我们知道传入的是一个临时对象的话，我们就不需要担心它是否完整，是否拷贝，我们可以简单无虑地使用它的资源，给到特定的对象，或者在其他地方使用它们，而不需要对其后果做考虑，因为反正不久后它也就会被销毁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[lvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;&amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[rvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">[lvalue] Hello, world</span><br><span class="line">[rvalue] Hello, world</span><br></pre></td></tr></table></figure>

<p>可以看到，对于传入一个右值，<code>type &amp;&amp;</code> 的调用优先级是要高于 <code>const type &amp;</code> 的。</p>
<h2 id="移动语句"><a href="#移动语句" class="headerlink" title="移动语句"></a>移动语句</h2><p>&emsp;&emsp;移动，即将一块内存从一个地方移动到另一个地方。但我们知道，内存就在那个地方，是无法移动的。因此，一种思路是将这块内存的数据搬到另一块内存，然后把原内存中的数据清空，这样就实现了移动的操作。但这种方法的时间复杂度为 $O(N)$。即如果有 $N$ 个字节，我们就需要移动 $N$ 次。<font color="darkred"><strong>其实还有另一种方法，那就是我们把指向新内存的指针搬过来，让它指向旧内存的首地址，这种只是修改了一个指针的指向，因此时间复杂度为 $O(1)$。但事情到这里还没有结束，因为此时我们如果要删除旧地址的指针，由于此时它还是指向这一块内存，这样就会顺带把这块内存数据给删去了，那么新的指针也无法工作了。因此，我们还要将旧的指针置为 <code>nullptr</code>。</strong></font>这种思路就是移动语句的思想。<br>&emsp;&emsp;因此一般来说，移动构造能够既节约内存（无需开辟新内存，可以将旧的将要废弃的内存直接拿过来用，不用再根据它复制开一块新的内存空间），又能节约时间（无需开辟新内存并复制过来，显然这是一项耗时的操作，而是直接修改一个指针的指向即可）。<br>&emsp;&emsp;下面通过一个具体的例子来讲解移动语句的好处。<br>&emsp;&emsp;我们需要创建两个类：</p>
<ul>
<li><p><strong>其一是自定义的 <code>String</code> 类。</strong></p>
<ul>
<li>我们首先定义了它的构造函数，一种是无参构造，按默认即可；一种是接收 <code>const char *</code> 字符串字面量来进行构造；还有一种是接收相同类型的 <code>const String &amp;</code> 进行拷贝构造。</li>
<li>其次我们定义一个打印函数 <code>Print()</code>，将字符串逐字符打印出来。</li>
<li>最后是简单的析构函数。</li>
</ul>
</li>
<li><p><strong>其二是用到 <code>String</code> 类的 <code>Entity</code> 类</strong></p>
<ul>
<li>构造函数方面，这里比较简单，<code>Entity</code> 类只有实体的名称，它的类型就是 <code>String</code>，因此我们只写一个接收字符串的构造函数即可，参数形式为 <code>const String &amp;</code>。</li>
<li>我们也定义了一个打印实体名称的函数，内部调用 <code>String</code> 的打印函数实现。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;接下来我们思考我们在 <code>main</code> 函数中定义一个 <code>Entity</code> 类的实例 <code>Entity e = Entity(&quot;Hello, world&quot;)</code> 时会发生什么。</p>
<ol>
<li>首先，<code>&quot;Hello, world&quot;</code> 要隐式转换为 <code>String</code> 类型，并且我们已经提供了相应的构造函数，此时动态分配了内存，会输出 <code>&quot;Created!&quot;</code>。</li>
<li>然后，调用 <code>Entity</code> 的构造函数，接收 <code>const String &amp;</code>，我们知道这是允许接收右值的。之后由其列表初始化功能 <code>m_Name(name)</code>，这里又会调用 <code>String(const String &amp;)</code> 的构造函数，即用一个 <code>String</code> 来初始化另一个 <code>String</code>，由 <code>String</code> 构造函数内部的代码可知，这里又会进行一次动态内存分配，会输出 <code>&quot;Copied!&quot;</code>。</li>
<li>之后由于 <code>&quot;Hello, world&quot;</code> 是一个右值，临时变量，完成了对 <code>Entity</code> 的构造之后，就会被销毁了，调用 <code>String</code> 的析构函数，释放这部分内存，输出 <code>&quot;Destroyed&quot;</code>。</li>
<li>后续作用域结束后，<code>e</code> 调用 <code>Entity</code> 的析构函数，释放它的内存。</li>
</ol>
<p>&emsp;&emsp;由上述的流程可知，我们为了定义一个 <code>Entity</code> 并将其初始化，一共进行了两次的动态内存分配，虽然有一次在初始化完成后就释放了，但复制内存生成新内存的时间是无法挽回的。从结果来看，我们只是动态分配了 <code>Entity</code> 里面的一个 <code>String</code> 而已，能不能只分配这一次内存呢？答案是可以的，只要用到移动语句即可，而它的思想就是我们在本节最开头加粗说的那样。<br>&emsp;&emsp;为了实现移动功能，我们需要添加一些代码。首先，我们的 <code>String</code> 构造函数仍然是正常接收一个 <code>const char *</code> 的字符串字面量，仍然正常分配动态内存生成一个 <code>String</code>。但是，当用这个 <code>String</code> 来初始化 <code>Entity</code> 中的实体名字字符串时，我们不能再让他与正常的分配过内存空间的字符串一样走 <code>String(const String &amp;str)</code> 这个构造函数。因为它实际上是一个右值，我们专门提供 <code>String(String &amp;&amp;str)</code> 来处理它。<br>&emsp;&emsp;因为这个 <code>String</code> 是一个右值，而所有的 <code>String</code> 都是有堆上的内存空间的，所以对于右值，这部分空间很快就要被释放的，我们可以用这块的内存直接来构造调用 <code>String(String &amp;&amp;)</code> 这个函数的字符串，省去了内存的分配、拷贝等步骤，只是简单的修改指针的朝向，更快速高效。<br>&emsp;&emsp;具体的代码见下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str.m_Data);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = str.m_Size;</span><br><span class="line">        m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">        str.m_Size = <span class="number">0</span>;</span><br><span class="line">        str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> m_Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; m_Data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_Data;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String &amp;name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(String &amp;&amp;name) : <span class="built_in">m_Name</span>((String &amp;&amp;)name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity e = <span class="built_in">Entity</span>(<span class="built_in">String</span>(<span class="string">&quot;Hello, world&quot;</span>));</span><br><span class="line">    e.<span class="built_in">PrintName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p><strong>注意在 <code>Entity(String &amp;&amp;name) : m_Name((String &amp;&amp;)name) {}</code> 中，列表初始化里还是要显性指定这是一个右值，否则还是会走 <code>const String &amp;</code> 常量引用的构造函数！而且比起 <code>(String &amp;&amp;)name</code>，更推荐使用 <code>std::move(name)</code></strong></p>
</div>
<p>&emsp;&emsp;总的来说就是一句话，右值不配拥有动态分配的内存空间，如果有，那可以将这块空间转交给别人继续使用，再留给它也是浪费了（指对于右值，一般存活时间不会很长，很快内存就会被释放）</p>
<h2 id="std-move-与移动赋值操作符"><a href="#std-move-与移动赋值操作符" class="headerlink" title="std::move 与移动赋值操作符"></a><code>std::move</code> 与移动赋值操作符</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a><code>std::move</code></h3><p>&emsp;&emsp;上一节中重点讲了移动构造，这一节主要讲移动赋值。首先来看一下 <code>std::move()</code>。上面也说了，<code>std::move()</code> 就是做了一个类型转换，将当前的变量类型标记为右值类型，通过 <code>static_cast</code> 实现，以下是 <code>std::move()</code> 的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_LIBCPP_NODISCARD_EXT <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt;&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_LIBCPP_LIFETIMEBOUND _Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt; _Up;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;大概能看到 <code>static_cast</code> 和右值符 <code>&amp;&amp;</code>，推测中间部分 <code>_Up</code> 就是原先变量的类型。当然，在简单情况下我们可以直接自行使用 <code>static_cast</code> 转换，但对于复杂数据类型情况尤其是使用了 <code>auto</code> 的情况下，既然 <code>C++</code> 本身给我们提供了更方便安全的转换函数，我们就安心的用吧！😌</p>
<h3 id="移动赋值操作符"><a href="#移动赋值操作符" class="headerlink" title="移动赋值操作符"></a>移动赋值操作符</h3><p>&emsp;&emsp;注意下述代码中的两个 <code>=</code> 是不同的含义！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2;</span><br><span class="line">str2 = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这第一个的 <code>=</code> 实际上是调用了 <code>String(const char *)</code> 构造函数，因此这是一个构造操作，并不是赋值操作。</li>
<li>而第二个是调用了无参构造函数，并在后续使用了一个字符串字面量进行赋值操作，这里才是真正的赋值操作，相当于 <code>str2.operator=(&quot;Hello, world!&quot;)</code>。</li>
</ul>
<p>&emsp;&emsp;因此要实现移动赋值操作，我们还需要提供 <code>String &amp;operator=(String &amp;&amp;str)</code> 移动赋值操作符的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String &amp;<span class="keyword">operator</span>=(String &amp;&amp;str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> m_Data;</span><br><span class="line"></span><br><span class="line">            m_Size = str.m_Size;</span><br><span class="line">            m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">            str.m_Size = <span class="number">0</span>;</span><br><span class="line">            str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这部分代码中，我们主要做的事情同移动构造函数，都是将当前实例的字符串指针以及长度赋值为右值的，然后把右值的置为空。<font color="darkred"><strong>但是，不同于构造函数是从头从无到有开始构造，赋值操作时当前的字符串可能有了自己的那一块内存，因此我们要先将这一块内存给释放掉，否则，更改了它的指针，这一块内存就无法获取，造成了内存泄漏。</strong></font><br>&emsp;&emsp;还有一点要注意的是，由于当前的字符串会释放自己之前的内存，<strong>我们要小心传入的右值是否就是当前字符串本身，如果是的话，那删除之后自身也无法获取右值的那些数据了，因为右值就是自己，一块全给删掉啦！</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Ardbr.github.io">creat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">https://ardbr.github.io/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Ardbr.github.io" target="_blank">creat's HomePage</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB/" title="C++ 学习——类与子类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++ 学习——类与子类</div></div><div class="info-2"><div class="info-item-1">虚析构函数&emsp;&emsp;对于一般成员函数来说，虚函数的意思就是这个函数可以被子类中的其他函数覆写。但对于析构函数来说，虚析构函数的意思是，不是覆写析构函数，而是加上一个新的析构函数。这是只在一个类具有子类的情况下我们才会要思考的地方。例如对于如下的代码，我们创建了两个类 Base 和继承自它的类 Derived。可以看到，它们都有对应的构造和析构函数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;class Base &#123;public:    Base() &#123;        std::cout &lt;&lt; &quot;Base Constructor.&quot; &lt;&lt; std::endl;    &#125;    ~Base() &#123;        std::cout &lt;&lt; &quot;Base Destructor.&quot; &lt;&lt; std::endl;   ...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="C++ 学习——数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++ 学习——数据结构</div></div><div class="info-2"><div class="info-item-1">vector优化部分&emsp;&emsp;分析下述代码，找出可以优化的地方： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Data &#123;public:    Data(int val = 0) : val(val) &#123;&#125;    int val = 0;&#125;;void printVector(std::vector&lt;Data&gt; vec) &#123;    for (int i = 0; i &lt; vec.size(); ++i) &#123;        std::cout &lt;&lt; vec[i].val &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;&#125;int main(void) &#123;    std::vector&lt;Data&gt; vec;    for (int i = 0; i &lt;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/" title="C++ 学习——一些新特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-22</div><div class="info-item-2">C++ 学习——一些新特性</div></div><div class="info-2"><div class="info-item-1">结构化绑定&emsp;&emsp;这是在 C++17 中新引入的特性，用于处理函数多返回值的问题。在旧版本的 C++ 中，如果我们想要处理一个函数具有多返回值，而且返回值的类型可能不同时，我们可以通过结构体、pair 或者 tuple 的形式，但他们都十分地繁琐，不管是对于函数返回类型还是接收部分处理。以下是一个使用 tuple 的简单示例： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;tuple&gt;std::tuple&lt;std::string, int&gt; createPerson() &#123;    return &#123;&quot;Cherno&quot;, 24&#125;;&#125;int main(void) &#123;    std::tuple&lt;std::string, int&gt; person = createPerson();    std::string name =...</div></div></div></a><a class="pagination-related" href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/" title="C++ 学习——关键字"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-28</div><div class="info-item-2">C++ 学习——关键字</div></div><div class="info-2"><div class="info-item-1">static前置🧀&emsp;&emsp;在学习 static 之前，我们应该知道以下的知识点：  变量的作用域 (scope)：表明一个变量是否能够被访问。它包含了两大部分： (1) 局部或块作用域 (Local or Block Scope)。 (2) 全局作用域 (Global Scope)。 变量的持续时间 (duration)：表明一个变量何时创建以及何时销毁。它也包含了两大部分： (1) 自动存储持续时间 (Automatic Storage Duration)（对于具有本地或块作用域的变量，出了这个作用域后就会自动销毁）。 (2) 静态存储时间 (Static Storage Duration)（对于具有全局作用域的变量或带有静态说明符的局部变量（在函数或代码块中））。 链接 (linkage)：确定变量是否可以在另一个文件中访问（或链接）。它有两种类型： (1) 内部链接 (Internal Linkage)（对于具有块作用域和全局作用域 &#x2F; 文件作用域 &#x2F; 全局命名空间作用域的变量）。 (2) 外部链接 (Enternal...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/" title="C++ 学习——内存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——内存</div></div><div class="info-2"><div class="info-item-1">多维数组的创建及删除1 维数组的动态分配内存&emsp;&emsp;直接使用 new 关键字进行分配，指令为 int *arr = new int[50]，这会分配一块连续的 50 个 int 大小的内存空间，并且返回这块内存的首地址给到 arr，arr 的类型为 int *。 2 维数组的动态内存分配&emsp;&emsp;首先我们需要分配一块内存空间 a，这块内存空间中的每一个值都是一个地址，指向另一块内存空间 b_i 的首地址，这样，我们便实现了二维数组的创建。例如，对于一个二维数组 arr2d[i][j]，首先，我们取 a[i] 中的值，这便是一个地址，我们顺着这个地址就能够找到第 i 块内存 b_i，之后我们锁定了这块内存。而由二维数组可知，这一块内存中每个里面存的便是具体的数据内容了。具体取哪个数据，便取决于 j 啦！ 3 维数组的动态内存分配&emsp;&emsp;对于三维内存，此处就不再赘述了，无非是 arr3d[i][j][k]，由 i 锁定第 i...</div></div></div></a><a class="pagination-related" href="/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" title="C++ 学习——命名空间"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-19</div><div class="info-item-2">C++ 学习——命名空间</div></div><div class="info-2"><div class="info-item-1">命名空间 namespace&emsp;&emsp;在 C 中，我们只能通过给函数名称前加上独有的前缀来避免命名冲突，例如对于 GLFW 库，这是一个 C 库，其中的所有函数都是以 GLFW 开头，例如 GLFWInit()。同样的还有 OpenGL 库，例如 glInit() 等。&emsp;&emsp;在 C++ 中，我们可以通过命名空间来解决多个相同函数名命名冲突的问题。&emsp;&emsp;using namespace 只在当前作用域中有效。尽量不要乱用，可以仅在一个 if 语句中使用，实在不行再考虑加到源文件的开头，但永远不要用在头文件中！ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;namespace apple &#123;    namespace function &#123;        void print2(const std::string &amp;str) &#123;            std::cout &lt;&lt; str...</div></div></div></a><a class="pagination-related" href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="C++ 学习——数据结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">C++ 学习——数据结构</div></div><div class="info-2"><div class="info-item-1">vector优化部分&emsp;&emsp;分析下述代码，找出可以优化的地方： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class Data &#123;public:    Data(int val = 0) : val(val) &#123;&#125;    int val = 0;&#125;;void printVector(std::vector&lt;Data&gt; vec) &#123;    for (int i = 0; i &lt; vec.size(); ++i) &#123;        std::cout &lt;&lt; vec[i].val &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;&#125;int main(void) &#123;    std::vector&lt;Data&gt; vec;    for (int i = 0; i &lt;...</div></div></div></a><a class="pagination-related" href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/" title="C++学习——杂项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-23</div><div class="info-item-2">C++学习——杂项</div></div><div class="info-2"><div class="info-item-1">C++ 的参数计算顺序123456789101112#include &lt;iostream&gt;int sum(int a, int b) &#123;    std::cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; (a + b) &lt;&lt; std::endl;&#125;int main(void) &#123;    int value = 0;    sum(value++, value++);    return 0;&#125;  &emsp;&emsp;运行结果： 12345678910(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o mainmain.cpp:5:1: warning: non-void function does not return a value...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">creat</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ardbr"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Ardbr" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">静待春节ing 🥰🥰</div></div><div class="card-widget card-countdown"><div class="countdown-mask"><div class="text-container"><p>距离 2025 年春节: </p><span class="countdown-number">xx</span><span class="countdown-unit">天</span></div><div class="current-time-container"> <span class="current-time"></span></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#string-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">string 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSO%EF%BC%88%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">SSO（小字符串优化）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%8C%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">类型双关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93-Union"><span class="toc-number">3.</span> <span class="toc-text">联合体 Union</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-cast-%E5%86%8D%E6%8E%A2"><span class="toc-number">5.</span> <span class="toc-text">dynamic_cast 再探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">类型转换操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-lvalue-%E5%92%8C%E5%8F%B3%E5%80%BC-rvalue"><span class="toc-number">7.</span> <span class="toc-text">左值 lvalue 和右值 rvalue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%BC%95%E7%94%A8-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">与引用 &amp; 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.</span> <span class="toc-text">移动语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-move-%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">std::move 与移动赋值操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-move"><span class="toc-number">9.1.</span> <span class="toc-text">std::move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">9.2.</span> <span class="toc-text">移动赋值操作符</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/11/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%954%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E9%83%A8%E5%88%86/" title="Hexo-butterfly 魔改记录4——主页部分">Hexo-butterfly 魔改记录4——主页部分</a><time datetime="2024-12-11T09:13:04.000Z" title="发表于 2024-12-11 17:13:04">2024-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/" title="C++ 学习——关键字">C++ 学习——关键字</a><time datetime="2024-11-28T07:31:04.000Z" title="发表于 2024-11-28 15:31:04">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/27/Unix-1-shell/" title="Unix-1-shell">Unix-1-shell</a><time datetime="2024-11-27T12:04:50.000Z" title="发表于 2024-11-27 20:04:50">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/" title="C++ 学习——算法">C++ 学习——算法</a><time datetime="2024-11-26T10:48:02.000Z" title="发表于 2024-11-26 18:48:02">2024-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/" title="C++学习——杂项">C++学习——杂项</a><time datetime="2024-11-23T08:03:56.000Z" title="发表于 2024-11-23 16:03:56">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By creat</div><div class="footer_custom_text">很高兴你能看到这里！</div></div></footer></div><div id="leftside-fps"><span id="leftside-fps-text"></span></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src=/js/sakuraPlus.js></script><script src=/js/parseLyric.js></script><script src=/js/music.js></script><script src=/js/getFps.js></script><script src=/js/countdown.js></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>