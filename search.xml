<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>reinforcement_learning Ch01</title>
      <link href="/2026/02/22/notes/reinforcement_learning/reinforcement-learning-Ch01/"/>
      <url>/2026/02/22/notes/reinforcement_learning/reinforcement-learning-Ch01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> flow_matching </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flow Matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diffusion Ch04</title>
      <link href="/2026/02/15/notes/diffusion/diffusion-Ch04/"/>
      <url>/2026/02/15/notes/diffusion/diffusion-Ch04/</url>
      
        <content type="html"><![CDATA[<h2 id="扩散模型中-reverse-time-sde-推导">扩散模型中 reverse-time SDE推导</h2><p>待补充，参考 <imgsrc="https://www.zhihu.com/question/629085800/answer/3421808487"alt="知乎" /></p><h2 id="两类扩散模型了解">两类扩散模型了解</h2><h3id="朗之万动力学去噪分数匹配smld">朗之万动力学去噪分数匹配（SMLD）</h3><p>我们设定扰动核 <span class="math inline">\(p_{\sigma}(\tilde{x}|x) :=\mathcal{N}(\tilde{x}; x,\sigma^2\mathbf{I})\)</span>，以及扰动（加噪）后的数据<strong>边缘概率分布</strong>为<span class="math inline">\(p_\sigma(\tilde{x}) := \intp_\sigma(\tilde{x}|x) p_\text{data}(x)\text{d}x\)</span>。</p><p>考虑一个噪声序列 <span class="math inline">\(\sigma_\text{min} =\sigma_1 &lt; \sigma_2 &lt; \dots &lt; \sigma_N =\sigma_\text{max}\)</span>，这也就是说每一步的加噪会越来越大。其中，<spanclass="math inline">\(\sigma_\text{min}\)</span> 足够小，能够使得 <spanclass="math inline">\(p_{\sigma_\text{min}} \approxp_\text{data}(x)\)</span>，<spanclass="math inline">\(\sigma_\text{max}\)</span> 足够大，能够使得 <spanclass="math inline">\(p_{\sigma_\text{max}} \approx \mathcal{N}(x; 0,\sigma_\text{max}^2\mathbf{I})\)</span>。我们可以训练一个噪声条件分数网络（NoiseConditional Score Network, NCSN），即 <spanclass="math inline">\(s_\theta(x, \sigma)\)</span>，使得去噪分数匹配目标<span class="math inline">\(\ref{eq:ncsn_objective}\)</span> 最小。<span class="math display">\[\begin{equation}\theta^* = \arg \min_\theta \sum_{i=1}^N \sigma_i^2\mathbb{E}_{p_\text{data}(x)} \mathbb{E}_{p_{\sigma_i}(\tilde{x}|x)} [\| s_\theta(\tilde{x}, \sigma_i) - \textcolor{red}{\nabla_{\tilde{x}}\log p_{\sigma_i}(\tilde{x}|x)} \|_2^2 ] \label{eq:ncsn_objective}\end{equation}\]</span></p><p>只要给定的样本数据足够多，我们就能使用神经网络学习到对于 <spanclass="math inline">\(\nabla_{\tilde{x}} \logp_{\sigma_i}(\tilde{x}|x)\)</span> 的较为准确的估计 <spanclass="math inline">\(s_\theta(x, \sigma)\)</span>。有了 <spanclass="math inline">\(s_\theta(x, \sigma)\)</span>，通过朗之万迭代式<span class="math inline">\(\ref{eq:langevin_mcmc}\)</span>就可以得到前面步的</p><p><span class="math display">\[\begin{equation}\mathbf{x}_i^m = \mathbf{x}_i^{m-1} + \underbrace{\epsilon_i\mathbf{s}_{\theta^*}(\mathbf{x}_i^{m-1}, \sigma_i)}_{\text{1. 爬坡(Drift)}} + \underbrace{\sqrt{2\epsilon_i} \mathbf{z}_i^m}_{\text{2.扰动 (Noise)}} \label{eq:langevin_mcmc}\end{equation}\]</span></p><div class="note danger flat"><p>这个公式由两股“力量”组成：</p><ol type="1"><li>爬坡 (Drift / Gradient Ascent)<spanclass="math inline">\(\mathbf{s}_{\theta^*}(\dots)\)</span>是神经网络预测的分数 (Score)，也就是概率密度的梯度 <spanclass="math inline">\(\nabla \logp(x)\)</span>。作用：它告诉数据点：“往这边走！这边的概率更高，更像真实的图片！”<spanclass="math inline">\(\epsilon_i\)</span> 是步长 (StepSize)，控制这一步走多远。</li><li>随机扰动 (Noise Injection)<spanclass="math inline">\(\mathbf{z}_i^m\)</span>是从标准正态分布采样出的随机噪声。作用：这是郎之万动力学的精髓。如果只爬坡，容易卡在局部的坑里出不来。加上这个噪声，就像给粒子一点“热运动”，让它有机会跳出局部最优解，去探索更好的区域。系数<span class="math inline">\(\sqrt{2\epsilon_i}\)</span>是物理学推导出来的固定比例，保证粒子最终能稳定在目标分布上。</li></ol></div><p>这是一个双层循环的过程，被称为<strong>“退火(Annealing)”</strong>。</p><ul><li>外层循环 (<span class="math inline">\(i = N \to1\)</span>)：噪声等级的接力开始 (<spanclass="math inline">\(i=N\)</span>)：从巨大的噪声 <spanclass="math inline">\(\sigma_{max}\)</span>开始（此时图片完全是一团糟）。我们先在这个大噪声级别下，跑 <spanclass="math inline">\(M\)</span>步郎之万迭代（内层循环）。在大噪声下，梯度指引的是宏观方向。交接：当第<span class="math inline">\(N\)</span> 级跑完 <spanclass="math inline">\(M\)</span> 步后，把得到的结果 <spanclass="math inline">\(\mathbf{x}_N^M\)</span> 作为下一级 <spanclass="math inline">\(N-1\)</span> 的起点 <spanclass="math inline">\(\mathbf{x}_{N-1}^0\)</span>。当 <spanclass="math inline">\(i=1\)</span> 时，噪声越来越小 (<spanclass="math inline">\(\sigma_{min}\)</span>)，梯度指引变得越来越精细（开始雕刻头发、纹理），直到最后输出清晰图片。</li><li>内层循环 (<span class="math inline">\(m = 1 \toM\)</span>)：在同一级噪声下混合在每一个固定的噪声等级 <spanclass="math inline">\(\sigma_i\)</span> 下，我们都要重复执行公式 (2)<span class="math inline">\(M\)</span>次。这是为了确保数据点真正“收敛”到了当前噪声等级下的分布 <spanclass="math inline">\(p_{\sigma_i}(x)\)</span>。</li></ul><h3 id="去噪扩散概率模型ddpm">去噪扩散概率模型（DDPM）</h3><p>这一部分已经很熟悉了，因此简单讨论一下即可。DDPM设定了一个离散的马尔可夫链 <span class="math inline">\({x_0, x_1, \dots,x_N}\)</span>，并且假设了 <span class="math inline">\(p(x_i | x_{i-1}) =\mathcal{N}(x_i; \sqrt{1 - \beta_i}x_{i-1},\beta_i\mathbf{I})\)</span>，并且由此可以得到汇总步 <spanclass="math inline">\(p_{\alpha_i}(x_i | x_0) = \mathcal{N}(x_i;\underbrace{\sqrt{\alpha_i}x_0}_{\text{均值}},\underbrace{(1-\alpha_i)I}_{\text{方差}})\)</span>。通过变分下界（ELBO），以分数函数的形式写出来，也就是公式<span class="math inline">\(\ref{eq:ddpm_objective}\)</span>。 <spanclass="math display">\[\begin{equation}\theta^* = \arg \min_\theta \sum_{i=1}^N (1-\alpha_i)\mathbb{E}_{p_{\text{data}}(x)} \mathbb{E}_{p_{\alpha_i}(\tilde{x}|x)} [\| \mathbf{s}_\theta(\tilde{x}, i) - \underbrace{\nabla_{\tilde{x}} \logp_{\alpha_i}(\tilde{x}|x)}_{\text{真实分数}} \|_2^2 ]\label{eq:ddpm_objective}\end{equation}\]</span></p><p>既然我们训练好了模型 <spanclass="math inline">\(s_\theta\)</span>，就可以倒着走，从纯噪声 <spanclass="math inline">\(x_N\)</span> 一步步还原回 <spanclass="math inline">\(x_0\)</span>。这个过程叫 Ancestral Sampling(祖先采样)，即公式 <spanclass="math inline">\(\ref{eq:ancestral_sampling}\)</span> <spanclass="math display">\[\begin{equation}x_{i-1} = \frac{1}{\sqrt{1-\beta_i}} (x_i + \beta_i\mathbf{s}_{\theta^*}(x_i, i)) + \sqrt{\beta_i} \mathbf{z}_i, \quad i =N, N-1, \dots, 1 \label{eq:ancestral_sampling}\end{equation}\]</span></p><ul><li><span class="math inline">\(\frac{1}{\sqrt{1-\beta_i}}\)</span>(放大)：因为前向过程把图像缩小了，逆向过程就要把它放大回来。</li><li><span class="math inline">\(\beta_i \mathbf{s}_{\theta^*}\)</span>(去噪/漂移)：利用神经网络预测的Score（梯度方向），把图片往“清晰”的方向推一把。</li><li><span class="math inline">\(\sqrt{\beta_i} \mathbf{z}_i\)</span>(随机扰动)：加入新的随机噪声 <spanclass="math inline">\(\mathbf{z}_i\)</span>。这非常关键！如果没有这一项，生成的图片纹理会很假。这和上一张图 SMLD里的郎之万动力学中的噪声项是一样的作用。</li></ul><div class="note warning flat"><p>SMLD 是“连续微分方程”的离散化求解；DDPM是“离散马尔可夫链”的逆向过程。虽然 DDPM看起来又是马尔可夫链又是变分推断，但把它剥皮拆骨后，它本质上依然是一个加权的去噪分数匹配(Weighted Denoising Score Matching)。</p></div><div class="note danger flat"><p><strong>❓怎么推导的</strong></p><hr /><p>DDPM 和 SMLD 的真正区别就在于每一级噪声的权重不同。</p><p>SMLD (Eq. 1)：权重是 <spanclass="math inline">\(\sigma_i^2\)</span>。来源：<spanclass="math inline">\(\sigma_i^2 \propto 1 /\mathbb{E}[\|\nabla_{\mathbf{x}} \log p_{\sigma_i}(\tilde{\mathbf{x}} |\mathbf{x})\|_2^2]\)</span>。这意味着 SMLD 的权重是根据 Fisher信息量来归一化的。</p><p>DDPM (Eq. 3)：权重是 <spanclass="math inline">\((1-\alpha_i)\)</span>。来源：<spanclass="math inline">\((1-\alpha_i) \propto 1 /\mathbb{E}[\|\nabla_{\mathbf{x}} \log p_{\alpha_i}(\tilde{\mathbf{x}} |\mathbf{x})\|_2^2]\)</span>。</p><p>具体的表达式不同，但这两个权重在函数形式上是一致的（都反比于 Score的模长期望）。</p></div>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flow_matching Ch02</title>
      <link href="/2026/02/14/notes/flow_matching/flow-matching-Ch02/"/>
      <url>/2026/02/14/notes/flow_matching/flow-matching-Ch02/</url>
      
        <content type="html"><![CDATA[<h2 id="条件流匹配cfm">条件流匹配（CFM）</h2><p>在上一章节中，最后我们给出了边缘概率路径 <spanclass="math inline">\(\ref{eq:marginal_prob_path}\)</span> 和边缘场向量<span class="math inline">\(\ref{eq:marginal_vec_field}\)</span>的公式表达。 <span class="math display">\[\begin{align}p_t(x) &amp;= \int p_t(x | x_1)q(x_1) \text{d}x_1\label{eq:marginal_prob_path} \\u_t(x) &amp;= \int u_t(x | x_1) \frac{p_t(x | x_1)q(x_1)}{p_t(x)}\text{d} x_1 \label{eq:marginal_vec_field}\end{align}\]</span></p><p>然而，这两个公式都存在一个共同的问题：<strong>需要计算积分</strong>。积分是不好计算的，这也导致了计算原流匹配目标<spanclass="math inline">\(\ref{eq:original_fm_objective}\)</span>难以计算。<span class="math display">\[\begin{equation}\mathcal{L}_\text{FM}(\theta) = \mathbb{E}_{t, p_t(x)} || v_t(x) -u_t(x) ||^2 \label{eq:original_fm_objective}\end{equation}\]</span></p><div class="note success flat"><p><span class="math inline">\(\mathbb{E}_{t, p_t(x)}\)</span>表示这个期望需要随机采样一个时间步 <spanclass="math inline">\(t\)</span>，然后从 <spanclass="math inline">\(p_t(x)\)</span> 中采样 <spanclass="math inline">\(x\)</span>。最后计算模型预测的当前 <spanclass="math inline">\(x\)</span> 下的向量场 <spanclass="math inline">\(v_t(x)\)</span> 和真实的向量场 <spanclass="math inline">\(u_t(x)\)</span> 之间的均方误差。</p></div><p>在本节中，我们考虑一个更简单的目标，也就是条件流匹配，直接考虑模型预测的<span class="math inline">\(v_t(x)\)</span> 和条件向量场 <spanclass="math inline">\(u_t(x | x_1)\)</span> 之间的均方误差 <spanclass="math inline">\(\ref{eq:conditional_fm_objective}\)</span>。出乎意料的是，<strong>这个条件流匹配目标<span class="math inline">\(\mathcal{L}_\text{CFM}(\theta)\)</span>能够达到和原流匹配目标 <spanclass="math inline">\(\mathcal{L}_\text{FM}(\theta)\)</span>相同的最优性（从梯度视角）</strong>。 <span class="math display">\[\begin{equation}\mathcal{L}_\text{CFM}(\theta) = \mathbb{E}_{t, q(x_1), p_t(x|x_1)} ||v_t(x) - u_t(x|x_1) ||^2 \label{eq:conditional_fm_objective}\end{equation}\]</span></p><p>其中 <span class="math inline">\(t \sim \mathcal{U}[0, 1]，x_1 \simq(x_1)，x \sim p_t(x | x_1)\)</span>。</p><div class="note success flat"><p><span class="math inline">\(\mathbb{E}_{t, q(x_1),p_t(x|x_1)}\)</span> 表示这个期望需要随机采样一个时间步 <spanclass="math inline">\(t\)</span>，然后从训练集 <spanclass="math inline">\(q(x_1)\)</span> 中随机采样一个样本 <spanclass="math inline">\(x_1\)</span>。之后，我们有了参考样本是 <spanclass="math inline">\(x_1\)</span>，以及当前时刻 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(p_t(x |x_1)\)</span> 条件概率<strong>意味着当前 <spanclass="math inline">\(x\)</span> 应该是什么样子的</strong>，我们从中采样<span class="math inline">\(x\)</span>。最后计算模型预测的当前 <spanclass="math inline">\(x\)</span> 下的向量场 <spanclass="math inline">\(v_t(x)\)</span> 和真实的向量场 <spanclass="math inline">\(u_t(x)\)</span> 之间的均方误差。</p></div><h3 id="条件流匹配优化目标等价性证明">条件流匹配优化目标等价性证明</h3><p>本节中我们需要证明 <span class="math display">\[\nabla_\theta \mathcal{L}_\text{FM}(\theta) = \nabla_\theta\mathcal{L}_\text{CFM}(\theta)\]</span></p><p>其中，<span class="math inline">\(\mathcal{L}_{FM}\)</span>是我们要达到的理想目标（让模型拟合整体真实的向量场 <spanclass="math inline">\(u_t\)</span>）。但我们之前说过，这个 <spanclass="math inline">\(u_t\)</span>没法算，所以这个损失函数没法直接求导训练。<spanclass="math inline">\(\mathcal{L}_{CFM}\)</span>是我们设计的简化目标（让模型拟合每一条单样本的直线路径 <spanclass="math inline">\(u_t(x|x_1)\)</span>）。这个很好算，我们写代码用的就是这个。</p><div class="note warning flat"><p><strong>等号含义：</strong>虽然这两个损失函数的值（LossValue）可能不一样（差一个常数），但它们对模型参数 <spanclass="math inline">\(\theta\)</span> 的梯度（<spanclass="math inline">\(\nabla_\theta\)</span>）是完全一样的！</p></div><p>首先，我们展开两个损失函数。</p><p>展开 FM 损失 (<spanclass="math inline">\(\mathcal{L}_{FM}\)</span>)： <spanclass="math display">\[\begin{equation}\mathbb{E}_{t, p_t(x)} \| v_t - u_t \|^2 = \underbrace{\mathbb{E}[\| v_t\|^2]}_{\text{包含 }\theta} - \underbrace{2\mathbb{E}[\langle v_t, u_t\rangle]}_{\text{包含 }\theta} + \underbrace{\mathbb{E}[\| u_t\|^2]}_{\text{与 }\theta \text{ 无关}} \label{eq:fm_loss_expand}\end{equation}\]</span></p><p>展开 CFM 损失 (<spanclass="math inline">\(\mathcal{L}_{CFM}\)</span>)： <spanclass="math display">\[\begin{equation}\mathbb{E}_{t, q(x_1), p_t(x|x_1)} \| v_t - u_t(x|x_1) \|^2 =\underbrace{\mathbb{E}[\| v_t \|^2]}_{\text{包含 }\theta} -\underbrace{2\mathbb{E}[\langle v_t, u_t(x|x_1) \rangle]}_{\text{包含}\theta} + \underbrace{\mathbb{E}[\| u_t(x|x_1) \|^2]}_{\text{与 }\theta\text{ 无关}} \label{eq:cfm_loss_expand}\end{equation}\]</span></p><div class="note warning flat"><p>对于任何向量 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>，都有 <span class="math inline">\(\|a -b\|^2 = \|a\|^2 - 2\langle a, b \rangle + \|b\|^2\)</span>，其中 <spanclass="math inline">\(\langle a, b \rangle\)</span> 表示 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 的内积。</p></div><p>在 <span class="math inline">\(\ref{eq:fm_loss_expand}\)</span> 和<span class="math inline">\(\ref{eq:cfm_loss_expand}\)</span>中，最后那一项（<span class="math inline">\(\|u_t\|^2\)</span> 和 <spanclass="math inline">\(\|u_t(x|x_1)\|^2\)</span>）都是真实数据的属性，不包含模型参数<span class="math inline">\(\theta\)</span>。所以当我们对 <spanclass="math inline">\(\theta\)</span> 求导（Gradient）时，这一项直接变成0，可以忽略。</p><h4 id="证明第一项相等">证明第一项相等</h4><p><span class="math display">\[\begin{align}\mathbb{E}_{p_t(x)}[\| v_t \|^2] &amp;= \int \| v_t \|^2 p_t(x)\text{d}x \\&amp;= \int \| v_t \|^2 \underbrace{(\int p_t(x | x_1) q(x_1)\text{d}x_1)}_{p_t(x)} \text{d}x \quad \text{（代入 $p_t$的条件概率路径）} \\&amp;= \iint \|v_t(x)\|^2 p_t(x|x_1)q(x_1) \text{d}x_1 \text{d}x \\&amp;= \mathbb{E}_{q(x_1), p_t(x | x_1)}[\| v_t \|^2]\end{align}\]</span></p><h4 id="证明第二项相等">证明第二项相等</h4><p><span class="math display">\[\begin{align}\mathbb{E}_{p_t(x)} \langle v_t(x), u_t(x) \rangle &amp;= \int\left\langle v_t(x), \frac{\intu_t(x|x_1)p_t(x|x_1)q(x_1)\text{d}x_1}{\cancel{p_t(x)}} \right\rangle\cancel{p_t(x)}\text{d}x \quad \text{（代入 $u_t(x)$ 的边缘场向量定义）}\\&amp;= \int \underbrace{\left\langle v_t(x), \textcolor{red}{\intu_t(x|x_1)p_t(x|x_1)q(x_1)\text{d}x_1}\right\rangle}_{先\textcolor{red}{积分}，后内积} \text{d}x \quad\text{（内积的线性性质）} \\&amp;= \int \underbrace{\int \textcolor{blue}{\left\langle v_t(x),u_t(x|x_1)p_t(x|x_1)q(x_1) \right\rangle}\text{d}x_1}_{先\textcolor{blue}{内积}，后积分}  \text{d}x \quad\text{（改变内积和积分的顺序）} \\&amp;= \iint \langle v_t(x), u_t(x|x_1) \rangle\textcolor{orange}{p_t(x|x_1)q(x_1)}\text{d}x_1 \text{d}x \quad\textcolor{orange}{\text{（内积的线性性质，提取标量）} } \\&amp;= \mathbb{E}_{q(x_1), p_t(x|x_1)} \langle v_t(x), u_t(x|x_1)\rangle,\end{align}\]</span></p><div class="note warning flat"><p>📒<strong>推导过程涉及的知识点</strong></p><hr /><ol type="1"><li>内积的线性性：<span class="math inline">\(\langle ka, b \rangle =k\langle a, b \rangle\)</span>，<strong>标量 <spanclass="math inline">\(k\)</span>是可以随意进出内积运算符的</strong>。</li><li>一个向量 <span class="math inline">\(a\)</span>与“一堆向量的和（积分）”做内积，等于 <spanclass="math inline">\(A\)</span>与“每一个向量”分别做内积后再求和（积分）。数学表达式为</li></ol><p><span class="math display">\[\left\langle \vec{a}, \int \vec{b}(y) dy \right\rangle = \int \langle\vec{a}, \vec{b}(y) \rangle dy\]</span> 注意上述式子成立的<strong>前提是 <spanclass="math inline">\(a\)</span> 与积分变量 <spanclass="math inline">\(y\)</span> 无关</strong>。在本问题中，<spanclass="math inline">\(a = v_t(x), \quad y = x_1\)</span>两者是无关的。</p></div><h3 id="条件概率路径和条件向量场再探">条件概率路径和条件向量场再探</h3><p>在之前的公式推导中，我们使用了条件概率路径 <spanclass="math inline">\(p_t(x | x_1)\)</span> 和条件向量场 <spanclass="math inline">\(u_t(x | x_1)\)</span> 推导出了概率路径 <spanclass="math inline">\(p_t(x)\)</span> 和向量场 <spanclass="math inline">\(u_t(x)\)</span>，即公式 <spanclass="math inline">\(\ref{eq:marginal_prob_path}\)</span> 和 <spanclass="math inline">\(\ref{eq:marginal_vec_field}\)</span>。</p><p>我们一直假设了条件概率路径 <span class="math inline">\(p_t(x |x_1)\)</span> 和条件向量场 <span class="math inline">\(u_t(x |x_1)\)</span>是已知分布的，却一直没有进一步说明到底是什么已知的分布。在在这一节中，我们将针对这一问题进行说明。</p><p>具体来说，我们假设 <span class="math inline">\(p_t(x|x_1)\)</span>服从高斯分布，即 <span class="math display">\[\begin{equation}p_t(x|x_1) = \mathcal{N}(x; \mu_t(x_1), \sigma_t(x_1)^2 I)\label{eq:pt_dist}\end{equation}\]</span></p><p>其中，<span class="math inline">\(\mu: [0, 1] \times \mathbb{R}^d\rightarrow \mathbb{R}^d\)</span> 是与时间有关的高斯均值，<spanclass="math inline">\(\sigma: [0, 1] \times \mathbb{R} \rightarrow\mathbb{R}_{&gt;0}\)</span>是与时间有关的高斯分布的标准差，<strong>这是一个标量。</strong>为了保证从噪声变成数据，规定首尾必须满足：</p><ul><li><strong><span class="math inline">\(t=0\)</span>(起点)：</strong>必须是标准噪声。所以 <spanclass="math inline">\(\mu_0=0\)</span>，<spanclass="math inline">\(\sigma_0=1\)</span>。</li><li><strong><span class="math inline">\(t=1\)</span>(终点)：</strong>必须是数据 <spanclass="math inline">\(x_1\)</span>。所以 <spanclass="math inline">\(\mu_1=x_1\)</span>，<spanclass="math inline">\(\sigma_1 =\sigma_{\min}\)</span>（非常小，接近0）。这意味着分布在 <spanclass="math inline">\(t=1\)</span> 时变成了一个聚集在 <spanclass="math inline">\(x_1\)</span> 上的尖峰（狄拉克函数的近似）。</li></ul><p>从一个分布到另一个分布的变化，会对应着无数个向量场。我们可以直线过去，也可以“旋转”着过去，然而，那些“转圈”的动作对于改变分布没有任何帮助，只会增加计算量。我们选择最简单的那个向量场，既然我们的路径是高斯的，那我们就用最简单的仿射变换(Affine Transformation) 来定义流。 <span class="math display">\[\begin{equation}\psi_t(x) = \sigma_t(x_1)x + \mu_t(x_1)\label{eq:canonical_transformation}\end{equation}\]</span></p><p>其中，公式 <spanclass="math inline">\(\ref{eq:canonical_transformation}\)</span> 里的<span class="math inline">\(x\)</span>在这里充当的是<strong>原始的标准高斯噪声样本 (<spanclass="math inline">\(x_0\)</span>)</strong>。<spanclass="math inline">\(\psi_t(x)\)</span> 算出的是 <spanclass="math inline">\(t\)</span> 时刻的具体位置 <spanclass="math inline">\(x_t\)</span>。这样一来的话，我们就有式 <spanclass="math inline">\(\ref{eq:psi_dist}\)</span>。 <spanclass="math display">\[\begin{equation}\psi_t(x) = \mathcal{N}(x; \mu_t(x_1), \sigma_t(x_1)^2I)\label{eq:psi_dist}\end{equation}\]</span></p><p>观察 <span class="math inline">\(\ref{eq:pt_dist}\)</span> 和 <spanclass="math inline">\(\ref{eq:psi_dist}\)</span>，可以发现两者是完全相同的！于是<span class="math display">\[[\psi_t]_* p(x) = p_t(x|x_1)\]</span></p><p><strong>也就是说，如果你拿一个标准高斯噪声 <spanclass="math inline">\(p(x)\)</span>，把它通过变换函数 <spanclass="math inline">\(\psi_t\)</span>（推前/Push-forward），得到的新分布，正好就是我们之前定义的条件概率路径<span class="math inline">\(p_t(x|x_1)\)</span>。</strong></p><p>在之前我们讨论过流 <span class="math inline">\(\psi_t(x)\)</span>和场 <span class="math inline">\(u_t(x)\)</span>之间的关系，将其稍做修改成条件形式，即 <span class="math display">\[\begin{equation}\frac{\text{d}}{\text{d}t}\psi_t(x) = u_t(\psi_t(x) | x_1)\label{eq:relationship_pt_ut}\end{equation}\]</span></p><p>于是这个时候的 <spanclass="math inline">\(\mathcal{L}_{\text{CFM}}\)</span> 就变成了 <spanclass="math display">\[\mathcal{L}_{\text{CFM}}(\theta) = \mathbb{E}_{t, q(x_1), p(x_0)}\left\| v_t(\psi_t(x_0)) - \frac{\text{d}}{\text{d}t}\psi_t(x_0)\right\|^2\]</span></p><p>公式 <span class="math inline">\(\ref{eq:relationship_pt_ut}\)</span>还可以进一步进行处理，首先，我们令 <span class="math inline">\(x =\psi_t(x_0)\)</span>，即 <span class="math inline">\(x_0 =\psi_t^{-1}(x)\)</span>。 <span class="math display">\[\begin{align}u_t(\psi_t(x_0) | x_1) &amp;= u_t(x | x_1) \\&amp;= \frac{\text{d}}{\text{d}t}\psi_t(x_0) \\&amp;= \sigma_t^\prime(x_1)x_0 + \mu_t^\prime(x_1) \\&amp;= \sigma_t^\prime(x_1)\underbrace{\left(\frac{x -\mu_t(x_1)}{\sigma_t(x_1)}\right)}_{x_0} + \mu_t^\prime(x_1) \\&amp;= \frac{\sigma_t^\prime(x_1)}{\sigma_t(x_1)}(x - \mu_t(x_1)) +\mu_t^\prime(x_1)\end{align}\]</span></p><p>也就是公式 <span class="math inline">\(\ref{eq:ut_def}\)</span>。<span class="math display">\[\begin{equation}u_t(x | x_1) = \frac{\sigma_t^\prime(x_1)}{\sigma_t(x_1)}(x -\mu_t(x_1)) + \mu_t^\prime(x_1) \label{eq:ut_def}\end{equation}\]</span></p><div class="note danger flat"><p>任意给定一个时间步 <span class="math inline">\(t\)</span> 的 <spanclass="math inline">\(x\)</span>，我们可以使用公式 <spanclass="math inline">\(\ref{eq:ut_def}\)</span> 来得到这个时间点 <spanclass="math inline">\(x\)</span> 的场向量应该是多少，这个公式内不依赖<span class="math inline">\(x_0\)</span>，只与当前的 <spanclass="math inline">\(x\)</span> 以及给定的条件样本 <spanclass="math inline">\(x_1\)</span> 有关。</p></div><h2 id="高斯条件概率路径的特例">高斯条件概率路径的特例</h2><h3 id="variance-exploding-ve-diffusion">Variance Exploding (VE)Diffusion</h3><p>对于方差爆炸的扩散模型来说，其前向和反向的过程可以总结如下：</p><ol type="1"><li><p><strong>扩散过程(Forward)：</strong>保持图片的均值不变，只是一直往里加高斯噪声，直到噪声的方差变得极其巨大（Exploding），图片完全被淹没。</p></li><li><p><strong>生成过程(Reverse)：</strong>从巨大的噪声中，一点点把方差降下来，恢复出图片。</p></li></ol><p>在这个例子中，我们设定 <span class="math display">\[p_t(x) = \mathcal{N}(x | x_1, \sigma_{1-t}^2 I)\]</span></p><div class="note warning flat"><p><span class="math inline">\(\mu_t(x_1) =x_1\)</span>：这意味着在这个路径中，中心位置始终都在真图 <spanclass="math inline">\(x_1\)</span> 那里，没有发生平移（不同于 OptimalTransport 的直线平移）。这也意味着 <spanclass="math inline">\(\mu&#39;_t(x_1) = 0\)</span>（常数的导数为0）。</p><p><span class="math inline">\(\sigma_t(x_1) =\sigma_{1-t}\)</span>：<span class="math inline">\(t\)</span> 的定义：在Flow Matching 里，<span class="math inline">\(t=0\)</span> 是噪声，<spanclass="math inline">\(t=1\)</span> 是真图。<spanclass="math inline">\(1-t\)</span>的含义：这是<strong>“时间倒流”</strong>。因为 Diffusion 的习惯通常是<span class="math inline">\(t\)</span> 越大噪声越大，而 Flow Matching 是<span class="math inline">\(t\)</span> 越大越接近真图。所以这里用 <spanclass="math inline">\(1-t\)</span> 来把时间轴反过来。当 <spanclass="math inline">\(t=0\)</span> (FM起点) <spanclass="math inline">\(\rightarrow\)</span> <spanclass="math inline">\(\sigma_1\)</span> (Diffusion 终点，大噪声)。当<span class="math inline">\(t=1\)</span> (FM终点) <spanclass="math inline">\(\rightarrow\)</span> <spanclass="math inline">\(\sigma_0\)</span> (Diffusion 起点，无噪声)。</p></div><p>代入向量场公式 <span class="math inline">\(\ref{eq:ut_def}\)</span>中，可以得到公式 <span class="math inline">\(\ref{eq:ve_ut}\)</span><span class="math display">\[\begin{equation}u_t(x|x_1) = -\frac{\sigma&#39;_{1-t}}{\sigma_{1-t}}(x - x_1)\label{eq:ve_ut}\end{equation}\]</span></p><p><strong>因此，只要把 <span class="math inline">\(\mu\)</span>设为常数，把 <span class="math inline">\(\sigma\)</span>设为倒序的时间函数，Flow Matching 就能退化成经典的 VEDiffusion。</strong></p><h3 id="variance-preserving-vp-diffusion">Variance Preserving (VP)Diffusion</h3><p>在方差保持的扩散模型中，我们设定 <span class="math display">\[p_t(x|x_1) = \mathcal{N}(x | \alpha_{1-t}x_1, (1 - \alpha_{1-t}^2) I),\text{ where } \alpha_t = e^{-\frac{1}{2}T(t)}, T(t) = \int_0^t\beta(s)ds\]</span></p><div class="note success flat"><p>Variance Preserving (VP)的意思是 <span class="math inline">\(\mu^2 +\sigma^2 = \alpha^2 + (1-\alpha^2) =1\)</span>。这意味着无论怎么加噪，总能量（方差）始终保持为 1。</p></div><p>于是这个时候，我们再应用公式 <spanclass="math inline">\(\ref{eq:ut_def}\)</span>，可以得到公式 <spanclass="math inline">\(\ref{eq:vp_ut}\)</span>。 <spanclass="math display">\[\begin{equation}u_t(x|x_1) = \frac{\alpha&#39;_{1-t}}{1-\alpha_{1-t}^2} (\alpha_{1-t}x -x_1) = -\frac{T&#39;(1-t)}{2} \left[ \frac{e^{-T(1-t)}x -e^{-\frac{1}{2}T(1-t)}x_1}{1 - e^{-T(1-t)}} \right] \label{eq:vp_ut}\end{equation}\]</span></p><h2 id="另一种证明-ve-和-vp-的方法">另一种证明 VE 和 VP 的方法</h2><h3 id="处理符号约定冲突问题">处理符号约定冲突问题</h3><p>前面多次提到，Diffusion 的符号约定是 <span class="math inline">\(t =0\)</span> 是真图，<span class="math inline">\(t = 1\)</span>是噪声图。而 <span class="math inline">\(Flow Matching\)</span>中，<span class="math inline">\(t = 0\)</span> 是噪声图，<spanclass="math inline">\(t = 1\)</span> 是真图。如果我想直接用 Diffusion论文里推导好的公式（比如 Song et al. 的 Probability FlowODE），我不仅要把时间轴倒过来（用 <spanclass="math inline">\(1-t\)</span>），还得把流动的方向反过来（加负号）。</p><p>接下来我们就来证明这一件事：把时间倒转过来（<spanclass="math inline">\(t \rightarrow 1 -t\)</span>），那么对应的速度场就是原速度场的负方向。 <spanclass="math display">\[\begin{aligned}\frac{d}{dt} \tilde{p}_t(x) &amp;= \frac{d}{dt} p_{1-t}(x) =-p&#39;_{1-t}(x) \\&amp;= \text{div}(p_{1-t}(x)u_{1-t}(x)) \\&amp;= -\text{div}(\tilde{p}_t(x)(-u_{1-t}(x)))\end{aligned}\]</span></p><p>因此，<span class="math inline">\(\tilde{u}_t(x) =-u_{1-t}(x)\)</span>。</p><h3 id="ve-形式的证明">VE 形式的证明</h3><p>对于 VE 形式来说，其随机微分方程 SDE 为 <spanclass="math inline">\(\ref{eq:ve_sde}\)</span>。 <spanclass="math display">\[\begin{equation}dy = \sqrt{\frac{\text{d}}{\text{d}t}\sigma_t^2}dw \label{eq:ve_sde}\end{equation}\]</span></p><p>SDE 的定义式为 <span class="math inline">\(\ref{eq:sde_def}\)</span><span class="math display">\[\begin{equation}\text{d}y = f_t\text{d}t + g_t\text{d}w \label{eq:sde_def}\end{equation}\]</span></p><p>结合 <span class="math inline">\(\ref{eq:ve_sde}\)</span> 和 <spanclass="math inline">\(\ref{eq:sde_def}\)</span>，可以得到 <spanclass="math display">\[\begin{align}f_t &amp;= 0 \\g_t^2 &amp;= \frac{\text{d}\sigma_t^2}{\text{d}t} =2\sigma_t\sigma_t^\prime\end{align}\]</span></p><p>其条件概率路径为 <spanclass="math inline">\(\ref{eq:ve_cond_prob_path}\)</span>。 <spanclass="math display">\[\begin{equation}p_t(y|y_0) = \mathcal{N}(y|y_0, \sigma_t^2I)\label{eq:ve_cond_prob_path}\end{equation}\]</span></p><p>于是，有了条件概率路径 <spanclass="math inline">\(p_t(y|y_0)\)</span>，就可以计算 <spanclass="math inline">\(\nabla \log p_t(y | y_0)\)</span>。 <spanclass="math display">\[\begin{align}p_t &amp;= \frac{1}{\sqrt{2}\sigma_t^2} \exp \left\{ -\frac{(y-y_0)^2}{2\sigma_t^2} \right\} \\\log p_t &amp;= \ln \left( \frac{1}{\sqrt{2}a_t^2} \right) -\frac{(y-y_0)^2}{2\sigma_t^2} \\\nabla_y \log p_t &amp;= - \frac{1}{2\sigma_t^2} \cdot 2 (y-y_0) \\&amp;= - \frac{(y-y_0)}{\sigma_t^2}\end{align}\]</span></p><p>OK，现在万事俱备，该求的量我们都已经求出来了。代入先前推导过的福克-普朗克方程式中对于场向量的表达式<span class="math inline">\(\ref{eq:w_t}\)</span> 中 <spanclass="math display">\[\begin{equation}w_t = f_t - \frac{g_t^2}{2}\nabla \log p_t \label{eq:w_t}\end{equation}\]</span></p><p>可以得到 <span class="math display">\[w_t = \frac{\sigma_t^\prime}{\sigma_t}(y - y_0)\]</span></p><p>注意最后一步，我们需要对 <span class="math inline">\(t\)</span>进行变量替换，来符合 Diffusion 的符号约定。令 <spanclass="math inline">\(t = 1 - t\)</span>，可以得到 <spanclass="math display">\[\begin{equation}w_t = \textcolor{red}{-}\frac{\sigma_{1 - t}^\prime}{\sigma_{1 - t}}(y -y_0) \quad \textcolor{red}{\text{（链式求导，对于 $1-t$ 会多一个负号）}}\label{eq:ve_wt_def}\end{equation}\]</span></p><p>可以看到，式 <span class="math inline">\(\ref{eq:ve_wt_def}\)</span>与之前使用。推导的结果 <spanclass="math inline">\(\ref{eq:ve_ut}\)</span> 完全一致！</p><h3 id="vp-形式的证明">VP 形式的证明</h3><p>先给出 VP 形式的 SDE <span class="math display">\[dy = -\frac{T&#39;(t)}{2}y dt + \sqrt{T&#39;(t)}dw, \quad \text{where}T(t) = \int_0^t \beta(s)ds, \quad t \in [0, 1].\]</span></p><p>同理，可以得到 SDE 的系数 <span class="math display">\[f_s(y) = -\frac{T&#39;(s)}{2}y, \quad g_s = \sqrt{T&#39;(s)}\]</span></p><p>条件概率密度为 <span class="math display">\[p_t(y|y_0) = \mathcal{N}(y | e^{-\frac{1}{2}T(t)}y_0, (1 - e^{-T(t)})I)\]</span></p><p>于是也可以求解 <span class="math inline">\(\nabla \logp_t(y|y_0)\)</span>，进而得到 <spanclass="math inline">\(w_t(y|y_0)\)</span>，见公式 <spanclass="math inline">\(\ref{eq:vp_ut_def}\)</span> <spanclass="math display">\[\begin{equation}w_t(y|y_0) = \frac{T&#39;(t)}{2} \left( \frac{y -e^{-\frac{1}{2}T(t)}y_0}{1 - e^{-T(t)}} - y \right)\end{equation}\]</span></p><p>最后，再进行变量替换，应用求导的链式法则，有 <spanclass="math display">\[\begin{align}\tilde{w}_t(y|y_0) &amp;= -\frac{T&#39;(1-t)}{2} \left( \frac{y -e^{-\frac{1}{2}T(1-t)}y_0}{1 - e^{-T(1-t)}} - y \right) \\&amp;= -\frac{T&#39;(1-t)}{2} \left[ \frac{e^{-T(1-t)}y -e^{-\frac{1}{2}T(1-t)}y_0}{1 - e^{-T(1-t)}} \right] \label{eq:vp_wt_def}\end{align}\]</span></p><p>不出意外，公式 <spanclass="math inline">\(\ref{eq:vp_wt_def}\)</span> 也是和 <spanclass="math inline">\(\ref{eq:vp_ut}\)</span> 一模一样的。</p><h2 id="最优传输路径">最优传输路径</h2><h2 id="flow-matching-思路梳理">Flow Matching 思路梳理</h2><h3 id="三个重要量之间的关系">三个重要量之间的关系</h3><p>整篇文章都在围绕着<strong>流 <spanclass="math inline">\(\phi_t\)</span>（Flow）</strong>、<strong>场 <spanclass="math inline">\(u_t\)</span>（VectorField）</strong>和<strong>概率路径 <spanclass="math inline">\(p_t\)</span>（ProbabilityPath）</strong>展开讨论的。这三个重要的量之间存在着密切的联系，彼此之间是可以相互推导转换的。</p><p>例如，流和场是积分和微分的关系，流在某一时刻 <spanclass="math inline">\(t\)</span> 的求导就是场，给定初始分布纯噪声 <spanclass="math inline">\(x_0\)</span>，则 <span class="math inline">\([0,t]\)</span> 区间内场的积分就是流。</p><p>场和概率路径之间是通过连续性方程进行联系的。直观来说，如果一个位置的场都是向四周进行扩散的，那么这个位置的概率密度在下一时刻就会降低，反之则会增大。</p><p>此外，<span class="math inline">\(p_0\)</span> 和 <spanclass="math inline">\(p_t\)</span> 之间也是可以相互转化的。当我们想知道<span class="math inline">\(x_1\)</span> 的概率分布 <spanclass="math inline">\(p_1\)</span>，首先，我们需要先用逆函数，将 <spanclass="math inline">\(x\)</span> 变为 <spanclass="math inline">\(x_0\)</span>，算出那个位置原来的概率密度 <spanclass="math inline">\(p_0\)</span>。之后，使用雅可比矩阵的行列式，作为体积压缩倍数，就能算出位置的当前的概率密度<span class="math inline">\(p_1\)</span>。</p><h3 id="流匹配的目标">流匹配的目标</h3><p>流匹配的目标就是为了求解出一条能从简单分布（标准高斯）<spanclass="math inline">\(p_0\)</span> 到复杂图像分布 <spanclass="math inline">\(p_1\)</span> 的概率路径。其作用对象是向量场 <spanclass="math inline">\(u_t\)</span>。于是，我们就想要通过一个神经网络，输出<span class="math inline">\(v_{\theta, t}\)</span> 去拟合一个向量场<span class="math inline">\(u_t\)</span>。</p><p>但是，通常来说，我们想要拟合一个东西，至少这个东西需要是已知的，也就是<span class="math inline">\(u_t\)</span> 需要已知。</p><h3 id="如何表示出-u_t">如何表示出 <spanclass="math inline">\(u_t\)</span></h3><p>关于如何表示出 <spanclass="math inline">\(u_t\)</span>，本文给出了三种方法。</p><ul><li><span class="math inline">\(u_t(x) = \int u_t(x | x_1) \frac{p_t(x |x_1)q(x_1)}{p_t(x)} \text{d} x_1\)</span> 给出了 <spanclass="math inline">\(u_t\)</span>的具体计算公式。然而，由于涉及积分，这个公式难以计算。</li><li>_{t, q(x_1), p_t(x|x_1)} | v_t - u_t(x|x_1)|^2，这个公式给出了转化后的优化目标——”逐样本“计算<strong>条件场向量</strong>。然后，通过证明对应项相等，可以得到尽管使用条件向量场<span class="math inline">\(u_t(x | x_1)\)</span>，其关于模型参数 <spanclass="math inline">\(\theta\)</span> 的梯度值与 <spanclass="math inline">\(u_t(x)\)</span>是完全相等的，因此可以达到相同的优化效果。</li><li><span class="math inline">\(u_t(x | x_1) =\frac{\sigma_t^\prime(x_1)}{\sigma_t(x_1)}(x - \mu_t(x_1)) +\mu_t^\prime(x_1)\)</span>。之后，我们进一步加强条件，考虑了高斯分布下的条件向量场，这给到了我们更好的性质，使得条件向量场的求解更加简单。</li></ul><h3 id="最优传输路径梳理">最优传输路径梳理</h3><p>建设中</p><h3 id="验证扩散过程">验证扩散过程</h3><p>最后，本文给出了对于 VE 和 VP，使用公式 <spanclass="math inline">\(u_t(x | x_1) =\frac{\sigma_t^\prime(x_1)}{\sigma_t(x_1)}(x - \mu_t(x_1)) +\mu_t^\prime(x_1)\)</span> 和福克-普朗克方程两种方式得到的 <spanclass="math inline">\(u_t(x |x_1)\)</span>，并证明了结果是完全相同的。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> flow_matching </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flow Matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flow_matching Ch01</title>
      <link href="/2026/02/12/notes/flow_matching/flow-matching-Ch01/"/>
      <url>/2026/02/12/notes/flow_matching/flow-matching-Ch01/</url>
      
        <content type="html"><![CDATA[<h2 id="flow-matching-总览">Flow Matching 总览</h2><h3 id="生成模型的目标">生成模型的目标</h3><p>生成模型（GAN, VAE, Diffusion, Flow）的目标是已知样本 <spanclass="math inline">\(x_1 \sim q_1\)</span>(未知)，用样本把未知分布估计出来。其中 <spanclass="math inline">\(x_1\)</span>代表真实数据（比如一张真实的狗的照片）。<spanclass="math inline">\(q_1\)</span> 代表真实数据的分布（DataDistribution），这是上帝视角的分布，我们在数学上不知道它的解析式，但我们有从中采样出来的“样本”。</p><p>我们的目标就是通过有限的样本，训练一个模型去逼近这个未知的 <spanclass="math inline">\(q_1\)</span>。</p><h3 id="做法">做法</h3><p>为了达到这个目的，通常的做法是利用已知分布（通常为高斯分布/标准正态分布）来映射到未知分布<span class="math inline">\(q_1\)</span>，即： <spanclass="math display">\[q_0 \text{（已知分布）} \xrightarrow{\phi} q_1\text{（待估计的未知分布）}\]</span></p><p>其中 <span class="math inline">\(\phi\)</span> (Phi)是一个映射函数（Mapping）。</p><div class="note success flat"><p>💡生成模型的本质就是寻找一个映射 <spanclass="math inline">\(\phi\)</span>，它能把简单的噪声 <spanclass="math inline">\(x_0\)</span> “推”成复杂的图像 <spanclass="math inline">\(x_1\)</span>。</p></div><h3 id="两种求解路径">两种求解路径</h3><h4 id="normalizing-flow标准化流">Normalizing Flow（标准化流）</h4><p>这是早期的流模型（如 RealNVP,Glow），利用了概率论中的变量变换公式（Change of VariablesFormula）。它要求映射函数必须是可逆的，而且要计算雅可比行列式（JacobianDeterminant），这极大地限制了神经网络的结构设计。</p><h4 id="flow-matching流匹配">Flow Matching（流匹配）</h4><p>这是目前最前沿的方法。它不再强求计算雅可比行列式，而是借助<strong>常微分方程（ODE）</strong>来建模。</p><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>将 <span class="math inline">\(q_0\)</span> 和 <spanclass="math inline">\(q_1\)</span> 为 ODE 的起点和终点</p></div></div><div class='timeline-item-content'><p>我们不再直接学映射，而是定义一个随时间 <spanclass="math inline">\(t\)</span> 变化的路径（Probability Path），从噪声<span class="math inline">\(t=0\)</span> 逐渐变成数据 <spanclass="math inline">\(t=1\)</span>。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>用神经网络逼近 ODE 的导数项</p></div></div><div class='timeline-item-content'><p>这里的“导数项”就是向量场（VectorField），也就是数据移动的“速度”和“方向”。</p><p>这也是 Flow Matching的核心：我们训练网络去预测在某个时刻，数据应该往哪个方向流。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>解 ODE, 得到 <span class="math inline">\(\varphi\)</span></p></div></div><div class='timeline-item-content'><p>训练好网络后，生成过程就是从噪声出发，沿着网络预测的“速度场”，一步步数值积分（比如用欧拉法），最终流向真实数据。</p></div></div></div><div class="note warning flat"><p>💥<strong>符号问题澄清</strong></p><hr /><p>在 DDPM 中，通常 <span class="math inline">\(x_0\)</span>是原始图，<span class="math inline">\(x_T\)</span> 是噪声。</p><p>而在 Flow Matching 中，通常 <span class="math inline">\(x_0\)</span>是噪声（起点），<span class="math inline">\(x_1\)</span>是图（终点）。这点符号上是反的，看的时候要注意。</p></div><h2 id="flow-定义">Flow 定义</h2><p>在不同的资料中，流有着不同的定义。但它们只是从<strong>“微观（微分）”</strong>和<strong>“宏观（积分）”</strong>两个不同视角来描述同一个物理过程。</p><h3 id="微观视角微分v_t">微观视角（微分）——<spanclass="math inline">\(v_t\)</span></h3><p>这里将流定义为 <span class="math inline">\(v = \{v_t\}_{t \in [0,1]}\)</span>。即一系列的向量场 (Vector Field) / 速度场 (VelocityField)。</p><p>它描述的是每一个瞬间、每一个位置上数据的“移动速度”和“方向”。这是我们在神经网络里直接去“学”（训练）的东西，<strong>网络输入<span class="math inline">\((x, t)\)</span>，输出这个点的速度 <spanclass="math inline">\(v_t(x)\)</span></strong>。</p><h3 id="宏观视角积分phi">宏观视角（积分）——<spanclass="math inline">\(\phi\)</span></h3><p>这里将流定义为流映射 (Flow Map) / 轨迹。</p><p>它描述的是一个初始点 <spanclass="math inline">\(\boldsymbol{x}_0\)</span> 随时间 <spanclass="math inline">\(t\)</span>移动后的最终位置或整条轨迹。这是我们通过解 ODE 算出来的结果。</p><h3 id="两者的等价关系">两者的等价关系</h3><p>我们假设初始噪声点为 <spanclass="math inline">\(\boldsymbol{x}_0\)</span>，最终生成的干净数据为<span class="math inline">\(\boldsymbol{x}_1\)</span>，数据的维度为<span class="math inline">\(d\)</span> 维，即 <spanclass="math inline">\(x_0 = (x^1, x^2, ..., x^d)\)</span>。则 <spanclass="math inline">\(v_t\)</span> 与 <spanclass="math inline">\(\phi\)</span> 都是 <span class="math inline">\([0,1] \times \mathbb{R}^d \rightarrow \mathbb{R}^d\)</span>的映射，且有公式 <span class="math inline">\(\ref{eq:flow_def1}\)</span>成立。 <span class="math display">\[\begin{equation}\frac{\text{d} x_t}{\text{d} t} = v_t(x_t, t), \quad t \in [0, 1]\label{eq:flow_def1}\end{equation}\]</span></p><div class="note danger flat"><p>注意这里的 <span class="math inline">\(v_t\)</span>不仅与时间有关，还与当前时刻 <span class="math inline">\(t\)</span>中每一个粒子的位置有关系。这里当时我理解起来有一些费解，因为 <spanclass="math inline">\(v_t\)</span> 下标是 <spanclass="math inline">\(t\)</span>，我就理所当然以为其只与 <spanclass="math inline">\(t\)</span> 有关了，当然还受一直以来使用 2维的轨迹微分是速度的影响。在我们 Flow场景中，一般数据都是极高维的。相当于对于每一个像素点，我们都将其视作了一个2 维点轨迹微分是速度进行求解。每一个像素点的速度场会不同，因此，<spanclass="math inline">\(x_t\)</span> 也是要作为输入的。</p><p>在这里可以举一个浅显易懂的例子解释一下：我们要把一堆高斯噪声点（就像广场上聚集的一群人，每一个人就相当于是一个像素点）变成真实数据分布（让大家各自回家）。</p><p>起点 <span class="math inline">\(t=0\)</span>：所有人（噪声 <spanclass="math inline">\(x\)</span>）都在广场中心聚集（标准正态分布）。</p><p>终点 <span class="math inline">\(t=1\)</span>：小明 (<spanclass="math inline">\(x_A\)</span>) 的家在东边的北京。小红 (<spanclass="math inline">\(x_B\)</span>) 的家在西边的伦敦。</p><p>如果 <span class="math inline">\(v_t\)</span> 只与 <spanclass="math inline">\(t\)</span> 有关，不依赖于位置 <spanclass="math inline">\(x\)</span>：这意味着在 <spanclass="math inline">\(t=0.1\)</span>时刻，广播里喊：“所有人往东走！”。结果：小明开心了，但小红也被迫往东走，最后大家都到了北京。这不仅没法生成多样的图像，还会把本来分散的分布强行平移。</p><p>因为 <span class="math inline">\(v_t\)</span> 依赖于位置 <spanclass="math inline">\(x\)</span>：在这个场中，如果你站在东侧 (<spanclass="math inline">\(x_A\)</span>)，你会感受到向东的风（速度 <spanclass="math inline">\(v &gt; 0\)</span>）。如果你站在西侧 (<spanclass="math inline">\(x_B\)</span>)，你会感受到向西的风（速度 <spanclass="math inline">\(v &lt; 0\)</span>）。这样，同一个时刻 <spanclass="math inline">\(t\)</span>，不同的位置有不同的指引，才能把一团原本聚集在一起的橡皮泥（噪声），捏成形状各异的雕塑（真实数据）。</p></div><p>此外，由定义可以有公式 <spanclass="math inline">\(\ref{eq:xt_def}\)</span> 成立。 <spanclass="math display">\[\begin{equation}x_t = \phi(x_0, t) \label{eq:xt_def}\end{equation}\]</span></p><p>将公式 <span class="math inline">\(\ref{eq:xt_def}\)</span> 代入到<span class="math inline">\(\ref{eq:flow_def1}\)</span> 中，写出来就是：<span class="math display">\[\begin{align}v_t(\phi_t(x_0, t), t) &amp;= \frac{\text{d} \phi_t(x_0, t)}{\text{d}t}\label{eq:vt}\\\phi_t(x_0, t) &amp;= \int_0^t v_t(\phi_t(x_0, \tau), \tau) \text{d}\tau+ x_0 \quad \color{red}{\text{（两边进行积分）}} \label{eq:flow_def2}\end{align}\]</span></p><p>可以看到，公式 <spanclass="math inline">\(\ref{eq:flow_def2}\)</span>就是从宏观积分角度进行分析的，使用 <spanclass="math inline">\(v\)</span> 或者 <spanclass="math inline">\(\phi\)</span> 来看待流 flow的定义，本质是等价的，一一对应的。</p><h2 id="连续性方程">连续性方程</h2><h3 id="连续性方程公式表达">连续性方程公式表达</h3><p>一种检验一个向量场 <span class="math inline">\(v_t(x)\)</span>是否能够产生概率路径 <span class="math inline">\(p_t\)</span>的方法是<strong>连续性方程</strong>。 <span class="math display">\[\begin{equation}\frac{d}{dt}p_t(x) + \text{div}(p_t(x)v_t(x)) = 0\label{eq:continuity_eq}\end{equation}\]</span></p><p>我们可以把它移项变成更易懂的形式： <span class="math display">\[\underbrace{\frac{d}{dt}p_t(x)}_{\text{密度的变化}} = \underbrace{-\text{div}(p_t(x)v_t(x))}_{\text{流入量的净值}}\]</span></p><h3 id="例子理解">例子理解</h3><p>我们可以通过一个直观的例子进行理解：想象你在一个拥挤的地铁站大厅（这是一个<span class="math inline">\(d\)</span> 维空间）。</p><ul><li><spanclass="math inline">\(p_t(x)\)</span>（概率密度）：大厅里某个位置 <spanclass="math inline">\(x\)</span> 有多挤（人的密度）。</li><li><spanclass="math inline">\(v_t(x)\)</span>（速度场）：这个位置的人群正在往哪个方向走，走得多快。</li></ul><p>连续性方程在说：人不会凭空消失，也不会凭空变出来（假设没有传送门）。如果你发现大厅里某一块区域（比如安检口）的人变得越来越多了（密度<span class="math inline">\(\frac{d}{dt}p_t\)</span>增加），那么一定是因为 <strong>走进这个区域的人</strong> 比<strong>走出这个区域的人</strong> 多。这就是连续性方程的本质： <spanclass="math display">\[\text{密度的变化率} + \text{净流出量} = 0\]</span></p><p>公式 <span class="math inline">\(\ref{eq:continuity_eq}\)</span>的第一项 <span class="math inline">\(\frac{d}{dt}p_t(x)\)</span>的含义：随着时间推移，在 <span class="math inline">\(x\)</span>这个固定点，概率密度（拥挤程度）是变大了还是变小了？</p><p>第二项：<span class="math inline">\(\text{div}(p_t(x)v_t(x))\)</span>这里是最难懂的，<span class="math inline">\(\text{div}\)</span>是“发散算子” (Divergence)。<spanclass="math inline">\(p_t(x)v_t(x)\)</span> 叫做通量 (Flux)。也就是“密度<span class="math inline">\(\times\)</span>速度”。它代表了<strong>“实际有多少量”</strong>在移动。</p><p><span class="math inline">\(\text{div}\)</span>(散度)：它是在计算<strong>“向外扩散的程度”</strong>。</p><ul><li><span class="math inline">\(\text{div} &gt;0\)</span>（正散度）：代表物质在向四周发散（像喷泉）。东西流走了，所以密度会下降。</li><li><span class="math inline">\(\text{div} &lt;0\)</span>（负散度）：代表物质在向中心汇聚（像排水口）。东西流进来了，所以密度会上升。</li><li><span class="math inline">\(\text{div} =0\)</span>：流进多少等于流出多少（像平滑的水管），密度不变。</li></ul><h3 id="连续性方程的作用">连续性方程的作用</h3><p>在 Flow Matching中，这个方程起到了<strong>“桥梁”</strong>的作用。</p><ul><li>微观上：我们训练神经网络去预测每一个点的速度 <spanclass="math inline">\(v_t(x)\)</span>（这是我们能控制的）。</li><li>宏观上：我们关心的是整张图片的分布 <spanclass="math inline">\(p_t(x)\)</span> 如何从噪声变成真图。</li></ul><p>连续性方程告诉我们要如何检验：“如果你定义了速度场 <spanclass="math inline">\(v_t\)</span>，那么概率分布 <spanclass="math inline">\(p_t\)</span> <strong>必须且只能</strong>按照连续性方程规定的方式演变。”</p><div class="note warning flat"><p>连续性方程就是一个<strong>“不作弊声明”</strong>：它保证了当我们移动每一个数据点时，整体的概率分布是连续变化的，没有概率凭空产生或消失。它是验证生成的路径是否合法的数学工具。</p><hr /><p><strong>不是所有的速度场 <span class="math inline">\(v_t\)</span>都能够生成生成合法的 <spanclass="math inline">\(p_t\)</span>。（待补充）</strong></p></div><h3 id="随机微分方程sde">随机微分方程（SDE）</h3><h4 id="单个粒子的随机过程演变">单个粒子的随机过程演变</h4><p>随机微分方程的数学表达式见式 <spanclass="math inline">\(\ref{eq:sde}\)</span>。 <spanclass="math display">\[\begin{equation}\text{d}y = \underbrace{f_t \text{d}t}_{\text{漂移(确定性趋势)}} +\underbrace{g_t \text{d}w}_{\text{扩散(随机噪声)}} \label{eq:sde}\end{equation}\]</span></p><p>这是一个粒子随时间的运动规律。我们想象一个喝醉的人走路，<spanclass="math inline">\(f_t\)</span>漂移项表示风把他往东吹（确定的力），相当于我们之前讨论过的向量场 <spanclass="math inline">\(v_t\)</span>。<span class="math inline">\(g_t\text{d}w\)</span>扩散项表示他自己摇摇晃晃，一会儿左一会儿右（随机的力）。这个过程是随机的，每次走出来的路线都不一样。</p><h4 id="群体的随机过程演变">群体的随机过程演变</h4><p>接着上面的例子，如果我们放一万个喝醉的人在广场上，我们要描述整个人群分布（密度<spanclass="math inline">\(p_t\)</span>）是怎么变化的。这时候就不能用随机方程了，要用<strong>Fokker-Planck 方程</strong>： <span class="math display">\[\begin{equation}\frac{dp_t}{dt} = \underbrace{-\text{div}(f_t p_t)}_{\text{被风吹着跑}}+ \underbrace{\frac{g_t^2}{2}\Delta p_t}_{\text{人群慢慢散开}}\label{eq:fokker_planck_eq}\end{equation}\]</span></p><p>第一项有 <spanclass="math inline">\(\text{div}\)</span>（散度），这是我们在连续性方程里见过的，代表“流动”。第二项是Laplace 算子 <span class="math inline">\(\Delta\)</span>（或者写作 <spanclass="math inline">\(\text{div}\nabla\)</span>），它代表<strong>“扩散”</strong>。这一项让原本聚在一起的人群变“糊”了，散开了。</p><p>接下来，我们想把后面的 <spanclass="math inline">\(\frac{g_t^2}{2}\Delta p_t\)</span>这一项最好消灭掉。要怎么做呢？注意到（注意力惊人😅）我们有恒等式 <spanclass="math inline">\(\nabla p_t = p_t \nabla \log p_t\)</span>成立！因此， <span class="math display">\[\frac{g_t^2}{2}\Delta p_t = \frac{g_t^2}{2}\text{div}\nabla p_t =\frac{g_t^2}{2}\text{div} (p_t \nabla \log p_t)\]</span></p><p>所以，这一项也变成了 <span class="math inline">\(\text{div}(\dotsp_t)\)</span> 的形式，我们对这两项进行合并，有 <spanclass="math display">\[\frac{dp_t}{dt} = -\text{div}\left( \left(\underbrace{f_t}_{\text{原有的漂移}} - \underbrace{\frac{g_t^2}{2}\nabla\log p_t}_{\text{把扩散转化成的速度}} \right) p_t \right)\]</span></p><p>我们把它简写为： <span class="math display">\[\frac{dp_t}{dt} = -\text{div}(w_t p_t)\]</span></p><p>其中 <span class="math display">\[\begin{equation}w_t = f_t - \frac{g_t^2}{2}\nabla \log p_t \label{eq:w_t}\end{equation}\]</span></p><p>公式 <span class="math inline">\(\ref{eq:w_t}\)</span> 解释了 FlowMatching 和扩散模型的一个核心秘密——概率流 ODE (Probability FlowODE)：</p><p>左边是一个完全确定的速度场 <spanclass="math inline">\(w_t\)</span>。右边包含了原本的漂移 <spanclass="math inline">\(f_t\)</span> 和 Score Function (<spanclass="math inline">\(\nabla \logp_t\)</span>)。即使原本的过程是随机的（一群醉汉乱撞），我们也能设计出一套确定的传送带（速度场<spanclass="math inline">\(w_t\)</span>），只要让醉汉站在传送带上不动，最终人群分布的形状变化，会和他们自己乱撞的效果一模一样！这就是为什么我们在训练模型时，只需要预测Score (<span class="math inline">\(\nabla \logp_t\)</span>)，就能构建出一个确定的 ODE来生成图像，而不需要真的去模拟随机过程。</p><div class="note success flat"><p>🤔<strong>个人理解</strong></p><hr /><p>这一部分我个人的理解就是，虽然单个粒子的演变是随机的。但是，当粒子数足够多的时候，粒子云整体反映出来的宏观性质却是确定性的，因为整个的<span class="math inline">\(\ref{eq:fokker_planck_eq}\)</span>公式的两边都没有任何的随机项。这就是<strong>群体的确定性</strong>。</p><p>因此，既然宏观云团的演变是确定的，那我们可以不要那些乱跑的醉汉。我们可以设计一种“传送带”（确定性的速度场<spanclass="math inline">\(v_t\)</span>），让粒子乖乖地沿着传送带走（不乱跑，去掉了<span class="math inline">\(dw\)</span>）。只要传送带设计得好（符合公式40），这些乖乖走的粒子形成的云团形状，就会和那些醉汉乱跑形成的云团形状一模一样。</p></div><h2 id="连续归一化流">连续归一化流</h2><p>连续归一化流的作用就是给定一个简单的先验分布（simple prior density）<span class="math inline">\(p_0\)</span>（例如纯噪声），通过 <spanclass="math inline">\(\phi_t\)</span> 的映射，转变成一个复杂的分布 <spanclass="math inline">\(p_t\)</span>。push_forward equation 如式 <spanclass="math inline">\(\ref{eq:push_forward_eq}\)</span>。 <spanclass="math display">\[\begin{equation}p_t = \left[ \phi_t \right]_*p_0 \label{eq:push_forward_eq}\end{equation}\]</span></p><p>其中前推算子/变量变换算子 <span class="math inline">\(*\)</span>定义如式 <spanclass="math inline">\(\ref{eq:push_forward_eq_def}\)</span>。 <spanclass="math display">\[\begin{equation}p_t(x) = [\phi_t]_* p_0(x) = p_0(\phi_t^{-1}(x)) \det \left[\frac{\partial \phi_t^{-1}}{\partial x}(x) \right]\label{eq:push_forward_eq_def}\end{equation}\]</span></p><h3 id="补充变量变换公式的推导过程">补充变量变换公式的推导过程</h3><p>不妨假设原始随机变量 <span class="math inline">\(x_0\)</span> 经过了<span class="math inline">\(\phi_t\)</span>变换函数的映射，变成了新的变量 <spanclass="math inline">\(x_1\)</span>。于是，我们的目标是，知道了 <spanclass="math inline">\(x_0\)</span> 的概率分布 <spanclass="math inline">\(p_0\)</span>，如何得到 <spanclass="math inline">\(x_1\)</span> 的概率分布 <spanclass="math inline">\(p_1\)</span>。</p><p>由概率守恒公式 <span class="math display">\[\begin{equation}p_0(x_0)dx_0 = p_1(x_1)dx_1\end{equation}\]</span></p><p>可以有 <span class="math display">\[\begin{equation}\Rightarrow p_1(x) = p_0(x_0) \cdot \frac{d x_0}{d x_1}\end{equation}\]</span></p><p>再将其推广到高维空间，有 <span class="math display">\[p_1(x) = p_0(x_0) \cdot \left| \det \left( \frac{\partial x_0}{\partialx_1} \right) \right|\]</span></p><p>因为 <span class="math inline">\(x_0 =\phi^{-1}(x)\)</span>，将其带入后就得到了 <spanclass="math inline">\(\ref{eq:push_forward_eq_def}\)</span>公式了。这说明了这样一件事：当我们想知道 <spanclass="math inline">\(x_1\)</span> 的概率分布 <spanclass="math inline">\(p_1\)</span>，首先，我们需要先用逆函数，将 <spanclass="math inline">\(x\)</span> 变为 <spanclass="math inline">\(x_0\)</span>，算出那个位置原来的概率密度 <spanclass="math inline">\(p_0\)</span>。之后，使用雅可比矩阵的行列式，作为体积压缩倍数，就能算出位置的当前的概率密度<span class="math inline">\(p_1\)</span>。</p><h3 id="几个重要量之间的关系">几个重要量之间的关系</h3><ol type="1"><li>流 <span class="math inline">\(\phi_t(x)\)</span></li><li>场 <span class="math inline">\(v_t\)</span></li><li>概率密度 <span class="math inline">\(p_0 \rightarrowp_t\)</span></li></ol><ul><li><strong>从流 <span class="math inline">\(\phi_t(x)\)</span> 到场<span class="math inline">\(v_t\)</span> 的变换：</strong>可以参考公式<span class="math inline">\(\ref{eq:vt}\)</span> 和 <spanclass="math inline">\(\ref{eq:flow_def2}\)</span>。其中，<spanclass="math inline">\(\ref{eq:vt}\)</span> 说明了场 <spanclass="math inline">\(v_t\)</span> 是流 <spanclass="math inline">\(\phi_t(x)\)</span> 的微分，反过来，流 <spanclass="math inline">\(\phi_t(x)\)</span> 是场 <spanclass="math inline">\(v_t\)</span> 的积分。</li><li><strong>从 <span class="math inline">\(p_0\)</span> 到 <spanclass="math inline">\(p_t\)</span> 的变换：</strong>：可以参考公式 <spanclass="math inline">\(\ref{eq:push_forward_eq_def}\)</span>。这个公式说明了当我们想知道<span class="math inline">\(x_1\)</span> 的概率分布 <spanclass="math inline">\(p_1\)</span>，首先，我们需要先用逆函数，将 <spanclass="math inline">\(x\)</span> 变为 <spanclass="math inline">\(x_0\)</span>，算出那个位置原来的概率密度 <spanclass="math inline">\(p_0\)</span>。之后，使用雅可比矩阵的行列式，作为体积压缩倍数，就能算出位置的当前的概率密度<span class="math inline">\(p_1\)</span>。</li><li><strong>从场 <span class="math inline">\(v_t\)</span> 到概率密度<span class="math inline">\(p_t\)</span> 的变换：</strong>可以参考公式<spanclass="math inline">\(\ref{eq:continuity_eq}\)</span>。这个公式说明了概率密度的变化与场<span class="math inline">\(v_t\)</span> 变化之间的关系。当 <spanclass="math inline">\(v_t\)</span>的方向向周围散开，当前位置的概率密度就会变低，反之，则会变高。</li></ul><h2 id="流匹配目标">流匹配目标</h2><h3 id="符号定义">符号定义</h3><ul><li><span class="math inline">\(x_1 \simq(x_1)\)</span>：这是真实数据（比如真实的人脸图片），这在我们训练过程中作为样本数据，其分布未知。</li><li><span class="math inline">\(p_t\)</span>：这是概率路径 (ProbabilityPath)。也就是从噪声变成数据的过程中，中间每一时刻的分布长什么样。</li><li><span class="math inline">\(p_0 =p\)</span>：这是初始分布，一般来说就是简单的分布，比如标准正态分布（噪声）。</li></ul><p>我们的任务就是想办法把简单的 <span class="math inline">\(p_0\)</span>变成复杂的 <span class="math inline">\(q(x_1)\)</span>。</p><h3 id="流匹配的目标公式">流匹配的目标公式</h3><p>假设我们已经有了一个完美的概率路径 <spanclass="math inline">\(p_t(x)\)</span>，那么一定存在一个对应的向量场<spanclass="math inline">\(u_t(x)\)</span>，它能驱动这个路径的演变（生成<span class="math inline">\(p_t\)</span>），那么这个向量场 <spanclass="math inline">\(u_t(x)\)</span> 就是我们想要得到的。而 <spanclass="math inline">\(p_t(x) \leftrightarrowu_t(x)\)</span>，也就是说如果上帝视角已经告诉了我们路径 <spanclass="math inline">\(p_t\)</span>，那对应的速度场 <spanclass="math inline">\(u_t\)</span>也就是确定的了。我们想要构建一个神经网络，其参数为 <spanclass="math inline">\(\theta\)</span>，模型的输出为 <spanclass="math inline">\(v_t(x)\)</span>。流匹配的目标，就是<strong>让神经网络预测的向量场<span class="math inline">\(v_t\)</span>，去尽可能逼近 (Regress)那个完美的向量场 <spanclass="math inline">\(u_t\)</span></strong>。我们使用一个简单的均方误差进行逼近，用公式写出来就是<span class="math inline">\(\ref{eq:fm_objective}\)</span>。</p><p><span class="math display">\[\begin{equation}\mathcal{L}_{FM}(\theta) = \mathbb{E}_{t, p_t(x)} || v_t(x) - u_t(x)||^2 \label{eq:fm_objective}\end{equation}\]</span></p><h3 id="面临的问题">面临的问题</h3><p>公式 <span class="math inline">\(\ref{eq:fm_objective}\)</span>面临一个严重的问题就是我们事先不知道 <spanclass="math inline">\(p_t\)</span> 和 <spanclass="math inline">\(u_t\)</span>。我们只有头（噪声 <spanclass="math inline">\(p_0\)</span>）和尾（真图 <spanclass="math inline">\(p_1\)</span>），中间到底该怎么走（<spanclass="math inline">\(p_t\)</span>）？中间的速度到底是多少（<spanclass="math inline">\(u_t\)</span>）？我们是不知道的！如果我们不知道标准答案<span class="math inline">\(u_t\)</span>，怎么去训练网络 <spanclass="math inline">\(v_t\)</span> 呢？</p><div class="note success flat"><p>Diffusion是通过“逐步加噪”（固定好的正态分布变换）<strong>强行定义了中间的 <spanclass="math inline">\(p_t\)</span></strong>，所以它知道中间长什么样。</p></div><p>为了解决这个问题，下一节的内容将会给出两种解决思路：<strong>给出<span class="math inline">\(u_t\)</span>形式</strong>或者<strong>创建一个更易实现的流目标</strong></p><h2id="通过条件概率路径和向量场构建-p_t-和-u_t">通过条件概率路径和向量场构建<span class="math inline">\(p_t\)</span> 和 <spanclass="math inline">\(u_t\)</span></h2><h3 id="构建-p_t">构建 <span class="math inline">\(p_t\)</span></h3><h4 id="条件概率路径">条件概率路径</h4><p>一个简单的构造复杂概率路径的方法是通过混合一系列的更简单的概率路径。如果给定了一个样本数据<span class="math inline">\(x_1\)</span>，我们定义 <spanclass="math inline">\(p_t(x | x_1)\)</span>叫做条件概率路径，如果它满足两个条件：</p><ul><li><span class="math inline">\(t = 0\)</span> 时，<spanclass="math inline">\(p_0(x | x_1) = p(x)\)</span>；</li><li><span class="math inline">\(t = 1\)</span> 时，<spanclass="math inline">\(p_1(x | x_1) = \mathcal{N}(x; x_1,\sigma^2I)\)</span>，其中 <span class="math inline">\(\sigma\)</span>是一个足够小的正值。</li></ul><div class="note danger flat"><p><span class="math inline">\(\sigma\)</span>是一个足够小的正值保证了这个高斯函数类似于一个脉冲函数，只在 <spanclass="math inline">\(x = x_1\)</span>的时候取一个很大的数，其他地方的取值很小很小。</p></div><p>通过对条件概率路径的边缘化，可以得到边缘概率路径 <spanclass="math inline">\(\ref{eq:marginal_prob_path}\)</span>。 <spanclass="math display">\[\begin{equation}p_t(x) = \int p_t(x | x_1)q(x_1) \text{d}x_1\label{eq:marginal_prob_path}\end{equation}\]</span></p><div class="note success flat"><p>🤯这个公式 <spanclass="math inline">\(\ref{eq:marginal_prob_path}\)</span>其实就是概率论中的全概率公式的连续化版本。表达的是 <spanclass="math inline">\(x\)</span> 的概率，就是在不同的 <spanclass="math inline">\(x_i\)</span> 下的条件分布，去乘上 <spanclass="math inline">\(x_i\)</span>各自出现的概率，最终汇总就有了（只要有） <spanclass="math inline">\(x\)</span> 出现的概率。</p></div><p>当 <span class="math inline">\(t = 0\)</span> 的时候，不难证明 <spanclass="math inline">\(p_0(x) =p(x)\)</span>，也就是初始的时候的数据的分布是一个简单分布。 <spanclass="math display">\[\begin{align}p_0(x) &amp;= \int p_0(x | x_1)q(x_1) \text{d}x_1 \\&amp;= \int p(x)q(x_1) \text{d}x_1 \\&amp;= p(x)\int q(x_1) \text{d}x_1 \\&amp;= p(x)\end{align}\]</span></p><p>接下来，我们需要证明 <span class="math inline">\(t = 1\)</span>的时候，<span class="math inline">\(p_1(x) =q(x)\)</span>，也就是最终的分布是真实的数据的分布。</p><h4 id="狄拉克函数">狄拉克函数</h4><h5 id="公式表达">公式表达</h5><p>首先，我们需要对狄拉克 <span class="math inline">\(\delta\)</span>函数 (Dirac Delta Function) 进行一下补充。狄拉克函数的定义如式 <spanclass="math inline">\(\ref{eq:dirac_func}\)</span>。 <spanclass="math display">\[\begin{equation}\delta(x) = \begin{cases} +\infty &amp; x=0 \\ 0 &amp; x \neq 0\end{cases} \label{eq:dirac_func}\end{equation}\]</span></p><h5 id="积分面积性质">积分（面积）性质</h5><p>这意味着狄拉克函数在原点 <span class="math inline">\(x=0\)</span>处无限高，而在其他任何地方都是0。虽然它无限细、无限高，但它围成的“面积”被强行定义为 1，即公式 <spanclass="math inline">\(\ref{eq:dirac_func_int}\)</span>。 <spanclass="math display">\[\begin{equation}\int_{-\infty}^{+\infty} \delta(x) dx = 1 \label{eq:dirac_func_int}\end{equation}\]</span></p><h5 id="筛选性质">筛选性质</h5><p>筛选性质是这个函数最有用的地方，公式表达为 <spanclass="math display">\[\int_{-\infty}^{\infty} f(x) \delta(x-a) dx = f(a)\]</span></p><p><span class="math inline">\(\delta(x-a)\)</span>是把狄拉克函数的脉冲的“尖刺”从原点移到了 <spanclass="math inline">\(x=a\)</span> 的位置。当我们拿任何函数 <spanclass="math inline">\(f(x)\)</span>去乘以这个尖刺并积分时，积分的结果就像是一只手，只把 <spanclass="math inline">\(x=a\)</span> 那个位置的函数值 <spanclass="math inline">\(f(a)\)</span>给“抓”了出来，其他部分的信息全被扔掉了（因为乘以了 0）。</p><p>参照这个思路的证明过程如下所示： <span class="math display">\[\begin{align}\int_{-\infty}^{\infty} f(x) \delta(x-a) dx &amp;=\int_{-\infty}^{\infty} f(a) \delta(x-a) \\&amp;= f(a) \int_{-\infty}^{\infty} \delta(x-a) \\&amp;= f(a)\end{align}\]</span></p><p>回到本问题，因为我们规定了 <span class="math inline">\(p_1(x | x_1) =\mathcal{N}(x; x_1, \sigma^2I)\)</span>，并且高斯分布的均值为 <spanclass="math inline">\(x_1\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span> 且 <spanclass="math inline">\(\sigma\)</span>是一个足够小的正值。那么如果把这个高斯分布的图像画一下，可以发现它其实也是近似于一个狄拉克函数的。并且，其“尖刺”是位于<span class="math inline">\(x = x_1\)</span>均值这个地方。这样一来，</p><p><span class="math display">\[\begin{align}p_1(x) &amp;= \int p_1(x | x_1)q(x_1) \text{d}x_1 \\&amp;= \int \delta^*(x - x_1) q(x_1) \text{d}x_1 \\&amp;\approx q(x) \int \delta^*(x - x_1) \text{d}x_1 \\&amp;\approx q(x)\end{align}\]</span></p><p>注意上面式子中是对 <span class="math inline">\(x_1\)</span>进行积分，只有当 <span class="math inline">\(x_1 = x\)</span>的时候，高斯分布才会有一个很大的值，其余位置都取极小的数值，因此可以近似为一个狄拉克函数，在公式中我们记为了<spanclass="math inline">\(\delta^*\)</span>。也正是因为只是近似狄拉克函数，所以最后这里是取约等于号<span class="math inline">\(\approx\)</span> 而非严格相等。</p><div class="note danger flat"><p>🧐<strong>为什么设置 <span class="math inline">\(t = 1\)</span>为高斯分布？</strong></p><hr /><p>EDM p22（待补充）</p></div><h3 id="构建-u_t">构建 <span class="math inline">\(u_t\)</span></h3><p>在前面一小节我们已经构造出了 <span class="math inline">\(p_t(x |x_1)\)</span> 和 <span class="math inline">\(p_t(x)\)</span>的表达式了。现在，让我们用连续性方程 <spanclass="math inline">\(\ref{eq:continuity_eq}\)</span> 来求解得到 <spanclass="math inline">\(u_t(x | x_1)\)</span>。由边缘化场向量，可以得到<span class="math inline">\(u_t(x)\)</span> 的形式，见公式 <spanclass="math inline">\(\ref{eq:marginal_vec_field}\)</span>。我们的目标任务是，证明此时的<span class="math inline">\(p_t(x)\)</span> 和 <spanclass="math inline">\(u_t(x)\)</span>，也是满足连续性方程 <spanclass="math inline">\(\ref{eq:continuity_eq}\)</span>的。</p><p><span class="math display">\[\begin{equation}u_t(x) = \int u_t(x | x_1) \frac{p_t(x | x_1)q(x_1)}{p_t(x)} \text{d}x_1 \label{eq:marginal_vec_field}\end{equation}\]</span></p><div class="note info flat"><p><strong>梳理一下现在我们得到的信息</strong></p><hr /><p>已知信息：<span class="math inline">\(p_t(x | x_1)\)</span> 和 <spanclass="math inline">\(p_t(x)\)</span>，以及这两个概率路径之间的关系式<spanclass="math inline">\(\ref{eq:marginal_prob_path}\)</span>，且通过连续性方程得到了<span class="math inline">\(u_t(x | x_1)\)</span>。 求解目标：<spanclass="math inline">\(u_t(x)\)</span>，且 <spanclass="math inline">\(u_t(x)\)</span> 和其对应的 <spanclass="math inline">\(p_t(x)\)</span> 需要满足连续性方程。</p></div><p>推导一下公式 <spanclass="math inline">\(\ref{eq:marginal_vec_field}\)</span>是怎么得来的： <span class="math display">\[\begin{align}\frac{d}{dt}p_t(x) &amp;= \int\left(\frac{d}{dt}p_t(x|x_1)\right)q(x_1)dx_1 \quad \text{（$p_t$ 对时间$t$ 进行求导）}\\&amp;= -\int \text{div}\left(u_t(x|x_1)p_t(x|x_1)\right)q(x_1)dx_1 \quad\text{（代入 $p_t(x|x_1)$ 和 $u_t(x|x_1)$ 的连续性方程）}\\&amp;= -\text{div}\left(\int u_t(x|x_1)p_t(x|x_1)q(x_1)dx_1\right) \quad\text{（交换 div 和 $\int$ 的顺序）} \\&amp;= -\text{div}\left(p_t(x) \underbrace{\int\frac{u_t(x|x_1)p_t(x|x_1)q(x_1)}{p_t(x)}dx_1}_{u_t(x)}\right) \quad\text{（$1 = \frac{p_t(x)}{p_t(x)}$）} \\&amp;= -\text{div}\left(u_t(x)p_t(x)\right)\end{align}\]</span></p><p>注意 <span class="math inline">\(\text{div}\)</span> 是对 <spanclass="math inline">\(x\)</span> 进行求导然后求和，而 <spanclass="math inline">\(\int\)</span> 则是对 <spanclass="math inline">\(x_1\)</span>进行积分，两者作用的变量不同，可以认为是独立的，因此可以交换 <spanclass="math inline">\(\text{div}\)</span> 和 <spanclass="math inline">\(\int\)</span> 的顺序，且在 <spanclass="math inline">\(\int\)</span> 内进行任何对于 <spanclass="math inline">\(x\)</span> 的操作不会影响等式的成立。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> flow_matching </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flow Matching </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diffusion Ch03</title>
      <link href="/2026/02/11/notes/diffusion/diffusion-Ch03/"/>
      <url>/2026/02/11/notes/diffusion/diffusion-Ch03/</url>
      
        <content type="html"><![CDATA[<h2 id="条件扩散模型">条件扩散模型</h2><p>至此，我们研究的都只是简单的分布 <spanclass="math inline">\(p(\boldsymbol{x})\)</span>，然而，在实际应用中，我们经常会对形如<span class="math inline">\(p(\boldsymbol{x} | y)\)</span>这种有条件的分布更感兴趣。这样一来，我们就可以通过条件 <spanclass="math inline">\(y\)</span> 来对生成的数据 <spanclass="math inline">\(\boldsymbol{x}\)</span> 进行控制。例如，在image-text 生成模型中，<span class="math inline">\(y\)</span>就可以被视作对于输入文本 text 的编码。</p><p>回忆我们之前的联合概率密度公式 <span class="math display">\[\begin{equation}p(\boldsymbol{x}_{0:T}) = p(\boldsymbol{x}_T) \prod_{t=1}^{T}p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) \label{eq:dist_uncond}\end{equation}\]</span></p><p>我们在分布 <span class="math inline">\(p(\cdot)\)</span> 中注入条件<span class="math inline">\(y\)</span>，即 <spanclass="math inline">\(p(\cdot | y)\)</span>，公式 <spanclass="math inline">\(\ref{eq:dist_uncond}\)</span> 就会转变成 <spanclass="math inline">\(\ref{eq:dist_cond}\)</span>。 <spanclass="math display">\[\begin{equation}p(\boldsymbol{x}_{0:T}|y) = p(\boldsymbol{x}_T) \prod_{t=1}^{T}p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, y)\label{eq:dist_cond}\end{equation}\]</span></p><p>在上一章节中，我们还研究了扩散模型对于 <spanclass="math inline">\(\mu_q\)</span>的三种设定方式，借此引出了三种不同的优化目标，即</p><ul><li>预测<strong>原始样本数据 <spanclass="math inline">\(x_0\)</span></strong>，即 <spanclass="math inline">\(\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t,y) \approx \boldsymbol{x}_0\)</span>；</li><li>预测<strong>噪声数据 <spanclass="math inline">\(\epsilon\)</span></strong>，即 <spanclass="math inline">\(\hat{\boldsymbol{\epsilon}}_{\theta}(\boldsymbol{x}_t,t, y) \approx \boldsymbol{\epsilon}_0\)</span>；</li><li>预测<strong>分数 <spanclass="math inline">\(\boldsymbol{s}_\theta\)</span></strong>，即 <spanclass="math inline">\(\boldsymbol{s}_{\theta}(\boldsymbol{x}_t, t, y)\approx \nabla \log p(\boldsymbol{x}_t|y)\)</span>。</li></ul><p>如果直接利用公式 <spanclass="math inline">\(\ref{eq:dist_cond}\)</span>来进行条件扩散，我们会发现实际上效果很差，<spanclass="math inline">\(y\)</span>并没有起到什么很明显的作用，仅仅只是多添加了一个输入 <spanclass="math inline">\(y\)</span>，主影响因素仍然是原先的输入 <spanclass="math inline">\(\boldsymbol{x}_t\)</span> 和 <spanclass="math inline">\(t\)</span>，<span class="math inline">\(y\)</span>作为输入条件会被忽略或弱化掉。这一问题的解决是通过两种加强控制条件的方法实现的。</p><p>下面，我们针对<strong>基于分数的（Score-based）</strong>来进行这两种条件扩散方法的说明。</p><h3 id="classifier-guidance">Classifier Guidance</h3><p>首先，我们还是利用贝叶斯公式，对基于分数的扩散模型的优化目标公式进行变换，最后可以得到两项梯度。<span class="math display">\[\begin{align}\nabla_{\boldsymbol{x}_t} \log p(\boldsymbol{x}_t|y) &amp;= \nabla \log\left( \frac{p(\boldsymbol{x}_t)p(y|\boldsymbol{x}_t)}{p(y)} \right) \\&amp;= \nabla \log p(\boldsymbol{x}_t) + \nabla \logp(y|\boldsymbol{x}_t) - \nabla \log p(y) \\&amp;= \underbrace{\nabla \log p(\boldsymbol{x}_t)}_{\text{unconditionalscore}} + \underbrace{\nabla \logp(y|\boldsymbol{x}_t)}_{\text{adversarial gradient}}\label{eq:classifier_guidance}\end{align}\]</span></p><ul><li><strong>Unconditional Score:</strong>这是一个普通的扩散模型，负责让图片看起来“像一张真实的图片”。</li><li><strong>Adversarial Gradient:</strong>这是一个分类器（Classifier）的梯度。它告诉模型：“请把图片修改得更像类别<spanclass="math inline">\(y\)</span>”。这就像一个对抗攻击过程，强迫生成的图片向目标类别靠拢。</li></ul><p>最大化分数，也就是要最大化这两项对数似然，即<strong>“让图片看起来像一张真实的图片”</strong>，并且<strong>“这张图片满足我注入的条件”</strong>。</p><div class="note info flat"><p>❓<strong>为什么叫做“分类器”？</strong></p><p>“分类器”这个名字起得非常直白，就是因为它在数学本质上和工程实现上，真的引入了一个外部的图像分类模型（ImageClassifier）。</p><p>为了理解为什么要叫“分类器”，我们需要看公式中的这一项： <spanclass="math display">\[\nabla_{\boldsymbol{x}_t} \log p(y|\boldsymbol{x}_t)\]</span> 这里的核心是 <spanclass="math inline">\(p(y|\boldsymbol{x}_t)\)</span>。在机器学习中，<spanclass="math inline">\(p(y|\boldsymbol{x})\)</span>是判别式模型（DiscriminativeModel）的标准形式，也就是我们俗称的“分类器”。例如，它的输入 <spanclass="math inline">\(\boldsymbol{x}\)</span>是一张图片（在这里是加了噪声的图片 <spanclass="math inline">\(\boldsymbol{x}_t\)</span>）。输出 <spanclass="math inline">\(y\)</span>是这张图片属于哪个类别（比如“狗”、“猫”或“飞机”）的概率。这样的话任务就是给图片打标签。因为这一项<span class="math inline">\(p(y|\boldsymbol{x}_t)\)</span>的计算任务就是“判断当前的噪声图 <spanclass="math inline">\(\boldsymbol{x}_t\)</span> 像类别 <spanclass="math inline">\(y\)</span>的概率有多大”，所以执行这个任务的模型就被称为“分类器”。</p></div><p>为了进一步能够控制平衡好<strong>无条件项</strong>和<strong>对抗生成项</strong>，我们会引入一个额外的超参数<span class="math inline">\(\gamma\)</span>。 <spanclass="math display">\[\begin{equation}\nabla \log p(\boldsymbol{x}_t|y) = \nabla \log p(\boldsymbol{x}_t) +\gamma \nabla \log p(y|\boldsymbol{x}_t)\label{eq:classifier_guidance_gamma}\end{equation}\]</span></p><ul><li>当 <span class="math inline">\(\gamma = 0\)</span>时，我们不考虑对抗生成项，也就是完全不考虑条件 <spanclass="math inline">\(y\)</span>，仅仅只是让它生成图像。</li><li>随着 <span class="math inline">\(\gamma\)</span>越来越大，模型对于对抗生成项的考虑权重越来越大，会更注意生成的图像是否能够满足条件<span class="math inline">\(y\)</span>。</li></ul><p>这种 Guidance最大的缺点在于，我们需要额外去学习一个分类器模型，也就是用于提供 <spanclass="math inline">\(\nabla_{\boldsymbol{x}_t} \logp(y|\boldsymbol{x}_t)\)</span>梯度的模型。它需要能够在我们给出任意时间步 <spanclass="math inline">\(t\)</span> 的数据 <spanclass="math inline">\(\boldsymbol{x}_t\)</span>时，输出这个时候它满足条件 <span class="math inline">\(y\)</span>的分数，这一点并不高效。</p><h3 id="classifier-free-guidance">Classifier-Free Guidance</h3><p>首先，我们对公式 <spanclass="math inline">\(\ref{eq:classifier_guidance}\)</span>进行一下变换，有 <span class="math display">\[\begin{equation}\nabla \log p(y|\boldsymbol{x}_t) = \nabla \log p(\boldsymbol{x}_t|y) -\nabla \log p(\boldsymbol{x}_t)\end{equation}\]</span></p><p>然后，把这个式子代入到公式 <spanclass="math inline">\(\ref{eq:classifier_guidance_gamma}\)</span>中，会得到 <span class="math display">\[\begin{align}\nabla \log p(\boldsymbol{x}_t|y) &amp;= \nabla \log p(\boldsymbol{x}_t)+ \gamma (\nabla \log p(\boldsymbol{x}_t|y) - \nabla \logp(\boldsymbol{x}_t)) \\&amp;= \nabla \log p(\boldsymbol{x}_t) + \gamma \nabla \logp(\boldsymbol{x}_t|y) - \gamma \nabla \log p(\boldsymbol{x}_t) \\&amp;= \underbrace{\gamma \nabla \logp(\boldsymbol{x}_t|y)}_{\text{conditional score}} + \underbrace{(1 -\gamma) \nabla \log p(\boldsymbol{x}_t)}_{\text{unconditional score}}\label{eq:classifier_free_gamma}\end{align}\]</span></p><p>这个就是无分类器引导的公式。分析一下 <spanclass="math inline">\(\gamma\)</span> 取值带来的影响：</p><ul><li><span class="math inline">\(\gamma = 0\)</span> 时，<spanclass="math inline">\(p(\boldsymbol{x}_t|y)\)</span> 这一项为0，完全不考虑条件 <span class="math inline">\(y\)</span>；</li><li><span class="math inline">\(0 &lt; \gamma &lt; 1\)</span>时，既考虑无条件项，又考虑了对抗生成项；</li><li><span class="math inline">\(\gamma = 1\)</span>时，此时就是最原始的正常训练，之前该忽略 <spanclass="math inline">\(y\)</span> 的，就依旧忽略 <spanclass="math inline">\(y\)</span>；</li><li><span class="math inline">\(\gamma &gt; 1\)</span>时，加强对抗生成项，也就是加强条件控制，而且此时由于 <spanclass="math inline">\(1 - \gamma &lt;0\)</span>，<strong>会导致模型生成远离无条件项</strong>。</li></ul><p>这个时候我们可以分别独立去训练两个模型，一个是 <spanclass="math inline">\(p(\boldsymbol{x}_t|y)\)</span>，另一个是 <spanclass="math inline">\(p(\boldsymbol{x}_t)\)</span>。但实际应用中，训练两个扩散模型成本过高，所以我们还是合并成一个模型使用公式<span class="math inline">\(\ref{eq:classifier_free_gamma}\)</span>进行训练，至于是否使用条件进行控制，则交给超参数 <spanclass="math inline">\(\gamma\)</span> 进行调节即可。</p><h2 id="扩散模型-dm-的训练和推理核心逻辑">扩散模型 DM的训练和推理核心逻辑</h2><p>这一节的重点内容是对前面所有 Diffusion Model知识点做一个串联工作，并由此展现出扩散模型训练和推理的整个核心逻辑。</p><h3 id="加噪过程">加噪过程</h3><p>在加噪过程中，从前面的知识点中，我们可以学习到在统一视角下，有着三种设定优化目标的方式，分别是预测原图<spanclass="math inline">\(\boldsymbol{x}_0\)</span>，预测任意给定时间步<span class="math inline">\(t\)</span> 的噪声 <spanclass="math inline">\(\epsilon_t\)</span>，或者预测分数函数 <spanclass="math inline">\(\boldsymbol{s}_\theta\)</span>。这里的预测是通过学习一个UNet 网络实现的。</p><p>以 DDPM 论文作为参考，我们使用预测噪声的视角，这个时候的优化目标 ELBO可以写成 <span class="math display">\[\begin{equation}\| \epsilon_t - \hat{\epsilon}_\theta(\boldsymbol{x}_t, t) \|^2_2\end{equation}\]</span> 其中 <span class="math inline">\(\theta\)</span> 就是 UNet网络需要学习的参数。</p><h3 id="去噪过程">去噪过程</h3><p>去噪的过程本质就是一个采样的过程，即计算 <spanclass="math inline">\(p(\boldsymbol{x}_{t-1} |\boldsymbol{x}_t)\)</span>。</p><p>去噪的流程见下方： <span class="math display">\[\begin{equation*}% 第一步：加噪与定义\underset{\substack{\color{green}\text{设定:} \\\color{green}\mathcal{N}(\boldsymbol{x}_t;\sqrt{\alpha_t}\boldsymbol{x}_{t-1},(1-\alpha_t)\mathbf{I})}}{\overset{\color{orange}\text{加噪}}{p(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})}}\quad \xrightarrow{\text{推导}} \quad% 第二步：任意时刻的分布（Boxed）\boxed{\underset{\color{red}\text{累加式}}{\overset{\color{purple}\text{与学习U-Net 有关}}{p(\boldsymbol{x}_t|\boldsymbol{x}_0)}} }\quad \xrightarrow{\text{推导去噪}} \quad% 第三步：真实后验（Boxed）\boxed{\underset{\color{red}\text{贝叶斯公式}}{\overset{\color{purple}\text{采样}}{p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)}} }\quad \xrightarrow{\text{近似}} \quad% 第四步：模型预测p(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)\end{equation*}\]</span></p><h3 id="训练流程">训练流程</h3><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>数据准备</p></div></div><div class='timeline-item-content'><p>从数据集中随机选取一张图片 <spanclass="math inline">\(\boldsymbol{x}_0\)</span></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>时间步准备</p></div></div><div class='timeline-item-content'><p>设定最大去噪步数为 <spanclass="math inline">\(T\)</span>，从均匀分布中随机采样一个时间步 <spanclass="math inline">\(t \sim U(1, T)\)</span>，获取 <spanclass="math inline">\(\alpha_t\)</span> 等数据</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>噪声准备</p></div></div><div class='timeline-item-content'><p>从标准高斯分布中采样一个噪声 <span class="math inline">\(\epsilon_0\sim \mathcal{N}(0, I)\)</span></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>加噪</p></div></div><div class='timeline-item-content'><p>根据公式 <span class="math display">\[\boldsymbol{x}_t = \sqrt{\bar{\alpha}_t} \boldsymbol{x}_0 + (1 -\bar{\alpha}_t) \epsilon_0\]</span></p><p>计算获取 <span class="math inline">\(t\)</span> 步加噪后的噪图 <spanclass="math inline">\(\boldsymbol{x}_t\)</span></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>训练</p></div></div><div class='timeline-item-content'><p>根据优化目标，训练 UNet 网络进行预测（以视角二——预测噪声为例）：<span class="math display">\[\epsilon_0 \approx \hat{\epsilon}_\theta(\boldsymbol{x}_t, t)\]</span></p></div></div></div><h3 id="推理流程">推理流程</h3><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>数据准备</p></div></div><div class='timeline-item-content'><p>从标准高斯分布中采样一个全噪图 <spanclass="math inline">\(\boldsymbol{x}_T\)</span></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>从第 <span class="math inline">\(T-1\)</span>步开始迭代，预测每一步的噪声</p></div></div><div class='timeline-item-content'><p>利用训练好的 UNet 网络预测当前时间步 <spanclass="math inline">\(t\)</span> 的噪声 <spanclass="math inline">\(\hat{\epsilon}_t(\boldsymbol{x}_t, t) \approx\epsilon_t\)</span></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>更新获取 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span></p></div></div><div class='timeline-item-content'><p><span class="math display">\[\boldsymbol{x}_{t-1} \approx \mu_{\theta}(\boldsymbol{x}_t, t) =\frac{1}{\sqrt{\alpha_t}} \boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\hat{\epsilon}_{\theta}(\boldsymbol{x}_t, t)\]</span></p></div></div></div><div class="note danger flat"><p>✏️<strong>为什么说均值 <spanclass="math inline">\(\mu_\theta\)</span> 就是 <spanclass="math inline">\(x_{t-1}\)</span> 的近似值？</strong></p><hr /><p>在扩散模型的逆向过程（ReverseProcess）中，神经网络预测的不是一个“定值”，而是一个概率分布。</p><p>我们假设 <span class="math inline">\(p_\theta(x_{t-1} | x_t)\)</span>是一个高斯分布（正态分布）： <span class="math display">\[p_\theta(x_{t-1} | x_t) = \mathcal{N}(x_{t-1};\boldsymbol{\mu}_\theta(x_t, t), \boldsymbol{\Sigma}_\theta(x_t, t))\]</span></p><p><spanclass="math inline">\(\boldsymbol{\mu}_\theta\)</span>（均值）代表这个高斯分布的峰值位置，也就是概率最大的那个点。<spanclass="math inline">\(\boldsymbol{\Sigma}_\theta\)</span>（方差）代表不确定性，也就是可能的波动范围。</p><p>为什么说它是近似值？当你从这个分布中采样得到 <spanclass="math inline">\(x_{t-1}\)</span> 时，公式是这样的： <spanclass="math display">\[x_{t-1} = \underbrace{\boldsymbol{\mu}_\theta(x_t,t)}_{\text{确定性部分（图像内容）}} + \underbrace{\sigma_t\boldsymbol{z}}_{\text{随机噪声}}\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{z} \sim \mathcal{N}(0,\mathbf{I})\)</span>。如果我们忽略随机噪声（即让 <spanclass="math inline">\(\boldsymbol{z}=0\)</span>），那么 <spanclass="math inline">\(x_{t-1}\)</span> 就完全等于 <spanclass="math inline">\(\boldsymbol{\mu}_\theta\)</span>。所以，<spanclass="math inline">\(\boldsymbol{\mu}_\theta\)</span>本质上就是去除了随机扰动后的 <spanclass="math inline">\(x_{t-1}\)</span> 的核心骨架。</p></div>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diffusion Ch02</title>
      <link href="/2026/02/10/notes/diffusion/diffusion-Ch02/"/>
      <url>/2026/02/10/notes/diffusion/diffusion-Ch02/</url>
      
        <content type="html"><![CDATA[<p>在上一章中，我们讲了 VDM 的第一种拆解方式，我们最终把 <spanclass="math inline">\(\text{ELBO}\)</span> 拆解成了 3项，分别是重建项、先验匹配项和一致项。这一种拆解的特点可总结如下：</p><ol type="1"><li>三项都有期望，因此可以用蒙特卡洛方法来进行估计；</li><li>“一致项”在时间步 <span class="math inline">\(t\)</span>的时候，与两个随机变量 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span> 和 <spanclass="math inline">\(\boldsymbol{x}_{t+1}\)</span>都有关系，因此估计的方差会比单个变量估计的方差大。在“一致性项”中，模型试图让“从<span class="math inline">\(t+1\)</span> 推回 <spanclass="math inline">\(t\)</span> 的分布”去匹配“从 <spanclass="math inline">\(t-1\)</span> 推到 <spanclass="math inline">\(t\)</span> 的分布”。因为 <spanclass="math inline">\(t+1\)</span> 和 <spanclass="math inline">\(t-1\)</span>都是采样出来的随机样本，它们都在“抖动”，所以计算出来的 Loss波动会非常大。</li><li>随着总扩散步 <span class="math inline">\(T\)</span>的增大，一致项估计方差也会线性增长。</li></ol><p>因此，这一种的拆解方法并不实用。我们希望最后推导出来的公式，每一项都只与一个随机变量有关。$$ <span class="math display">\[\begin{align}\log p(\boldsymbol{x}) &amp;\geq\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T) \prod_{t=1}^Tp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{\prod_{t=1}^Tq(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T) p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)\prod_{t=2}^Tp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)\prod_{t=2}^T q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})} \right] \quad\color{orange}{(\text{extract } t=1)} \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T) p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)\prod_{t=2}^Tp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)\prod_{t=2}^T q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1},\boldsymbol{x}_0)} \right] \quad (\color{green}{(\text{Markovproperty})} \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p_{\theta}(\boldsymbol{x}_T)p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}+ \log \prod_{t=2}^T\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1},\boldsymbol{x}_0)} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}+ \log \prod_{t=2}^T\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{\frac{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)q(\boldsymbol{x}_t|\boldsymbol{x}_0)}{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_0)}}\right] \quad \color{orange}{(\text{Bayes rule})} \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}+ \log \prod_{t=2}^{T}\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{\frac{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)q(\boldsymbol{x}_t|\boldsymbol{x}_0)}{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_0)}}\right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}+ \log\frac{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}{q(\boldsymbol{x}_T|\boldsymbol{x}_0)}+ \log \prod_{t=2}^{T}\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \logp_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1) + \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_0)} +\sum_{t=2}^{T} \log\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} [\logp_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)] +\mathbb{E}_{q(\boldsymbol{x}_T|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_0)} \right]+ \sum_{t=2}^{T} \mathbb{E}_{q(\boldsymbol{x}_t,\boldsymbol{x}_{t-1}|\boldsymbol{x}_0)} \left[ \log\frac{p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)} \right] \\&amp;= \underbrace{\mathbb{E}_{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}[\logp_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)]}_{\text{reconstructionterm}} - \underbrace{D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_0)\parallel p(\boldsymbol{x}_T))}_{\text{prior matching term}} -\underbrace{\sum_{t=2}^{T}\mathbb{E}_{q(\boldsymbol{x}_t|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0) \parallelp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t))]}_{\text{denoisingmatching term}}\end{align}\]</span> $$</p><p>我们成功用另一种形式来推导出了 <spanclass="math inline">\(\text{ELBO}\)</span>的三项表达式。与之前一样，我们再来分析一下这三项。</p><ul><li><spanclass="math inline">\(\mathbb{E}_{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}[\log p_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)]\)</span>这一部分与之前的相同，也是重建项，此处不再赘述。</li><li><spanclass="math inline">\(D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_0)\parallel p(\boldsymbol{x}_T))\)</span>是先验匹配项。它的含义也是我们最终生成的噪声，与最终标准分布的噪声 <spanclass="math inline">\(\boldsymbol{x}_T\)</span> 的相似程度。在 <spanclass="math inline">\(T\)</span> 足够大的时候，我们也可以假设其近似为0，因此也是可以忽略掉的。</li><li><span class="math inline">\(\sum_{t=2}^{T}\mathbb{E}_{q(\boldsymbol{x}_t|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0) \parallelp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t))]\)</span>这一项是去噪匹配项，这是与之前差距最大的地方。它所描述的是真实的去噪分布<span class="math inline">\(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)\)</span> 与我们模型近似的去噪分布 <spanclass="math inline">\(p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)\)</span>之间的相似程度。可以看到这个时候我们只需要一个变量 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span>就可以了，因此最后的方差会小很多。</li></ul><p>两种方法的第三项有着本质的区别。上一章中的思想是<strong>保持去噪和加噪过程的一致性</strong>，它规定了由<span class="math inline">\(\boldsymbol{x}_{t-1}\)</span> 加噪生成的<span class="math inline">\(\boldsymbol{x}_{t}\)</span> 必须与 <spanclass="math inline">\(\boldsymbol{x}_{t+1}\)</span> 去噪生成的 <spanclass="math inline">\(\boldsymbol{x}_{t}\)</span>保持一致。所以这会涉及到两个变量。而本章节中的第二种方法则仅针对去噪过程而言的，只需要 <spanclass="math inline">\(\boldsymbol{x}_{t+1}\)</span> 去噪生成的 <spanclass="math inline">\(\boldsymbol{x}_{t}\)</span>的近似去噪分布能够与真实去噪分布接近即可！</p><h2id="扩散模型优化目标在高斯限制条件加噪过程下的最终形式变化思路">扩散模型优化目标在高斯限制条件（加噪过程）下的最终形式变化思路</h2><h3 id="前向加噪过程">前向加噪过程</h3><p>首先让我们再次写出我们之前推导得到的 <spanclass="math inline">\(\text{ELBO}\)</span> 表达式：</p><p><span class="math display">\[\begin{equation}\underbrace{\mathbb{E}_{q(\boldsymbol{x}_1|\boldsymbol{x}_0)} [\logp_{\theta}(\boldsymbol{x}_0|\boldsymbol{x}_1)]}_{\text{reconstructionterm}} - \underbrace{D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_0)\parallel p(\boldsymbol{x}_T))}_{\text{prior matching term}} -\underbrace{\sum_{t=2}^{T}\mathbb{E}_{q(\boldsymbol{x}_t|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0) \parallelp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t))]}_{\text{denoisingmatching term}}\end{equation}\]</span></p><h4 id="前向加噪的公式推导">前向加噪的公式推导</h4><p>回顾 MHVAE 的第 2 个限制条件——加噪过程可以建模成高斯分布。写出 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span> 到 <spanclass="math inline">\(\boldsymbol{x}_{t}\)</span> 的递推式：</p><p><span class="math display">\[\begin{equation} \label{eq:forward1}q(\boldsymbol{x}_{t} | \boldsymbol{x}_{t-1}) =\mathcal{N}(\boldsymbol{x}_{t}; \sqrt{\alpha_t}\boldsymbol{x}_{t-1}, (1- \alpha_t)\textbf{I})\end{equation}\]</span></p><p>注意我们的 <span class="math inline">\(\alpha\)</span>是预先就给定好的，并不是超参数，不参与训练。因此，加噪过程是一个完全确定的模型。</p><p>应用一下重参数化技巧，我们可以得到： <span class="math display">\[\begin{equation} \label{eq:forward_reparam}\boldsymbol{x}_t = \sqrt{\alpha_t}\boldsymbol{x}_{t-1} + \sqrt{1 -\alpha_t}\boldsymbol{\epsilon} \quad \text{with } \boldsymbol{\epsilon}\sim \mathcal{N}(\boldsymbol{\epsilon}; \mathbf{0}, \mathbf{I})\end{equation}\]</span></p><p>同理，我们也可以获取 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span> 时候的重参数化公式：<span class="math display">\[\begin{equation} \label{eq:forward_reparam2}\boldsymbol{x}_{t-1} = \sqrt{\alpha_{t-1}}\boldsymbol{x}_{t-2} + \sqrt{1- \alpha_{t-1}}\boldsymbol{\epsilon} \quad \text{with }\boldsymbol{\epsilon} \sim \mathcal{N}(\boldsymbol{\epsilon};\mathbf{0}, \mathbf{I})\end{equation}\]</span> 注意我们把公式 <spanclass="math inline">\(\ref{eq:forward_reparam2}\)</span> 代入到 <spanclass="math inline">\(\ref{eq:forward_reparam}\)</span> 中，消去 <spanclass="math inline">\(\boldsymbol{x}_{t-1}\)</span>，我们就得到了 <spanclass="math inline">\(\boldsymbol{x}_{t}\)</span> 和 <spanclass="math inline">\(\boldsymbol{x}_{t-2}\)</span>之间的关系！因此，可以预见，当我们一直这样迭代下去的话，最终就可以得到<span class="math inline">\(\boldsymbol{x}_{t}\)</span> 和 <spanclass="math inline">\(\boldsymbol{x}_{0}\)</span> 之间的关系。</p><p><span class="math display">\[\begin{align}\boldsymbol{x}_t &amp;= \sqrt{\alpha_t}\boldsymbol{x}_{t-1} + \sqrt{1 -\alpha_t}\boldsymbol{\epsilon}^*_{t-1} \\&amp;= \sqrt{\alpha_t} \left( \sqrt{\alpha_{t-1}}\boldsymbol{x}_{t-2} +\sqrt{1 - \alpha_{t-1}}\boldsymbol{\epsilon}^*_{t-2} \right) + \sqrt{1 -\alpha_t}\boldsymbol{\epsilon}^*_{t-1} \\&amp;= \sqrt{\alpha_t \alpha_{t-1}}\boldsymbol{x}_{t-2} + \sqrt{\alpha_t- \alpha_t \alpha_{t-1}}\boldsymbol{\epsilon}^*_{t-2} + \sqrt{1 -\alpha_t}\boldsymbol{\epsilon}^*_{t-1} \label{eq:forward_Q1}\\&amp;= \sqrt{\alpha_t \alpha_{t-1}}\boldsymbol{x}_{t-2} + \sqrt{\sqrt{\alpha_t - \alpha_t \alpha_{t-1}}^2 + \sqrt{1 - \alpha_t}^2 }\boldsymbol{\epsilon}_{t-2} \label{eq:forward_Q2}\\&amp;= \sqrt{\alpha_t \alpha_{t-1}}\boldsymbol{x}_{t-2} + \sqrt{1 -\alpha_t \alpha_{t-1}}\boldsymbol{\epsilon}_{t-2} \\&amp;= \dots \\&amp;= \sqrt{\prod_{i=1}^t \alpha_i}\boldsymbol{x}_0 + \sqrt{1 -\prod_{i=1}^t \alpha_i}\boldsymbol{\epsilon}_0 \\&amp;= \sqrt{\bar{\alpha}_t}\boldsymbol{x}_0 + \sqrt{1 -\bar{\alpha}_t}\boldsymbol{\epsilon}_0 \\&amp;\sim \mathcal{N}(\boldsymbol{x}_t;\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0, (1 - \bar{\alpha}_t)\mathbf{I})\end{align}\]</span></p><p>即 <span class="math display">\[\begin{equation}q(\boldsymbol{x_t} | \boldsymbol{x_0}) = \mathcal{N}(\boldsymbol{x}_t;\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0, (1 - \bar{\alpha}_t)\mathbf{I})\label{eq:forward2}\end{equation}\]</span></p><h4 id="公式难点解释">公式难点解释</h4><p>这部分用于解释说明为什么公式 <spanclass="math inline">\(\ref{eq:forward_Q1}\)</span> 能够变到 <spanclass="math inline">\(\ref{eq:forward_Q2}\)</span> 的。<div class="note danger flat"><p>📒如果随机变量 <span class="math inline">\(X \sim \mathcal{N}(\mu_1,\sigma_1^2)\)</span>，以及 <span class="math inline">\(Y \sim\mathcal{N}(\mu_2, \sigma_2^2)\)</span>，并且 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 独立同分布。那么有 <spanclass="math display">\[aX + bY \sim \mathcal{N}(a\mu_1 + b\mu_2, a^2\sigma_1^2 + b^2\sigma_2^2)\]</span></p></div></p><p>依据这个知识点，我们就可以有</p><p><span class="math display">\[\begin{align}\sqrt{\alpha_t - \alpha_t \alpha_{t-1}}\boldsymbol{\epsilon}^*_{t-2}&amp;\sim \mathcal{N}(0, (\alpha_t - \alpha_t \alpha_{t-1})\textbf{I})\\\sqrt{1 - \alpha_t}\boldsymbol{\epsilon}^*_{t-1} &amp;\sim\mathcal{N}(0, (1 - \alpha_t)\textbf{I}) \\\end{align}\]</span></p><p>于是有下面公式成立：</p><p><span class="math display">\[\begin{equation}\sqrt{\alpha_t - \alpha_t \alpha_{t-1}}\boldsymbol{\epsilon}^*_{t-2} +\sqrt{1 - \alpha_t}\boldsymbol{\epsilon}^*_{t-1} = \sqrt{ \sqrt{\alpha_t- \alpha_t \alpha_{t-1}}^2 + \sqrt{1 - \alpha_t}^2 }\boldsymbol{\epsilon}_{t-2}\end{equation}\]</span></p><h3 id="真实去噪分布表示">真实去噪分布表示</h3><p>接下来，我们需要来研究一下真实去噪分布 <spanclass="math inline">\(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t,\boldsymbol{x}_0)\)</span>怎么表示。我们现在已知的信息有前面前向加噪过程推导出的这些公式，<strong>如何能够由已知的加噪过程，即公式<span class="math inline">\(\ref{eq:forward1}\)</span> 和 <spanclass="math inline">\(\ref{eq:forward2}\)</span>，推导出去噪过程呢？</strong></p><p>借助<strong>贝叶斯公式</strong>，我们可以有： <spanclass="math display">\[\begin{equation}q(\boldsymbol{x}_{t-1} | \boldsymbol{x}_{t}, \boldsymbol{x}_{0}) =\frac{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{t-1},\boldsymbol{x}_{0})q(\boldsymbol{x}_{t-1} |\boldsymbol{x}_{0})}{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{0})}\end{equation}\]</span></p><div class="note warning flat"><p>贝叶斯法则公式如下，证明十分简单，只需要把右边的分母乘到左边即可，思想就是把两个联合分布等价地换了一下顺序而已。<span class="math display">\[q(\boldsymbol{x}_{t-1} | \boldsymbol{x}_{t}, \boldsymbol{x}_{0}) =\frac{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{t-1},\boldsymbol{x}_{0})q(\boldsymbol{x}_{t-1} |\boldsymbol{x}_{0})}{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{0})}\]</span></p></div><p>注意右边分子中的 <span class="math inline">\(q(\boldsymbol{x}_{t} |\boldsymbol{x}_{t-1},\boldsymbol{x}_{0})\)</span>，我们由马尔可夫性质，完全可以把 <spanclass="math inline">\(\boldsymbol{x}_{0}\)</span> 忽略掉，化简即： <spanclass="math display">\[\begin{equation} \label{eq:reverse_gt}q(\boldsymbol{x}_{t-1} | \boldsymbol{x}_{t}, \boldsymbol{x}_{0}) =\frac{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{t-1})q(\boldsymbol{x}_{t-1}| \boldsymbol{x}_{0})}{q(\boldsymbol{x}_{t} | \boldsymbol{x}_{0})}\end{equation}\]</span> 这个时候可以发现，等式 <spanclass="math inline">\(\ref{eq:reverse_gt}\)</span> 右边中的 <spanclass="math inline">\(q(\boldsymbol{x}_{t} |\boldsymbol{x}_{t-1})\)</span> 是递推式 <spanclass="math inline">\(\ref{eq:forward1}\)</span>，而 <spanclass="math inline">\(q(\boldsymbol{x}_{t-1} |\boldsymbol{x}_{0})\)</span> 和 <spanclass="math inline">\(q(\boldsymbol{x}_{t} |\boldsymbol{x}_{0})\)</span> 是累加式 <spanclass="math inline">\(\ref{eq:forward2}\)</span>。还有一个关键点是这三个概率分布都是服从高斯分布的，而他们的乘除运算还是高斯分布，于是，真实去噪分布<span class="math inline">\(q(\boldsymbol{x}_{t-1} | \boldsymbol{x}_{t},\boldsymbol{x}_{0})\)</span> 也是满足高斯分布的。</p><p>具体的推导过程如下所示。 <span class="math display">\[\begin{align}q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0) &amp;=\frac{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1},\boldsymbol{x}_0)q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_0)}{q(\boldsymbol{x}_t|\boldsymbol{x}_0)}\\&amp;= \frac{\mathcal{N}(\boldsymbol{x}_t;\sqrt{\alpha_t}\boldsymbol{x}_{t-1}, (1-\alpha_t)\mathbf{I})\mathcal{N}(\boldsymbol{x}_{t-1};\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0,(1-\bar{\alpha}_{t-1})\mathbf{I})}{\mathcal{N}(\boldsymbol{x}_t;\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0, (1-\bar{\alpha}_t)\mathbf{I})} \\&amp;\propto \exp \left\{ - \left[ \frac{(\boldsymbol{x}_t -\sqrt{\alpha_t}\boldsymbol{x}_{t-1})^2}{2(1-\alpha_t)} +\frac{(\boldsymbol{x}_{t-1} -\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0)^2}{2(1-\bar{\alpha}_{t-1})} -\frac{(\boldsymbol{x}_t -\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0)^2}{2(1-\bar{\alpha}_t)} \right]\right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left[ \frac{(\boldsymbol{x}_t -\sqrt{\alpha_t}\boldsymbol{x}_{t-1})^2}{1-\alpha_t} +\frac{(\boldsymbol{x}_{t-1} -\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0)^2}{1-\bar{\alpha}_{t-1}} +C(\boldsymbol{x}_t, \boldsymbol{x}_0) \right] \right\} \\&amp;\propto \exp \left\{ -\frac{1}{2} \left[\frac{-2\sqrt{\alpha_t}\boldsymbol{x}_t\boldsymbol{x}_{t-1} +\alpha_t\boldsymbol{x}_{t-1}^2}{1-\alpha_t} +\frac{\boldsymbol{x}_{t-1}^2 -2\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_{t-1}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left[ \left(\frac{\alpha_t}{1-\alpha_t} + \frac{1}{1-\bar{\alpha}_{t-1}}\right)\boldsymbol{x}_{t-1}^2 - 2 \left(\frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right)\boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left[\frac{\alpha_t(1-\bar{\alpha}_{t-1}) + 1 -\alpha_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})} \boldsymbol{x}_{t-1}^2 - 2\left( \frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right)\boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left[ \frac{\alpha_t - \bar{\alpha}_t+ 1 - \alpha_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})}\boldsymbol{x}_{t-1}^2 - 2 \left(\frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right)\boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left[ \frac{1 -\bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})}\boldsymbol{x}_{t-1}^2 - 2 \left(\frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right)\boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left( \frac{1 -\bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})} \right) \left[\boldsymbol{x}_{t-1}^2 - 2 \frac{ \left(\frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right) }{ \frac{1 - \bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})}} \boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left( \frac{1 -\bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})} \right) \left[\boldsymbol{x}_{t-1}^2 - 2 \frac{ \left(\frac{\sqrt{\alpha_t}\boldsymbol{x}_t}{1-\alpha_t} +\frac{\sqrt{\bar{\alpha}_{t-1}}\boldsymbol{x}_0}{1-\bar{\alpha}_{t-1}}\right) (1-\alpha_t)(1-\bar{\alpha}_{t-1}) }{ 1 - \bar{\alpha}_t }\boldsymbol{x}_{t-1} \right] \right\} \\&amp;= \exp \left\{ -\frac{1}{2} \left( \frac{1 -\bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})} \right) \left[\boldsymbol{x}_{t-1}^2 - 2 \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0 }{ 1 -\bar{\alpha}_t } \boldsymbol{x}_{t-1} \right] \right\} \\&amp;\propto \mathcal{N} \Bigg( \boldsymbol{x}_{t-1}; \underbrace{\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1 -\bar{\alpha}_t} }_{\boldsymbol{\mu}_q(\boldsymbol{x}_t,\boldsymbol{x}_0)}, \underbrace{ \frac{(1 - \alpha_t)(1 -\bar{\alpha}_{t-1})}{1 - \bar{\alpha}_t} \mathbf{I}}_{\boldsymbol{\Sigma}_q(t)} \Bigg)\end{align}\]</span></p><p>上式的最后一步，我们求解出了<strong>真实去噪分布的均值以及方差</strong>，我们在下方重新书写一份：<span class="math display">\[\begin{align}\mu_q(x_0, x_t) &amp;=\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1 -\bar{\alpha}_t} \label{eq:reverse_gt_mu} \\\sigma^2_q(t) &amp;= \frac{(1 - \alpha_t)(1 - \bar{\alpha}_{t-1})}{1 -\bar{\alpha}_t} \label{eq:reverse_gt_sigma}\end{align}\]</span></p><p>从式 <span class="math inline">\(\ref{eq:reverse_gt_mu}\)</span>可以看出，真实去噪分布的均值与 <spanclass="math inline">\(\boldsymbol{x}_t\)</span> 和 <spanclass="math inline">\(\boldsymbol{x}_0\)</span> 有关系，而方差 <spanclass="math inline">\(\ref{eq:reverse_gt_sigma}\)</span> 仅与时间步<span class="math inline">\(t\)</span> 有关，因此可以看做是定值。</p><h3 id="近似去噪分布表示">近似去噪分布表示</h3><mark class="hl-label orange">为了能够使得近似与真实的去噪分布相近，我们不妨假设近似的去噪分布也是服从高斯分布的。</mark><p><span class="math display">\[\begin{equation}\boldsymbol{x}_{t-1} \simp_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) =\mathcal{N}(\boldsymbol{x}_{t-1}; \mu_{\theta}, \Sigma_{\theta}(t))\end{equation}\]</span> 由公式 <spanclass="math inline">\(\ref{eq:reverse_gt_sigma}\)</span>，我们发现了真实去噪分布的方差是完全确定的，因此我们也假设近似去噪分布的方差<span class="math inline">\(\sigma_{\theta}(t)\)</span> 就等于 <spanclass="math inline">\(\sigma_{q}(t)\)</span>。这样一来，我们只需要关注其均值就好了！</p><h3 id="进一步简化-kl-散度">进一步简化 <spanclass="math inline">\(KL\)</span> 散度</h3><div class="note warning flat"><p>🧀两个多元高斯分布的 <span class="math inline">\(\text{KL}\)</span>散度公式为 <span class="math display">\[D_{\text{KL}}(\mathcal{N}(\boldsymbol{x}; \boldsymbol{\mu}_x,\boldsymbol{\Sigma}_x) \parallel \mathcal{N}(\boldsymbol{y};\boldsymbol{\mu}_y, \boldsymbol{\Sigma}_y)) = \frac{1}{2} \left[ \log\frac{|\boldsymbol{\Sigma}_y|}{|\boldsymbol{\Sigma}_x|} - d +\text{tr}(\boldsymbol{\Sigma}_y^{-1}\boldsymbol{\Sigma}_x) +(\boldsymbol{\mu}_y - \boldsymbol{\mu}_x)^T \boldsymbol{\Sigma}_y^{-1}(\boldsymbol{\mu}_y - \boldsymbol{\mu}_x) \right]\]</span></p></div><p>有了前面众多的铺垫，接下来让我们计算化简一下式 <spanclass="math inline">\(\underset{\theta}{\arg \min}D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t))\)</span>吧！💪 <span class="math display">\[\begin{align}&amp; \underset{\theta}{\arg \min}D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)) \\&amp;= \underset{\theta}{\arg \min}D_{\text{KL}}(\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}_q,\boldsymbol{\Sigma}_q(t)) \parallel \mathcal{N}(\boldsymbol{x}_{t-1};\boldsymbol{\mu}_{\theta}, \boldsymbol{\Sigma}_q(t))) \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2} \left[ \log\frac{|\boldsymbol{\Sigma}_q(t)|}{|\boldsymbol{\Sigma}_q(t)|} - d +\text{tr}(\boldsymbol{\Sigma}_q(t)^{-1}\boldsymbol{\Sigma}_q(t)) +(\boldsymbol{\mu}_{\theta} - \boldsymbol{\mu}_q)^T\boldsymbol{\Sigma}_q(t)^{-1} (\boldsymbol{\mu}_{\theta} -\boldsymbol{\mu}_q) \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2} \left[ \log 1 - d + d +(\boldsymbol{\mu}_{\theta} - \boldsymbol{\mu}_q)^T\boldsymbol{\Sigma}_q(t)^{-1} (\boldsymbol{\mu}_{\theta} -\boldsymbol{\mu}_q) \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2} \left[(\boldsymbol{\mu}_{\theta} - \boldsymbol{\mu}_q)^T\boldsymbol{\Sigma}_q(t)^{-1} (\boldsymbol{\mu}_{\theta} -\boldsymbol{\mu}_q) \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2} \left[(\boldsymbol{\mu}_{\theta} - \boldsymbol{\mu}_q)^T(\sigma_q^2(t)\mathbf{I})^{-1} (\boldsymbol{\mu}_{\theta} -\boldsymbol{\mu}_q) \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\|\boldsymbol{\mu}_{\theta} - \boldsymbol{\mu}_q\|_2^2 \right]\label{eq:objective_normal}\end{align}\]</span></p><p>经过上述“简单”的运算，我们最终得到了一个十分简洁的表达式形式，它告诉我们，实际上我们最终的训练目标，可以只是我们模型近似后验高斯分布的均值，与真实的后验分布的均值的均方误差MSE（系数是可以忽略的）。这个简洁的形式，离不开我们假设近似后验分布的方差与真实后验分布的方差是相同的。</p><p>但是我们的优化目标化归到均值 <span class="math inline">\(\mu\)</span>上，还是不太好进行计算。我们可以进一步对 <spanclass="math inline">\(\mu\)</span>进行不同的设定，来使得我们最终的优化目标更加简单。</p><h3 id="mu-的不同设定"><span class="math inline">\(\mu\)</span>的不同设定</h3><h4 id="利用-x_0-进行设定">利用 <span class="math inline">\(x_0\)</span>进行设定</h4><p>回忆式 <spanclass="math inline">\(\ref{eq:reverse_gt_mu}\)</span>，仿照这个公式，我们设计一个<span class="math inline">\(\mu_\theta(t)\)</span>，如式所示： <spanclass="math display">\[\begin{equation}\mu_\theta(x_t, t) =\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\hat{\boldsymbol{x}}_\theta(\boldsymbol{x}_t,t)}{1 - \bar{\alpha}_t} \label{eq:reverse_mu}\end{equation}\]</span></p><p>这样一来，我们把式 <spanclass="math inline">\(\ref{eq:reverse_gt_mu}\)</span> 和式 <spanclass="math inline">\(\ref{eq:reverse_mu}\)</span> 代入到式 <spanclass="math inline">\(\ref{eq:objective_normal}\)</span>进行化简，如下推导： <span class="math display">\[\begin{align}&amp; \underset{\theta}{\arg \min}D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)) \\&amp;= \underset{\theta}{\arg \min}D_{\text{KL}}(\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}_q,\boldsymbol{\Sigma}_q(t)) \parallel \mathcal{N}(\boldsymbol{x}_{t-1};\boldsymbol{\mu}_{\theta}, \boldsymbol{\Sigma}_q(t))) \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\| \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t,t)}{1-\bar{\alpha}_t} -\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1-\bar{\alpha}_t}\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\|\frac{\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t,t)}{1-\bar{\alpha}_t} -\frac{\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1-\bar{\alpha}_t}\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\| \frac{\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)}{1-\bar{\alpha}_t}(\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) - \boldsymbol{x}_0)\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)^2}{(1-\bar{\alpha}_t)^2} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \label{eq:KL_x0}\end{align}\]</span></p><p>至此，我们得到了 <span class="math inline">\(\mu_q\)</span>的第一种设定方法，也就是我们学习一个神经网络，然后从给定的任意时刻 <spanclass="math inline">\(t\)</span> 和其对应的噪声数据 <spanclass="math inline">\(\boldsymbol{x}_t\)</span>，预测出原样本数据 <spanclass="math inline">\(\boldsymbol{x}_0\)</span>。</p><p>另外，我们这里推导的都只是一项 <spanclass="math inline">\(\text{KL}\)</span>散度，别忘了去噪匹配项中，前面还有一个加和运算 <spanclass="math inline">\(\Sigma^T_{t=2}\)</span>。在这里，为了实现这一目标，我们把加和项变成一个均匀分布的期望。<span class="math display">\[\underset{\theta}{\arg \min} \mathbb{E}_{t \sim U\{2, T\}} \left[\mathbb{E}_{q(\boldsymbol{x}_t|\boldsymbol{x}_0)} \left[D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)) \right]\right]\]</span></p><div class="note success flat"><p>💡这也是为什么在扩散模型算法的流程中，第一步总是随机选取一个时间步<span class="math inline">\(t\)</span>。</p></div><h4 id="利用-epsilon_t-进行设定">利用 <spanclass="math inline">\(\epsilon_t\)</span> 进行设定</h4><p>由前面的公式，我们有公式 <spanclass="math inline">\(\ref{eq:mu_epsilon}\)</span> 成立。 <spanclass="math display">\[\begin{equation}\boldsymbol{x}_0 = \frac{\boldsymbol{x}_t - \sqrt{1 -\bar{\alpha}_t}\boldsymbol{\epsilon}_0}{\sqrt{\bar{\alpha}_t}}\label{eq:mu_epsilon}\end{equation}\]</span></p><p>之后将 <span class="math inline">\(\mu_q\)</span> 改写为 <spanclass="math inline">\(\boldsymbol{x}_t\)</span> 和 <spanclass="math inline">\(\epsilon_t\)</span> 的形式，也就是把 <spanclass="math inline">\(\boldsymbol{x}_0\)</span> 进行替换，即： <spanclass="math display">\[\begin{align}\boldsymbol{\mu}_q(\boldsymbol{x}_t, \boldsymbol{x}_0) &amp;=\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1-\bar{\alpha}_t}\\&amp;= \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t) \frac{\boldsymbol{x}_t -\sqrt{1-\bar{\alpha}_t}\boldsymbol{\epsilon}_0}{\sqrt{\bar{\alpha}_t}}}{1-\bar{\alpha}_t}\\&amp;= \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +(1-\alpha_t) \frac{\boldsymbol{x}_t -\sqrt{1-\bar{\alpha}_t}\boldsymbol{\epsilon}_0}{\sqrt{\alpha_t}}}{1-\bar{\alpha}_t}\\&amp;=\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t}{1-\bar{\alpha}_t}+ \frac{(1-\alpha_t)\boldsymbol{x}_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}-\frac{(1-\alpha_t)\sqrt{1-\bar{\alpha}_t}\boldsymbol{\epsilon}_0}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}\\&amp;= \left(\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})}{1-\bar{\alpha}_t} +\frac{1-\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \right)\boldsymbol{x}_t -\frac{(1-\alpha_t)\sqrt{1-\bar{\alpha}_t}}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0 \\&amp;= \left(\frac{\alpha_t(1-\bar{\alpha}_{t-1})}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}+ \frac{1-\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \right)\boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0 \\&amp;= \frac{\alpha_t - \bar{\alpha}_t + 1 -\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0 \\&amp;= \frac{1-\bar{\alpha}_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}\boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0 \\&amp;= \frac{1}{\sqrt{\alpha_t}} \boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0\end{align}\]</span></p><p>这就是真实的后验分布的概率分布函数。接下来我们可以依葫芦画瓢，设定一下近似的后验分布的函数表达式：<span class="math display">\[\boldsymbol{\mu_\theta}(\boldsymbol{x}_t, t) = \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0\]</span></p><p>于是此时的优化目标，<span class="math inline">\(\text{KL}\)</span>散度就可以表示成 <span class="math display">\[\begin{align}&amp; \underset{\theta}{\arg \min}D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)) \\&amp;= \underset{\theta}{\arg \min}D_{\text{KL}}(\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}_q,\boldsymbol{\Sigma}_q(t)) \parallel \mathcal{N}(\boldsymbol{x}_{t-1};\boldsymbol{\mu}_{\theta}, \boldsymbol{\Sigma}_q(t))) \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\| \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\hat{\boldsymbol{\epsilon}}_{\theta}(\boldsymbol{x}_t,t) - \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\|\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\boldsymbol{\epsilon}_0-\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}\hat{\boldsymbol{\epsilon}}_{\theta}(\boldsymbol{x}_t,t) \right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\|\frac{1-\alpha_t}{\sqrt{1-\bar{\alpha}_t}\sqrt{\alpha_t}}(\boldsymbol{\epsilon}_0- \hat{\boldsymbol{\epsilon}}_{\theta}(\boldsymbol{x}_t, t))\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{(1-\bar{\alpha}_t)\alpha_t} \left[\|\boldsymbol{\epsilon}_0 -\hat{\boldsymbol{\epsilon}}_{\theta}(\boldsymbol{x}_t, t)\|_2^2 \right]\end{align}\]</span></p><h4 id="利用分数函数进行设定">利用分数函数进行设定</h4><p>首先，我们需要先来用一下 <strong>Tweedie 公式</strong>。</p><div class="note info flat"><p>Tweedie（特威迪）公式揭示了<strong>去噪后的真实均值</strong>（左边）可以通过<strong>当前噪声数据加上分数函数（ScoreFunction）</strong>（右边）直接计算出来。 <span class="math display">\[\begin{equation}\mathbb{E}[\boldsymbol{\mu}_z | \boldsymbol{z}] = \boldsymbol{z} +\boldsymbol{\Sigma}_z \nabla_{\boldsymbol{z}} \log p(\boldsymbol{z})\label{eq:tweedie}\end{equation}\]</span></p><hr /><p><strong>证明如下：</strong></p><p>我们假设存在一个“原本的、干净的、真实的”数值 <spanclass="math inline">\(\theta\)</span>，它遵循某种自然的规律分布 <spanclass="math inline">\(\pi(\theta)\)</span>，即 <spanclass="math inline">\(\theta \sim \pi(\theta)\)</span>。</p><p>观测值（含噪数据）<span class="math inline">\(x \sim \mathcal{N}(x;\theta, \sigma^2)\)</span>。即 <spanclass="math inline">\(f(x|\theta)\)</span> 是一个均值为 <spanclass="math inline">\(\theta\)</span>，方差为 <spanclass="math inline">\(\sigma^2\)</span> 的高斯分布。</p><p>于是 <span class="math inline">\(x\)</span>的分布可以由边际分布（证据）：<span class="math inline">\(m(x) = \intf(x|\theta)\pi(\theta) d\theta\)</span> 得到。</p><hr /><p>证明从计算后验期望（即我们想要的去噪结果）开始： <spanclass="math display">\[\mathbb{E}[\theta|x] = \int \theta f(\theta|x) d\theta\]</span></p><p>之后，我们使用了一个经典的<strong>“加一项减一项” (Add ZeroTrick)</strong> 技巧：将 <span class="math inline">\(\theta\)</span>写成 <span class="math inline">\((\theta - x + x)\)</span>。 <spanclass="math display">\[\begin{align*}\mathbb{E}[\theta|x] &amp;= \int (\theta - x + x) f(\theta|x) d\theta \\&amp;= \underbrace{\int (\theta - x) f(\theta|x)d\theta}_{\text{第一部分：残差项}} + \underbrace{\int x f(\theta|x)d\theta}_{\text{第二部分：基准项}}\end{align*}\]</span> 第二部分很简单：因为 <span class="math inline">\(x\)</span>对于积分变量 <span class="math inline">\(\theta\)</span>来说是常数，且概率密度积分为1，所以这一项就是 <spanclass="math inline">\(x\)</span>。这对应了公式 <spanclass="math inline">\(\ref{eq:tweedie}\)</span> 里的第一项。</p><p>第一部分是难点：利用贝叶斯公式 <spanclass="math inline">\(f(\theta|x) =\frac{f(x|\theta)\pi(\theta)}{m(x)}\)</span> 展开： <spanclass="math display">\[\text{Term 1} = \int (\theta - x) \frac{f(x|\theta)\pi(\theta)}{m(x)}d\theta = \frac{1}{m(x)} \int (\theta - x) f(x|\theta)\pi(\theta)d\theta\]</span></p><p>为了处理上面那个积分里的 <span class="math inline">\((\theta - x)f(x|\theta)\)</span>，考虑对边际分布 <spanclass="math inline">\(m(x)\)</span> 求导： <span class="math display">\[m&#39;(x) = \frac{\partial}{\partial x} \int f(x|\theta)\pi(\theta)d\theta\]</span></p><p>交换积分与微分符号，核心在于对高斯似然函数 <spanclass="math inline">\(f(x|\theta)\)</span> 求导： <spanclass="math display">\[f(x|\theta) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\theta)^2}{2\sigma^2}}\]</span></p><p><span class="math display">\[\frac{\partial}{\partial x} f(x|\theta)= f(x|\theta) \cdot \left( -\frac{2(x-\theta)}{2\sigma^2} \right) =f(x|\theta) \frac{\theta - x}{\sigma^2}\]</span></p><p>这样一来，导数里自动出现了我们刚才需要的 <spanclass="math inline">\((\theta - x)\)</span> 项！所以： <spanclass="math display">\[m&#39;(x) = \int \left( f(x|\theta) \frac{\theta - x}{\sigma^2} \right)\pi(\theta) d\theta\]</span></p><p>移项整理得到： <span class="math display">\[\sigma^2 m&#39;(x) = \int (\theta - x) f(x|\theta)\pi(\theta) d\theta\]</span></p><p>现在把第3步的结果代回第2步的式子中： <span class="math display">\[\begin{align*}\mathbb{E}[\theta|x] &amp;= x + \frac{1}{m(x)} \cdot \underbrace{\int(\theta - x) f(x|\theta)\pi(\theta) d\theta}_{\text{替换为 } \sigma^2m&#39;(x)} \\&amp;= x + \frac{1}{m(x)} \cdot \sigma^2 m&#39;(x) \\&amp;= x + \sigma^2 \frac{m&#39;(x)}{m(x)}\end{align*}\]</span> 利用对数导数性质 <span class="math inline">\(\frac{u&#39;}{u}= (\log u)&#39;\)</span>，最终得到： <span class="math display">\[\mathbb{E}[\theta|x] = x + \sigma^2 \frac{d}{dx} \log m(x)\]</span></p></div><p>由公式 <spanclass="math inline">\(\ref{eq:forward2}\)</span>，我们可以得到其均值<span class="math inline">\(\mu\)</span> 和方差 <spanclass="math inline">\(\sigma^2\)</span>。代入 Tweedie 公式中，可以得到<span class="math display">\[\begin{equation}\mathbb{E}[\boldsymbol{\mu}_{\boldsymbol{x}_t}|\boldsymbol{x}_t] =\boldsymbol{x}_t + (1 - \bar{\alpha}_t)\nabla_{\boldsymbol{x}_t} \logp(\boldsymbol{x}_t)\end{equation}\]</span></p><p>注意我们用 <span class="math inline">\(\mu =\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0\)</span> 来估计 <spanclass="math inline">\(\mathbb{E}[\boldsymbol{\mu}_{\boldsymbol{x}_t}|\boldsymbol{x}_t]\)</span>，可以有下式成立。<span class="math display">\[\begin{equation}\sqrt{\bar{\alpha}_t}\boldsymbol{x}_0 = \boldsymbol{x}_t + (1 -\bar{\alpha}_t)\nabla \log p(\boldsymbol{x}_t)\end{equation}\]</span></p><p>最终可以得到 <span class="math inline">\(\boldsymbol{x}_0\)</span>和对数似然 <span class="math inline">\(\log p(\boldsymbol{x}_t)\)</span>之间的关系式 <spanclass="math inline">\(\ref{eq:build_x0_with_score}\)</span> <spanclass="math display">\[\begin{equation}\boldsymbol{x}_0 = \frac{\boldsymbol{x}_t + (1 - \bar{\alpha}_t)\nabla\log p(\boldsymbol{x}_t)}{\sqrt{\bar{\alpha}_t}}\label{eq:build_x0_with_score}\end{equation}\]</span></p><p>我们现在有了用分数函数重建的 <spanclass="math inline">\(\boldsymbol{x}_0\)</span>，将其带入到 <spanclass="math inline">\(\ref{eq:reverse_gt_mu}\)</span>，然后进行一系列的化简，得到真实后验分布的均值<span class="math inline">\(\mu_q\)</span>，即 <spanclass="math display">\[\begin{align}\boldsymbol{\mu}_q(\boldsymbol{x}_t, \boldsymbol{x}_0) &amp;=\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t)\boldsymbol{x}_0}{1-\bar{\alpha}_t}\\&amp;= \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1-\alpha_t) \frac{\boldsymbol{x}_t +(1-\bar{\alpha}_t)\nabla \logp(\boldsymbol{x}_t)}{\sqrt{\bar{\alpha}_t}}}{1-\bar{\alpha}_t} \\&amp;= \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t +(1-\alpha_t)\frac{\boldsymbol{x}_t + (1-\bar{\alpha}_t)\nabla \logp(\boldsymbol{x}_t)}{\sqrt{\alpha_t}}}{1-\bar{\alpha}_t} \\&amp;=\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})\boldsymbol{x}_t}{1-\bar{\alpha}_t}+ \frac{(1-\alpha_t)\boldsymbol{x}_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}+ \frac{(1-\alpha_t)(1-\bar{\alpha}_t)\nabla \logp(\boldsymbol{x}_t)}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \\&amp;= \left(\frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})}{1-\bar{\alpha}_t} +\frac{1-\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \right)\boldsymbol{x}_t + \frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \logp(\boldsymbol{x}_t) \\&amp;= \left(\frac{\alpha_t(1-\bar{\alpha}_{t-1})}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}+ \frac{1-\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}} \right)\boldsymbol{x}_t + \frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \logp(\boldsymbol{x}_t) \\&amp;= \frac{\alpha_t - \bar{\alpha}_t + 1 -\alpha_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \log p(\boldsymbol{x}_t) \\&amp;= \frac{1 -\bar{\alpha}_t}{(1-\bar{\alpha}_t)\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \log p(\boldsymbol{x}_t) \\&amp;= \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \log p(\boldsymbol{x}_t)\end{align}\]</span></p><p>因此，这个时候我们可以设近似的后验分布均值为 <spanclass="math display">\[\begin{equation}\boldsymbol{\mu}_{\theta}(\boldsymbol{x}_t, t) =\frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{\alpha_t}}\boldsymbol{s}_{\theta}(\boldsymbol{x}_t,t)\end{equation}\]</span></p><p>因此这个时候问题的优化目标就会转变成 <span class="math display">\[\begin{align}&amp; \underset{\theta}{\arg \min}D_{\text{KL}}(q(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t, \boldsymbol{x}_0)\parallel p_{\theta}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)) \\&amp;= \underset{\theta}{\arg \min}D_{\text{KL}}(\mathcal{N}(\boldsymbol{x}_{t-1}; \boldsymbol{\mu}_q,\boldsymbol{\Sigma}_q(t)) \parallel \mathcal{N}(\boldsymbol{x}_{t-1};\boldsymbol{\mu}_{\theta}, \boldsymbol{\Sigma}_q(t))) \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\| \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t +\frac{1-\alpha_t}{\sqrt{\alpha_t}}\boldsymbol{s}_{\theta}(\boldsymbol{x}_t,t) - \frac{1}{\sqrt{\alpha_t}}\boldsymbol{x}_t -\frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \log p(\boldsymbol{x}_t)\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\|\frac{1-\alpha_t}{\sqrt{\alpha_t}}\boldsymbol{s}_{\theta}(\boldsymbol{x}_t,t) - \frac{1-\alpha_t}{\sqrt{\alpha_t}}\nabla \log p(\boldsymbol{x}_t)\right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)} \left[\left\| \frac{1-\alpha_t}{\sqrt{\alpha_t}}(\boldsymbol{s}_{\theta}(\boldsymbol{x}_t, t) - \nabla \logp(\boldsymbol{x}_t)) \right\|_2^2 \right] \\&amp;= \underset{\theta}{\arg \min} \frac{1}{2\sigma_q^2(t)}\frac{(1-\alpha_t)^2}{\alpha_t} \left[\|\boldsymbol{s}_{\theta}(\boldsymbol{x}_t, t) - \nabla \logp(\boldsymbol{x}_t)\|_2^2 \right]\end{align}\]</span></p><p>也就是神经网络所要学习的参数 <spanclass="math inline">\(\boldsymbol{s}_{\theta}(\boldsymbol{x}_t,t)\)</span> 与实际的分数函数 <span class="math inline">\(\logp(\boldsymbol{x}_t)\)</span> 的均方误差最小。</p><h4id="使用分数函数与噪声预测之间的联系">使用分数函数与噪声预测之间的联系</h4><p>在下面的式子中，左边是用 Tweedie 公式表示的 <spanclass="math inline">\(\boldsymbol{x}_0\)</span>，右边是用重参数化技巧表示的<spanclass="math inline">\(\boldsymbol{x}_0\)</span>。通过让两者相等，我们找到了连接两者的桥梁。之后消去分母<span class="math inline">\(\sqrt{\bar{\alpha}_t}\)</span> 和分子中的<span class="math inline">\(\boldsymbol{x}_t\)</span>，得到中间关系。<span class="math display">\[\begin{align}\boldsymbol{x}_0 &amp;= \frac{\boldsymbol{x}_t + (1 -\bar{\alpha}_t)\nabla \log p(\boldsymbol{x}_t)}{\sqrt{\bar{\alpha}_t}} =\frac{\boldsymbol{x}_t - \sqrt{1 -\bar{\alpha}_t}\boldsymbol{\epsilon}_0}{\sqrt{\bar{\alpha}_t}} \\\therefore (1 - \bar{\alpha}_t)\nabla \log p(\boldsymbol{x}_t) &amp;=-\sqrt{1 - \bar{\alpha}_t}\boldsymbol{\epsilon}_0 \\\nabla \log p(\boldsymbol{x}_t) &amp;= - \frac{1}{\sqrt{1 -\bar{\alpha}_t}}\boldsymbol{\epsilon}_0\end{align}\]</span></p><p>最后，不难发现，我们<strong>学习分数函数，实际上就是在学习负的噪声</strong>。直觉来讲，噪声是使得我们的图像变得越来越混乱，最终接近于标准高斯分布（指向数据密度低的地方）。而分数函数则是通过梯度引导，使得指向数据密度高的地方。因此，两者的方向恰好相反，预测噪声<span class="math inline">\(\boldsymbol{\epsilon}_\theta\)</span>等价于预测分数 <spanclass="math inline">\(\boldsymbol{s}_\theta\)</span>，预测噪声就是在预测梯度的反方向。</p><div class="note success flat"><p>🌞<strong>进一步加深对于 <span class="math inline">\(\logp(\boldsymbol{x}_t)\)</span> 的理解</strong></p><p><span class="math inline">\(\log p(\boldsymbol{x}_t)\)</span>可以看作是上帝给这张图片 <spanclass="math inline">\(\boldsymbol{x}_t\)</span> 打的一个“真实性分数”。</p><p><strong><spanclass="math inline">\(p(\boldsymbol{x}_t)\)</span>（概率密度）表示在<span class="math inline">\(t\)</span> 时刻，出现这张图片 <spanclass="math inline">\(\boldsymbol{x}_t\)</span>的概率有多大。</strong>而使用 <span class="math inline">\(\logp(\boldsymbol{x}_t)\)</span>（对数概率）是因为概率通常是极小的数（比如<span class="math inline">\(10^{-100}\)</span>），取对数后变成负数（比如<spanclass="math inline">\(-230\)</span>），数值上更容易处理，且变成了“加法”关系。</p><hr /><p>举个例子🌰：</p><p>假设 <span class="math inline">\(t=0\)</span>（无噪声阶段）：</p><p>如果 <span class="math inline">\(\boldsymbol{x}_0\)</span>是<strong>一张清晰的猫的照片</strong>：它在真实数据分布中很常见，所以<span class="math inline">\(p(\boldsymbol{x}_0)\)</span> 很高，<spanclass="math inline">\(\log p(\boldsymbol{x}_0)\)</span>是一个较大的值（比如 -100）。</p><p>如果 <span class="math inline">\(\boldsymbol{x}_0\)</span>是<strong>一张完全随机的乱码图</strong>：它在真实世界几乎不可能出现，所以<span class="math inline">\(p(\boldsymbol{x}_0)\)</span> 极低，<spanclass="math inline">\(\log p(\boldsymbol{x}_0)\)</span>是一个极小的值（比如 -100000）。</p><p>因此，<strong><span class="math inline">\(\logp(\boldsymbol{x}_t)\)</span> 越大，说明这张图在当前时刻 <spanclass="math inline">\(t\)</span> 看起来越“正常”、越“合理”。</strong></p></div><h3 id="学习扩散模型噪声参数-alpha_t">学习扩散模型噪声参数 <spanclass="math inline">\(\alpha_t\)</span></h3><p>在前面的学习中，我们一直假设了噪声参数 <spanclass="math inline">\(\alpha_t\)</span>是预先设定好的，因此可以在模型初始化的时候预先计算并缓存好所有的 <spanclass="math inline">\(\bar{\alpha_t}\)</span>等数据，需要的时候直接拿过来用即可。其实，<spanclass="math inline">\(\alpha_t\)</span>参数也是可以进行学习的，这一章将对其进行重点讨论。</p><h4 id="alpha_t-的第一种学习方式"><spanclass="math inline">\(\alpha_t\)</span> 的第一种学习方式</h4><p>第一种方法是我们可以直接构造一个神经网络来学习 <spanclass="math inline">\(\alpha_t =\hat{\alpha}_\eta(t)\)</span>。这样一来每给定一个具体的时间步 <spanclass="math inline">\(t\)</span>，我们就可以调用模型来输出一个 <spanclass="math inline">\(\hat{\alpha}_\eta(t)\)</span>。但是这种方法的效率并不高，因为我们前面很多地方需要用到<span class="math inline">\(\bar{\alpha}_t\)</span>这种连乘形式，这样一来需要调用模型多次。当然我们也可以对连乘项预计算并缓存，但是由于<span class="math inline">\(\alpha_t\)</span>此时是学习参数，会动态更新。而一旦更新后，原先的缓存值便已失效，我们不得不重新计算缓存，总体来说效率依旧不高。</p><h4 id="alpha_t-的第二种学习方式"><spanclass="math inline">\(\alpha_t\)</span> 的第二种学习方式</h4><p>第二种方法则是从公式 <spanclass="math inline">\(\ref{eq:KL_x0}\)</span> 入手，将方差 <spanclass="math inline">\(\sigma_q^2(t)\)</span>代入后，对其进行进一步的变换，最后裂项得到对称的形式： <spanclass="math display">\[\begin{align}\frac{1}{2\sigma_q^2(t)}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)^2}{(1-\bar{\alpha}_t)^2} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right]&amp;= \frac{1}{2\frac{(1-\alpha_t)(1-\bar{\alpha}_{t-1})}{1-\bar{\alpha}_t}}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)^2}{(1-\bar{\alpha}_t)^2} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2}\frac{1-\bar{\alpha}_t}{(1-\alpha_t)(1-\bar{\alpha}_{t-1})}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)^2}{(1-\bar{\alpha}_t)^2} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)}\left[ \|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2} \frac{\bar{\alpha}_{t-1} -\bar{\alpha}_t}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2} \frac{\bar{\alpha}_{t-1} -\bar{\alpha}_{t-1}\bar{\alpha}_t + \bar{\alpha}_{t-1}\bar{\alpha}_t -\bar{\alpha}_t}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2} \frac{\bar{\alpha}_{t-1}(1-\bar{\alpha}_t) -\bar{\alpha}_t(1-\bar{\alpha}_{t-1})}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)}\left[ \|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2} \left(\frac{\bar{\alpha}_{t-1}(1-\bar{\alpha}_t)}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)}-\frac{\bar{\alpha}_t(1-\bar{\alpha}_{t-1})}{(1-\bar{\alpha}_{t-1})(1-\bar{\alpha}_t)}\right) \left[ \|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \\&amp;= \frac{1}{2} \left(\frac{\bar{\alpha}_{t-1}}{1-\bar{\alpha}_{t-1}} -\frac{\bar{\alpha}_t}{1-\bar{\alpha}_t} \right) \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] \label{eq:KL_alpha}\end{align}\]</span></p><div class="note warning flat"><p>🎈对于高斯分布 <span class="math inline">\(X \sim \mathcal{N}(x; \mu,\sigma^2)\)</span>，信噪比的定义为： <span class="math display">\[\text{SNR} = \frac{\mu^2}{\sigma^2}\]</span></p></div><p>回忆我们 <span class="math inline">\(q(\boldsymbol{x}_t |\boldsymbol{x}_0) = \mathcal{N}(\boldsymbol{x}_t; \sqrt{\bar{\alpha_t}},1 - \bar{\alpha_t}\mathbf{I})\)</span>，于是由 SNR 的定义，可以有：<span class="math display">\[\begin{equation}\text{SNR} = \frac{\bar{\alpha_t}}{1 - \bar{\alpha_t}}\label{eq:snr_def}\end{equation}\]</span></p><p>将 <span class="math inline">\(\ref{eq:snr_def}\)</span> 代入到 <spanclass="math inline">\(\ref{eq:KL_alpha}\)</span>，我们有 <spanclass="math display">\[\frac{1}{2\sigma_q^2(t)}\frac{\bar{\alpha}_{t-1}(1-\alpha_t)^2}{(1-\bar{\alpha}_t)^2} \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right] = \frac{1}{2} \left( \text{SNR}(t-1) -\text{SNR}(t) \right) \left[\|\hat{\boldsymbol{x}}_{\theta}(\boldsymbol{x}_t, t) -\boldsymbol{x}_0\|_2^2 \right]\]</span></p><p>注意我们的 <span class="math inline">\(\alpha_t &lt; 1\)</span>恒成立，因此在式 <span class="math inline">\(\ref{eq:snr_def}\)</span>中，随着时间步 <span class="math inline">\(t\)</span> 的增大，分子 <spanclass="math inline">\(\bar{\alpha_t}\)</span> 会越来越小，而分母 <spanclass="math inline">\(1 - \bar{\alpha_t}\)</span>则会越来越大，所以<strong>信噪比 SNR 是随着 <spanclass="math inline">\(t\)</span>的增大而单调递增的。</strong>直观理解，这一性质是显然的，因为随着时间步<span class="math inline">\(t\)</span>的增大，我们的加噪就一个让信噪比越来越大的过程。因此，我们可以利用神经网络设计一个单调递增的函数<span class="math inline">\(\omega_\eta(t)\)</span>，然后定义 SNR 如式<span class="math inline">\(\ref{eq:snr_dec}\)</span> 所示。 <spanclass="math display">\[\begin{equation}\text{SNR}(t) = \text{exp}(-\omega_\eta(t)) \label{eq:snr_dec}\end{equation}\]</span></p><div class="note danger flat"><p><strong>❓怎么才能够保证设计的神经网络是单调递增的呢？</strong></p></div><p><span class="math display">\[\begin{align}&amp;\frac{\bar{\alpha}_t}{1 - \bar{\alpha}_t} =\exp(-\omega_{\boldsymbol{\eta}}(t)) \\&amp;\therefore \bar{\alpha}_t =\text{sigmoid}(-\omega_{\boldsymbol{\eta}}(t)) \\&amp;\therefore 1 - \bar{\alpha}_t =\text{sigmoid}(\omega_{\boldsymbol{\eta}}(t))\end{align}\]</span></p><div class="note info flat"><p><span class="math inline">\(\text{sigmoid}\)</span>函数是一个单调递增的函数，其表达式为 <span class="math display">\[\text{sigmoid}(x) = \frac{1}{1 + e^{-x}}\]</span></p></div><p>这就是第二种方法！在这一思路下，我们对原先的公式进行进一步处理，发现最终的优化目标其实只与<span class="math inline">\(\bar{\alpha_t}\)</span>这种连乘形式的有关。所以我们直接使用一个神经网络来预测 <spanclass="math inline">\(\bar{\alpha_t}\)</span>即可。同时，我们还通过设计的神经网络，保证了其参数的性质，例如函数的单调性。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diffusion Ch01</title>
      <link href="/2026/02/09/notes/diffusion/diffusion-Ch01/"/>
      <url>/2026/02/09/notes/diffusion/diffusion-Ch01/</url>
      
        <content type="html"><![CDATA[<h2 id="生成模型的定义">生成模型的定义</h2><p>生成模型是从给定的一堆数据样本中，学习数据的真正分布（由观测样本学习到真实分布），即<span class="math inline">\(x \rightarrow p(x)\)</span>。</p><p>作用：</p><ul><li>任意生成一个新的样本</li><li>评估观测或者采样数据的似然度（likelihood）</li></ul><p>现有的生成模型：</p><ol type="1"><li>GAN：以对抗的方式从复杂的分布中采样</li><li>基于似然的生成模型，比如自回归、归一化流、VAE 变分自编码器</li><li>基于能量函数建模：把分布学习变为学习能量函数</li><li>基于分数的生成模型：不学习能量函数，而是能量函数的分数来评判神经网络</li></ol><p>我们需要引入“潜变量”，一般记为 <spanclass="math inline">\(z\)</span>。观测变量也就是数据样本 <spanclass="math inline">\(x\)</span>，一般只是潜变量的一部分（某一维度）的投射。对于隐变量而言，我们一般应该寻找低维的，而不是高维的。原因有二：</p><ul><li>没有更强的先验知识，学习高维的隐变量是不可能的</li><li>低维隐变量的表示是一种压缩形式，语义上可能会更有意义</li></ul><h2 id="证据下界evidence-lower-bound">证据下界（Evidence LowerBound）</h2><p>我们可以通过联合密度 <span class="math inline">\(p(x, z)\)</span>对观测样本和隐变量进行建模。而由联合密度得到似然函数 <spanclass="math inline">\(p(x)\)</span> 有两种方式：</p><ol type="1"><li>通过边缘概率公式：<span class="math inline">\(p(x) = \int p(x, z) \,dz\)</span></li><li>通过条件概率（概率的链式法则）：<span class="math inline">\(p(x) =\frac{p(x, z)}{p(z|x)}\)</span></li></ol><p>所谓的证据（Evidence）的叫法，实际上等价于对数似然。也就是 <spanclass="math inline">\(\log p(x)\)</span>。对于我们的优化来说，目标就是<span class="math inline">\(\max \logp(x)\)</span>。而通过上面的公式，我们有两种方式来对 <spanclass="math inline">\(p(x)\)</span> 进行表示。</p><p>但是，边缘概率需要对<strong>所有的</strong>隐变量 <spanclass="math inline">\(z\)</span>进行积分，这是一件很困难的事情。而且，由于真实的后验分布概率 <spanclass="math inline">\(p(z|x)\)</span>我们也是不知道的，所以应用条件概率也是一件很困难的事情，所以我们需要用一些近似的方法来估计这个后验分布概率。</p><figure><img src="/img/diffusion/latent_var.png" alt="latent_var" /><figcaption aria-hidden="true">latent_var</figcaption></figure><p>我们的优化目标从 <span class="math inline">\(\max \log p(x)\)</span>转变为 <span class="math inline">\(\max \text{ELBO}\)</span>，其中 <spanclass="math inline">\(\text{ELBO} =\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\right]\)</span>，这里需要解释说明两个问题：</p><ol type="1"><li><span class="math inline">\(\text{ELBO}\)</span> 确实是 <spanclass="math inline">\(\log p(x)\)</span> 的一个下界，即证 <spanclass="math inline">\(\log p(x) \ge\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\right]\)</span>；</li><li>这么多的下界中，为什么选择了 <spanclass="math inline">\(\text{ELBO}\)</span> 这个下界。</li></ol><p>首先，我们来证明 <span class="math inline">\(\log p(x) \ge\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\right]\)</span>：</p><p><span class="math display">\[\begin{align}\log p(\boldsymbol{x}) &amp;= \log \int p(\boldsymbol{x},\boldsymbol{z}) d\boldsymbol{z} &amp;&amp; \text{(Apply Equation 1)}\tag{5} \\&amp;= \log \int \frac{p(\boldsymbol{x}, \boldsymbol{z})q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}d\boldsymbol{z} &amp;&amp; \text{(Multiply by } 1 =\frac{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\text{)} \tag{6} \\&amp;= \log \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right]&amp;&amp; \text{(Definition of Expectation)} \tag{7} \\&amp;\ge \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[\log \frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right]&amp;&amp; \text{(Apply Jensen&#39;s Inequality)} \tag{8}\end{align}\]</span></p><div class="note info flat"><p>注意最后一步我们用到了 Jensen 不等式，由于 <spanclass="math inline">\(f(\cdot) = \log(\cdot)\)</span>是一个凹函数（不同教材和学科方向对与凹凸函数的定义并不一致），所以有<span class="math inline">\(f(\mathbb{E}(\cdot)) \ge\mathbb{E}(f(\cdot))\)</span> 成立。</p></div><p>接下来说明为什么要选择 <spanclass="math inline">\(\text{ELBO}\)</span> 这个下界：</p><p><span class="math display">\[\begin{align}\log p(\boldsymbol{x}) &amp;= \log p(\boldsymbol{x}) \intq_{\phi}(\boldsymbol{z}|\boldsymbol{x}) d\boldsymbol{z} &amp;&amp;\text{(Multiply by } 1 = \int q_{\phi}(\boldsymbol{z}|\boldsymbol{x})d\boldsymbol{z} \text{)} \tag{9} \\&amp;= \int q_{\phi}(\boldsymbol{z}|\boldsymbol{x}) (\logp(\boldsymbol{x})) d\boldsymbol{z} &amp;&amp; \text{(Bring evidence intointegral)} \tag{10} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} [\logp(\boldsymbol{x})] &amp;&amp; \text{(Definition of Expectation)}\tag{11} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{p(\boldsymbol{z}|\boldsymbol{x})} \right] &amp;&amp;\text{(Apply Equation 2)} \tag{12} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x}, \boldsymbol{z})q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}{p(\boldsymbol{z}|\boldsymbol{x})q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right] &amp;&amp;\text{(Multiply by } 1 =\frac{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\text{)} \tag{13} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right] +\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}{p(\boldsymbol{z}|\boldsymbol{x})}\right] &amp;&amp; \text{(Split the Expectation)} \tag{14} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right] +D_{\text{KL}}(q_{\phi}(\boldsymbol{z}|\boldsymbol{x}) \parallelp(\boldsymbol{z}|\boldsymbol{x})) &amp;&amp; \text{(Definition of KLDivergence)} \tag{15} \\&amp;\ge \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[\log \frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right]&amp;&amp; \text{(KL Divergence always } \ge 0 \text{)} \tag{16}\end{align}\]</span></p><div class="note warning flat"><p><span class="math inline">\(\text{KL}\)</span>散度：度量分布的接近程度，公式为：</p><p><span class="math inline">\(D_\text{KL}(p || q) = \int p(x) \log\frac{p(x)}{q(x)} \text{d}x = \mathbb{E}_{p(x)} \left[ \log\frac{p(x)}{q(x)}\right]\)</span></p><ul><li>非负性：<span class="math inline">\(p\)</span> 与 <spanclass="math inline">\(q\)</span> 越接近，则 <spanclass="math inline">\(\text{KL}\)</span> 散度越小，越趋近于 0。但 <spanclass="math inline">\(\text{KL}\)</span> 散度非负，<spanclass="math inline">\(D_\text{KL} \ge 0\)</span>。</li><li>非对称性：<span class="math inline">\(D_\text{KL}(p || q) \neqD_\text{KL}(q || p)\)</span></li></ul></div><p>由上述的公式，我们可以得到 <span class="math display">\[\log p(x) = \text{ELBO} + \text{KL 散度}\]</span></p><p>因为 <span class="math inline">\(p(x)\)</span>是定值常数（数据就在那里），最大化 <spanclass="math inline">\(\text{ELBO}\)</span>（变分下界）就相当于是最小化<span class="math inline">\(\text{KL}\)</span>散度！<strong>因为我们不仅想要最大化 <span class="math inline">\(\logp(x)\)</span>，我们还想神经网络学习的近似后验分布与真实的后验分布越接近越好（<spanclass="math inline">\(\text{KL}\)</span> 散度接近于 0），所以我们选择了<span class="math inline">\(\text{ELBO}\)</span> 这个下界。</strong></p><h2 id="vaevariational-autoencoder">VAE（Variational Autoencoder）</h2><p>接下来我们介绍什么叫做变分自编码器。这个名字听起来会特别令人困惑，什么叫做“变分自编码器”，“变分”是什么意思，“自编码器”又是什么意思呢？</p><h3 id="自编码器-autoencoder">自编码器 (Autoencoder)</h3><p>想象你是一个画家，你想把一张复杂的画（输入 <spanclass="math inline">\(x\)</span>）传给你的朋友，但你只能说很简短的一句话。</p><ul><li>Encoder(编码器)：你盯着画，提取出最核心的特征（比如“一只在草地上的白猫”），这句简短的话就是Latent Code (隐变量 <spanclass="math inline">\(z\)</span>)。这一步是压缩信息。</li><li>Decoder (解码器)：你的朋友听到这句话，凭空画出一张画。</li><li>目标：你希望朋友画出来的画，和你原本看到的那张画越像越好。在这个过程中：输入是<span class="math inline">\(x\)</span>。输出是重建后的 <spanclass="math inline">\(\hat{x}\)</span>。中间那个“瓶颈”就是 <spanclass="math inline">\(z\)</span>。</li></ul><p>普通的自编码器（Autoencoder）把图片映射成一个固定的点（比如坐标 [2.5,3.1]）</p><h3 id="变分-variational">变分 (Variational)</h3><p>“变分”这个词来自<strong>变分推断 (VariationalInference)</strong>。为什么要“变分”？普通的自编码器有一个大问题：它生成的<span class="math inline">\(z\)</span>是离散的点。如果你想生成一张新图片，你不知道该去坐标系的哪里取点。如果你取在两个点中间，可能解码出来就是乱码。</p><p><strong>VAE的做法：</strong>它不把图片映射成一个“点”，而是映射成一个<strong>“概率分布”(ProbabilityDistribution)</strong>（通常是高斯分布，即正态分布）。Encoder不再说：“这张图的坐标是 [2, 3]”。Encoder 改口说：“这张图大概在 [2, 3]附近，方差是 0.5 的一个圈圈里”。这就叫“Variational(变分)”：我们不再寻找一个确定的值，而是去寻找一个最佳的分布函数 <spanclass="math inline">\(q_\phi(z|x)\)</span>来近似那个未知的真实分布。</p><blockquote><p>一句话总结：普通自编码器是把数据压缩成代码。变分自编码器是把数据压缩成概率分布。</p></blockquote><p>下面将结合公式进行进一步的说明。</p><p><span class="math display">\[\begin{align}\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \right] &amp;=\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p_{\theta}(\boldsymbol{x}|\boldsymbol{z})p(\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\right] &amp;&amp; \text{(Chain Rule of Probability)} \\&amp;= \mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} [\logp_{\theta}(\boldsymbol{x}|\boldsymbol{z})] +\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{z})}{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}\right] &amp;&amp; \text{(Split the Expectation)} \\&amp;= \underbrace{\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})}[\log p_{\theta}(\boldsymbol{x}|\boldsymbol{z})]}_{\text{reconstructionterm}} -\underbrace{D_{\text{KL}}(q_{\phi}(\boldsymbol{z}|\boldsymbol{x})\parallel p(\boldsymbol{z}))}_{\text{prior matching term}} &amp;&amp;\text{(Definition of KL Divergence)}\end{align}\]</span></p><p>VAE 的训练目标就是让这个式子最大化，它由两部分对抗组成：</p><ul><li><p>第一部分：<strong>Reconstruction Term(重建项)对应概念：Autoencoder (自编码器)</strong></p><p>含义：“画得像不像？”我们从分布里采样一个 <spanclass="math inline">\(z\)</span>，通过 Decoder 生成图像，<mark class="hl-label orange">希望它和原图越像越好</mark>。<div class="note danger flat"><p>测量编码器 <span class="math inline">\(p_\theta(x | z)\)</span>重建（给定隐变量 <span class="math inline">\(z\)</span> 生成原数据 <spanclass="math inline">\(x\)</span> 的过程）可能性</p></div></p></li><li><p>第二部分：<strong>Prior Matching Term (先验匹配项 / <spanclass="math inline">\(\text{KL}\)</span> 散度)对应概念：Variational(变分)</strong></p><p>含义：“分布规不规范？”这里用到了 <spanclass="math inline">\(\text{KL}\)</span>散度！它强迫神经网络预测出来的分布 <spanclass="math inline">\(q_\phi(z|x)\)</span> 去接近一个标准的正态分布<spanclass="math inline">\(p(z)\)</span>（通常是均值为0，方差为1的标准高斯分布）。为什么要做这一步？为了让生成的“潜空间” (Latent Space)连续且平滑。这样你以后在这个空间里随便取一个点，都能生成出像模像样的图片，而不是乱码。<div class="note danger flat"><p>度量所学习到的 <span class="math inline">\(q_\phi(z | x)\)</span>能够保留多少原先的先验知识 <span class="math inline">\(p(z)\)</span>的程度</p></div></p></li></ul><p>我们需要使得第一部分尽可能大，第二部分尽可能小。<strong>为了简便起见，我们一般都会假设<span class="math inline">\(p_\theta(x | z)\)</span>、<spanclass="math inline">\(q_\phi(z | x)\)</span> 和 <spanclass="math inline">\(p(z)\)</span>都是服从高斯分布的。</strong>后验分布 <spanclass="math inline">\(q_{\phi}(\boldsymbol{z}|\boldsymbol{x})\)</span>和先验分布 <span class="math inline">\(p(\boldsymbol{z})\)</span>的公式见下方：</p><p><span class="math display">\[\begin{align}q_{\phi}(\boldsymbol{z}|\boldsymbol{x}) &amp;=\mathcal{N}(\boldsymbol{z}; \boldsymbol{\mu}_{\phi}(\boldsymbol{x}),\boldsymbol{\sigma}_{\phi}^2(\boldsymbol{x})\mathbf{I}) \\p(\boldsymbol{z}) &amp;= \mathcal{N}(\boldsymbol{z}; \mathbf{0},\mathbf{I})\end{align}\]</span></p><blockquote><p>为了更加简便，我们甚至不会考虑协方差，只是考虑每一个高斯分布单独的方差。</p></blockquote><p><span class="math display">\[\operatorname*{arg\,max}_{\phi, \theta}\mathbb{E}_{q_{\phi}(\boldsymbol{z}|\boldsymbol{x})} \left[ \logp_{\theta}(\boldsymbol{x}|\boldsymbol{z}) \right] -D_{\text{KL}}(q_{\phi}(\boldsymbol{z}|\boldsymbol{x}) \parallelp(\boldsymbol{z})) \approx \operatorname*{arg\,max}_{\phi, \theta}\sum_{l=1}^{L} \log p_{\theta}(\boldsymbol{x}|\boldsymbol{z}^{(l)}) -D_{\text{KL}}(q_{\phi}(\boldsymbol{z}|\boldsymbol{x}) \parallelp(\boldsymbol{z}))\]</span></p><p>在上面这个式子中，我们是可以直接计算出 <spanclass="math inline">\(D_{\text{KL}}(q_{\phi}(\boldsymbol{z}|\boldsymbol{x})\parallel p(\boldsymbol{z}))\)</span> 这一项的，因为 <spanclass="math inline">\(\parallel\)</span>两边的都是高斯分布，因此可以直接代入相关的公式进行计算。</p><p>对于第一项求期望，我们可以有两种方法：蒙特卡洛和参数重整化方法</p><h3 id="蒙特卡洛方法">蒙特卡洛方法</h3><p>蒙特卡洛方法就是不断地采样，然后取平均值来近似估计真实值。具体来说，对于<spanclass="math inline">\(\mathbb{E}_{p(\boldsymbol{x})}(g(\boldsymbol{x}))\)</span>，第一步我们需要以<span class="math inline">\(p(\boldsymbol{x})\)</span>的概率分布来采样多个（记为 <span class="math inline">\(n\)</span>）<span class="math inline">\(\boldsymbol{x}\)</span>，即 <spanclass="math inline">\(\{\boldsymbol{x_i}\}^n_{i=1}\)</span>。然后，对于这<span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(\boldsymbol{x}_i\)</span>，我们取其平均值 <spanclass="math inline">\(\frac{1}{n}\sum^n_{i=1}g(\boldsymbol{x}_i)\)</span>，作为对于期望的估计值。</p><p>在前面的式子中，我们就是采样了 <span class="math inline">\(L\)</span>个样本，之后求和取平均。但是因为这里我们优化的目标和 <spanclass="math inline">\(L\)</span> 无关，因此是否除以 <spanclass="math inline">\(L\)</span>关系并不大，为了简便起见，我们并没有除以 <spanclass="math inline">\(L\)</span>。</p><h4 id="蒙特卡洛随机采样的问题">蒙特卡洛随机采样的问题</h4><mark class="hl-label red">蒙特卡洛有一个致命的问题，那就是随机采样是不可微分的，进而会导致梯度传播、计算失效。</mark><p>我们可以从直观理解和数学原理两个角度来看。</p><ol type="1"><li><p><strong>直观理解：</strong>断裂的计算图在神经网络训练中，为了更新参数（比如<span class="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span>），我们需要计算梯度（Gradient）。梯度的本质是问这样一个问题：</p><blockquote><p>“如果我把输入（<span class="math inline">\(\mu\)</span> 或 <spanclass="math inline">\(\sigma\)</span>）稍微增加一点点，输出（Loss）会变化多少？”</p></blockquote><p>正常情况（可微分）假设公式是 <span class="math inline">\(z = \mu +\sigma\)</span>。如果你把 <span class="math inline">\(\mu\)</span> 增加0.001，<span class="math inline">\(z\)</span> 也会增加0.001。这种关系是确定性的、连续的。计算机可以算出导数 <spanclass="math inline">\(\frac{\partial z}{\partial \mu} =1\)</span>，梯度畅通无阻。</p><p>随机采样的情况（不可微分）现在公式变成了 <spanclass="math inline">\(z \sim \mathcal{N}(\mu,\sigma^2)\)</span>（从分布中采样）。</p><ul><li><strong>前向传播（Forward）：</strong>你告诉电脑 <spanclass="math inline">\(\mu=0,\sigma=1\)</span>，电脑扔了个骰子，给你一个数字 <spanclass="math inline">\(z = 0.5\)</span>。</li><li><strong>反向传播（Backward）：</strong>现在你想算梯度。你问电脑：“如果我把<span class="math inline">\(\mu\)</span> 从 0 变成 0.001，刚才那个 <spanclass="math inline">\(z=0.5\)</span>会变成多少？”电脑的回答：“我不知道。因为 <spanclass="math inline">\(z\)</span> 是我随机抽出来的。如果你改了 <spanclass="math inline">\(\mu\)</span>，那就是另一次抽签了，出来的可能是<span class="math inline">\(0.6\)</span>，也可能是 <spanclass="math inline">\(-0.2\)</span>。这两个数字之间没有平滑的过渡关系。”</li></ul><p>因此，采样的结果是一个随机的数值，而不是一个包含参数 <spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span> 的函数。在计算图（ComputationGraph）中，采样操作是一个切断点。</p></li><li><p><strong>数学解释：</strong>链式法则的失效即使我们强行去算，也会发现数学上走不通。假设我们的损失函数是<span class="math inline">\(L\)</span>，我们需要求 <spanclass="math inline">\(\frac{\partial L}{\partial\mu}\)</span>。根据链式法则：</p><p><span class="math display">\[\frac{\partial L}{\partial \mu} = \frac{\partial L}{\partial z} \cdot\frac{\partial z}{\partial \mu}\]</span> <span class="math inline">\(\frac{\partial L}{\partialz}\)</span>：这一步没问题，神经网络后面部分都是可导的。</p><p><span class="math inline">\(\frac{\partial z}{\partial\mu}\)</span>：这一步是关键。<span class="math inline">\(z\)</span> 对<span class="math inline">\(\mu\)</span> 的导数是多少？当你执行 <spanclass="math inline">\(z = \text{sample}(\mu, \sigma)\)</span>后，在计算机眼里，<span class="math inline">\(z\)</span>就变成了一个常数（比如 0.53）。常数对任何变量的导数都是 0。 <spanclass="math display">\[\frac{\partial z}{\partial \mu} = 0\]</span>如果这一项是 0，那么整个梯度 <spanclass="math inline">\(\frac{\partial L}{\partial \mu}\)</span>也就变成了 0。这意味着你的神经网络根本学不到东西，因为它觉得 <spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span> 怎么变都不会影响 <spanclass="math inline">\(z\)</span>（因为采样操作把这种联系掩盖了）。</p></li></ol><h3 id="参数重整化方法">参数重整化方法</h3><p>上述问题的解决方案就是<strong>重参数化技巧 (ReparameterizationTrick)</strong>。</p><p>为了解决这个问题，VAE发明了天才般的重参数化技巧。它的核心思想是：把“随机性”从网络的主干道上剥离出去，把它变成一个外挂的输入。我们不再直接采<span class="math inline">\(z \sim \mathcal{N}(\mu,\sigma^2)\)</span>，而是：先从一个标准正态分布（没有参数，<spanclass="math inline">\(\mu=0, \sigma=1\)</span>）中采一个噪声 <spanclass="math inline">\(\epsilon\)</span>： <span class="math display">\[\epsilon \sim \mathcal{N}(0, 1)\]</span> (注意：这一步是随机的，但它不依赖于 <spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span>，所以不需要对它求导)然后通过一个确定性的公式计算<span class="math inline">\(z\)</span>： <span class="math display">\[z = \mu + \sigma \cdot \epsilon\]</span> 现在看看有什么不同：当我们再问：“如果 <spanclass="math inline">\(\mu\)</span> 增加一点点，<spanclass="math inline">\(z\)</span> 会怎么变？” <spanclass="math display">\[\frac{\partial z}{\partial \mu} = \frac{\partial(\mu + \sigma \cdot \epsilon)}{\partial \mu} = 1\]</span> <span class="math display">\[\frac{\partial z}{\partial \sigma} = \frac{\partial (\mu + \sigma \cdot\epsilon)}{\partial \sigma} = \epsilon\]</span> 通了！<span class="math inline">\(\epsilon\)</span>在这里被当作一个常数（就像输入数据一样）。<spanclass="math inline">\(z\)</span> 变成了 <spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span> 的平滑函数。梯度可以通过 <spanclass="math inline">\(\times\)</span> 和 <spanclass="math inline">\(+\)</span> 运算流畅地传回到 <spanclass="math inline">\(\mu\)</span> 和 <spanclass="math inline">\(\sigma\)</span>。</p><div class="note success flat"><p>将随机变量重新表示为噪声变量的确定性函数： <spanclass="math display">\[\boldsymbol{z} = \boldsymbol{\mu}_{\phi}(\boldsymbol{x}) +\boldsymbol{\sigma}_{\phi}(\boldsymbol{x}) \odot \boldsymbol{\epsilon}\quad \text{with} \quad \boldsymbol{\epsilon} \sim\mathcal{N}(\boldsymbol{\epsilon}; \mathbf{0}, \mathbf{I})\]</span></p></div><h2 id="hvaehierarchical-variational-autoencoder">HVAE（HierarchicalVariational Autoencoder）</h2><p>在前面，我们考虑了观测样本 <spanclass="math inline">\(\boldsymbol{x}\)</span> 与单个隐变量 <spanclass="math inline">\(\boldsymbol{z}\)</span>之间的关系。但是，一个隐变量可能还会与其他的隐变量之间有关系，如下图所示：</p><figure><img src="/img/diffusion/HVAE.png" alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><p>为了简便起见，我们只考虑具有马尔可夫性质的 <spanclass="math inline">\(\text{HVAE}\)</span>，称作 <spanclass="math inline">\(\text{MHVAE}\)</span>。也就是对于 <spanclass="math inline">\(\boldsymbol{z}_i\)</span>来说，它只会依赖于它前一个的隐变量（或观测变量）的状态，而不是历史上所有前面的隐变量。</p><h3 id="优化目标">优化目标</h3><p>在 VAE 中，我们的优化目标是最大化 ELBO。VAE中只有两个变量，一个是观测数据 <spanclass="math inline">\(\boldsymbol{x}\)</span>，一个是 <spanclass="math inline">\(\boldsymbol{z}\)</span>，因此可以看做是 2维的。</p><p>但是在 MHVAE中，我们的隐变量个数增多了，因此维度也会上去。其联合概率密度分布（解码decoder 过程）与近似的后验概率分布（编码 encoder过程）的公式见下方：</p><p><span class="math display">\[\begin{align}p(\boldsymbol{x}, \boldsymbol{z}_{1:T}) &amp;=p(\boldsymbol{z}_T)p_{\theta}(\boldsymbol{x}|\boldsymbol{z}_1)\prod_{t=2}^{T} p_{\theta}(\boldsymbol{z}_{t-1}|\boldsymbol{z}_t)\label{eq:mhvae_decoder}\\q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x}) &amp;=q_{\phi}(\boldsymbol{z}_1|\boldsymbol{x}) \prod_{t=2}^{T}q_{\phi}(\boldsymbol{z}_t|\boldsymbol{z}_{t-1}) \label{eq:mhvae_encoder}\end{align}\]</span></p><p>其 ELBO 的公式推导见下方： <span class="math display">\[\begin{align}\log p(\boldsymbol{x}) &amp;= \log \int p(\boldsymbol{x},\boldsymbol{z}_{1:T}) d\boldsymbol{z}_{1:T} &amp;&amp; \text{(ApplyEquation 1)} \\&amp;= \log \int \frac{p(\boldsymbol{x},\boldsymbol{z}_{1:T})q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}d\boldsymbol{z}_{1:T} &amp;&amp; \text{(Multiply by } 1 =\frac{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\text{)} \\&amp;= \log \mathbb{E}_{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\left[ \frac{p(\boldsymbol{x},\boldsymbol{z}_{1:T})}{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\right] &amp;&amp; \text{(Definition of Expectation)} \\&amp;\ge \mathbb{E}_{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\left[ \log \frac{p(\boldsymbol{x},\boldsymbol{z}_{1:T})}{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\right] &amp;&amp; \text{(Apply Jensen&#39;s Inequality)}\end{align}\]</span></p><p>注意，我们可以利用马尔可夫的性质，即当前时刻的状态仅依赖于上一时刻，所以将其进一步化简，也就是代入公式<span class="math inline">\(\ref{eq:mhvae_encoder}\)</span> 和 <spanclass="math inline">\(\ref{eq:mhvae_decoder}\)</span>： <spanclass="math display">\[\begin{equation} \label{eq:vdm}\mathbb{E}_{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})} \left[ \log\frac{p(\boldsymbol{x},\boldsymbol{z}_{1:T})}{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\right] = \mathbb{E}_{q_{\phi}(\boldsymbol{z}_{1:T}|\boldsymbol{x})}\left[ \log\frac{p(\boldsymbol{z}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}|\boldsymbol{z}_1)\prod_{t=2}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{z}_{t-1}|\boldsymbol{z}_t)}{q_{\phi}(\boldsymbol{z}_1|\boldsymbol{x})\prod_{t=2}^{T} q_{\phi}(\boldsymbol{z}_t|\boldsymbol{z}_{t-1})} \right]\end{equation}\]</span></p><p>之后，我们会进一步围绕公式 <spanclass="math inline">\(\ref{eq:vdm}\)</span>展开<strong>变分扩散模型</strong>的研究。</p><h2 id="vdmvariational-diffusion-model">VDM（Variational DiffusionModel）</h2><p>扩散模型可以看做是一种特殊的 MHVAE，但是会有三个关键限制。</p><ul><li><p><strong>隐变量维度等于数据维度</strong></p><p><strong>普通 VAE：</strong>通常会把图片“压缩”。比如一张1000像素的图，压缩成一个 10个数字的向量（隐变量），这叫降维。</p><p><strong>扩散模型：</strong>不压缩。如果你的原图是 <spanclass="math inline">\(256 \times 256\)</span>的，那么中间的每一层噪声图（隐变量）也是 <span class="math inline">\(256\times 256\)</span> 的。图片的大小始终保持不变，只是内容变了。</p></li><li><p><strong>编码器结构是固定的，不需要学习</strong></p><p><strong>普通VAE：</strong>编码器（Encoder）是一个神经网络，需要通过训练来学习如何提取特征。</p><p><strong>扩散模型：</strong>编码器（也就是“前向过程”或“加噪过程”）是写死的数学规则。它不需要神经网络去学，只是机械地向图片里加高斯噪声（LinearGaussian）。</p></li><li><p><strong>最终变为标准高斯分布</strong></p><p><strong>普通VAE：</strong>我们希望隐变量符合高斯分布，但这是一种约束。<strong>扩散模型：</strong>这是一个硬性终点。随着时间 <spanclass="math inline">\(t\)</span> 推移，噪声越加越多，直到最后时刻 <spanclass="math inline">\(T\)</span>，原本的图片彻底变成了一张纯粹的随机噪声图（标准高斯分布，均值为0，方差为1）。这意味着我们清楚地知道“终点”长什么样。</p></li></ul><div class="note success flat"><p><strong>扩散模型 = 马尔可夫层次变分自编码器 (MHVAE) +3个限制条件</strong></p></div><h3 id="限制一的数学建模">限制一的数学建模</h3><p>在第一个限制的基础上，我们可以改写公式 <spanclass="math inline">\(\ref{eq:mhvae_encoder}\)</span>，把其中的 <spanclass="math inline">\(\boldsymbol{z}\)</span> 全部换成 <spanclass="math inline">\(\boldsymbol{x}\)</span>，也就是下面这个式子 <spanclass="math inline">\(\ref{eq:vdm_encoder}\)</span>。 <spanclass="math display">\[\begin{equation} \label{eq:vdm_encoder}q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0) = \prod_{t=1}^{T}q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})\end{equation}\]</span></p><h3 id="限制二的数学建模">限制二的数学建模</h3><p>在第二个限制的基础上，因为前向编码过程是高斯建模，非学习性质的，因此，我们可以给出迭代形式的具体的编码公式，如式<span class="math inline">\(\ref{eq:vdm_encoder_iter}\)</span>所示。注意，这个公式里面只有 <spanclass="math inline">\(\alpha_t\)</span>是未知的，但是，我们可以人为预先设置好每一步的 <spanclass="math inline">\(\alpha_t\)</span>，就像学习率一样。这个时候，<strong>编码过程是不含参数，唯一确定的。</strong></p><p><span class="math display">\[\begin{equation} \label{eq:vdm_encoder_iter}q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}) = \mathcal{N}(\boldsymbol{x}_t;\sqrt{\alpha_t}\boldsymbol{x}_{t-1}, (1-\alpha_t)\mathbf{I})\end{equation}\]</span></p><h3 id="限制三的数学建模">限制三的数学建模</h3><p>在第三个限制的基础上，最终的 <spanclass="math inline">\(\boldsymbol{x}_T\)</span> 服从高斯分布。因此，有式<span class="math inline">\(\ref{eq:vdm_encoder_xT}\)</span> 成立。</p><p><span class="math display">\[\begin{align}p(\boldsymbol{x}_{0:T}) &amp;= p(\boldsymbol{x}_T) \prod_{t=1}^{T}p_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t) \\\text{where,} &amp; \notag \\p(\boldsymbol{x}_T) &amp;= \mathcal{N}(\boldsymbol{x}_T; \mathbf{0},\mathbf{I}) \label{eq:vdm_encoder_xT}\end{align}\]</span></p><h3 id="总体-pipeline">总体 pipeline</h3><ol type="1"><li>Encoder：不设置参数，全部都建模为高斯分布；</li><li>Decoder：只需关注去噪过程，其中 <spanclass="math inline">\(p_\theta(\boldsymbol{x}_{t-1} |\boldsymbol{x}_t)\)</span> 是通过模型训练参数 <spanclass="math inline">\(\theta\)</span> 进行学习的。</li></ol><p>训练好一个 VDM 模型，从高斯噪声 <spanclass="math inline">\(p(\boldsymbol{x}_T)\)</span> 中采样得到纯噪声图片<span class="math inline">\(\boldsymbol{x}_T\)</span>。然后迭代去噪<span class="math inline">\(T\)</span> 步，每一步使用模型训练出的 <spanclass="math inline">\(p_\theta(\boldsymbol{x}_{t-1} |\boldsymbol{x}_t)\)</span> 去噪。</p><figure><img src="/img/diffusion/vdm.png" alt="vdm" /><figcaption aria-hidden="true">vdm</figcaption></figure><h3 id="vdm-优化目标">VDM 优化目标</h3><p>依旧是之前的 <spanclass="math inline">\(\text{ELBO}\)</span>，但是当我们把所有的 <spanclass="math inline">\(\boldsymbol{z}\)</span> 替换成 <spanclass="math inline">\(\boldsymbol{x}\)</span>之后，可以进行进一步的处理了。</p><p><span class="math display">\[\begin{align}\log p(\boldsymbol{x}) &amp;= \log \int p(\boldsymbol{x}_{0:T})d\boldsymbol{x}_{1:T} \\&amp;= \log \int\frac{p(\boldsymbol{x}_{0:T})q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}d\boldsymbol{x}_{1:T} \\&amp;= \log \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[\frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\right] \\&amp;\geq \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[\log\frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)}\right] \quad \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T) \prod_{t=1}^Tp_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{\prod_{t=1}^Tq(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1) \prod_{t=2}^Tp_{\boldsymbol{\theta}}(\boldsymbol{x}_{t-1}|\boldsymbol{x}_t)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})\prod_{t=1}^{T-1} q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)\prod_{t=1}^{T-1}p_{\boldsymbol{\theta}}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})\prod_{t=1}^{T-1} q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})} \right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[\frac{p(\boldsymbol{x}_T)p_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[\log \prod_{t=1}^{T-1}\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})}\right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} [\logp_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)] +\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[\sum_{t=1}^{T-1} \log\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})}\right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} [\logp_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)] +\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \sum_{t=1}^{T-1}\mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} \left[ \log\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})}\right] \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{1:T}|\boldsymbol{x}_0)} [\logp_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)] +\mathbb{E}_{q(\boldsymbol{x}_{T-1}, \boldsymbol{x}_T|\boldsymbol{x}_0)}\left[ \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right] + \sum_{t=1}^{T-1} \mathbb{E}_{q(\boldsymbol{x}_{t-1},\boldsymbol{x}_t, \boldsymbol{x}_{t+1}|\boldsymbol{x}_0)} \left[ \log\frac{p_{\boldsymbol{\theta}}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1})}{q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1})}\right] \\&amp;= \underbrace{\mathbb{E}_{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}[\logp_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)]}_{\text{reconstructionterm}} -\underbrace{\mathbb{E}_{q(\boldsymbol{x}_{T-1}|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1}) \parallelp(\boldsymbol{x}_T))]}_{\text{prior matching term}} \\&amp; - \underbrace{\sum_{t=1}^{T-1} \mathbb{E}_{q(\boldsymbol{x}_{t-1},\boldsymbol{x}_{t+1}|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}) \parallelp_{\theta}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1}))]}_{\text{consistencyterm}}\end{align}\]</span></p><p>上面的推导中关于 prior matching term这一部分比较难以理解，下面具体展开来说明。</p><p>$$ <span class="math display">\[\begin{align}\mathbb{E}_{q(\boldsymbol{x}_{T-1}, \boldsymbol{x}_T|\boldsymbol{x}_0)}\left[ \log\frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1})}\right]&amp;= \int \log \frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T |\boldsymbol{x}_{T-1})} q(\boldsymbol{x}_{T-1}, \boldsymbol{x}_T |\boldsymbol{x}_0) \text{d}\boldsymbol{x}_{T-1:T} \\&amp;= \int \log \frac{p(\boldsymbol{x}_T)}{q(\boldsymbol{x}_T |\boldsymbol{x}_{T-1})} q(\boldsymbol{x}_{T} | \boldsymbol{x}_{T-1},\boldsymbol{x}_0) q(\boldsymbol{x}_{T-1} | \boldsymbol{x}_0)\text{d}\boldsymbol{x}_{T-1:T} \\&amp;= - \int \left[ \log \frac{q(\boldsymbol{x}_T |\boldsymbol{x}_{T-1})}{p(\boldsymbol{x}_T)} q(\boldsymbol{x}_{T} |\boldsymbol{x}_{T-1}) \text{d} (\boldsymbol{x}_T) \right]q(\boldsymbol{x}_{T-1} | \boldsymbol{x}_0) \text{d} \boldsymbol{x}_{T-1}\\&amp;= -\int D_\text{KL}(q(\boldsymbol{x}_T | \boldsymbol{x}_{T-1})\parallel p(\boldsymbol{x}_T)) q(\boldsymbol{x}_{T-1} |\boldsymbol{x}_0) \text{d} \boldsymbol{x}_{T-1} \\&amp;= \mathbb{E}_{q(\boldsymbol{x}_{T-1}|\boldsymbol{x}_0)}D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1}) \parallelp(\boldsymbol{x}_T))\end{align}\]</span> $$</p><p>关键之处在于理解 <span class="math inline">\(\text{KL}\)</span>散度的定义式，以及联合的期望如何进行拆解。我们从开始的 <spanclass="math inline">\(\mathbb{E}_{q(\boldsymbol{x}_{T-1},\boldsymbol{x}_T|\boldsymbol{x}_0)}\)</span> 期望变成了最终的 <spanclass="math inline">\(\mathbb{E}_{q(\boldsymbol{x}_{T-1} |\boldsymbol{x}_0)}\)</span>，成功地把 <spanclass="math inline">\(\boldsymbol{x}_T\)</span> 提取了出来，最终放进了<span class="math inline">\(\text{KL}\)</span> 散度里面。</p><div class="note danger flat"><p>📖采用对数似然是为了数值稳定性，能够在保证成千上万的像素点的概率相乘之后，总的概率不至于太小。因为概率的连乘反映到对数运算中是相加的形式！</p></div><ul><li><spanclass="math inline">\(\mathbb{E}_{q(\boldsymbol{x}_1|\boldsymbol{x}_0)}[\logp_{\boldsymbol{\theta}}(\boldsymbol{x}_0|\boldsymbol{x}_1)]\)</span>被称作重建项，这一项的含义是评估加噪一步后的 <spanclass="math inline">\(\boldsymbol{x}_1\)</span> 与原来的观测数据 <spanclass="math inline">\(\boldsymbol{x}_0\)</span>之间的对数似然。我们需要最大化对数似然，本质就是在给定 <spanclass="math inline">\(\boldsymbol{x}_1\)</span>这个稍微带一点噪声的数据基础上，我们恢复出 <spanclass="math inline">\(\boldsymbol{x}_0\)</span> 的概率分布。</li><li><spanclass="math inline">\(\mathbb{E}_{q(\boldsymbol{x}_{T-1}|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_T|\boldsymbol{x}_{T-1}) \parallelp(\boldsymbol{x}_T))]\)</span>这一项被称作先验匹配项。它的意思是我们最后一步加噪由 <spanclass="math inline">\(\boldsymbol{x}_{T-1}\)</span> 生成的 <spanclass="math inline">\(\boldsymbol{x}_T\)</span> 应该要与标准高斯噪声<span class="math inline">\(\boldsymbol{x}_T\)</span>的分布足够接近。对于这一项来说，我们并不需要去训练，因为这一项也没有任何参数需要去学习。我们只需要保证<span class="math inline">\(T\)</span>足够大即可，这样这一项就能够趋近于 0。</li><li><span class="math inline">\(\sum_{t=1}^{T-1}\mathbb{E}_{q(\boldsymbol{x}_{t-1},\boldsymbol{x}_{t+1}|\boldsymbol{x}_0)}[D_{\text{KL}}(q(\boldsymbol{x}_t|\boldsymbol{x}_{t-1}) \parallelp_{\theta}(\boldsymbol{x}_t|\boldsymbol{x}_{t+1}))]\)</span>是一致项。它所要说明的意思是对于每一时间步 <spanclass="math inline">\(t\)</span>，我们的加噪过程和去噪过程应该保持一致性。也就是我们从<span class="math inline">\(\boldsymbol{x}_{t-1}\)</span> 加噪获取到的<span class="math inline">\(\boldsymbol{x}_{t}\)</span>，应该要与我们从<span class="math inline">\(\boldsymbol{x}_{t+1}\)</span> 去噪获取到的<span class="math inline">\(\boldsymbol{x}_{t}\)</span>，这两个的 <spanclass="math inline">\(\boldsymbol{x}_{t}\)</span>应该要越接近越好。这样就能够保证加噪和去噪的每一时间步的 <spanclass="math inline">\(\boldsymbol{x}_t\)</span>是一致的。同时从这里我们也可以看出，这一项需要中间所有时间步的 <spanclass="math inline">\(\text{KL}\)</span>散度求和，因此会是整个训练过程最耗时的部分。</li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch06 Model 组装</title>
      <link href="/2026/01/23/projects/minimind/minimind-Ch06-Model-%E7%BB%84%E8%A3%85/"/>
      <url>/2026/01/23/projects/minimind/minimind-Ch06-Model-%E7%BB%84%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/img/minimind/architecture.png","alt":"model architecture"}]</div>    </div><p>在上一章节中，我们又实现了单个的 Transformer块，在这一章节中，我们将会组装实现上图最左边的整个 Model 结构。</p><h2 id="tokenizer">Tokenizer</h2><p>Tokenizer（分词器） 是所有现代自然语言处理（NLP）模型（如ChatGPT、Llama、BERT 等）的第一道大门。</p><p>计算机根本看不懂“苹果”或“Apple”这些字，它只认识数字。Tokenizer的作用就是把一段文字切分成一个个小块（Token），然后把这些小块转换成计算机能识别的数字ID。</p><div class="note success flat"><p>📒Tokenizer 是人类语言（文本）和机器语言（数字）之间的“翻译官”。</p></div><h3 id="为什么需要-tokenizer">为什么需要 Tokenizer</h3><p>想象你要教一个只懂数学的机器人学英语：你不能直接给它看句子 “I loveAI”。你需要把句子拆开，变成列表：[“I”, “love”,“AI”]。你需要一本字典，规定：“I” = 1, “love” = 2, “AI” =3。最后你输入给机器人的其实是：[1, 2, 3]。</p><p>这个过程就是 Tokenization（分词）。</p><h3 id="工作流程">工作流程</h3><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第一步：切分</p></div></div><div class='timeline-item-content'><p>将一段长文本切成小的单元。注意分词器并不一定是按英语单词为最小划分单元，此处为了简便起见做了这个简化。</p><p>输入：<code>Learning AI is fun!</code></p><p>输出：<code>["Learning", "AI", "is", "fun", "!"]</code></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第二步：映射</p></div></div><div class='timeline-item-content'><p>拿着切分好的小块，去查一个巨大的词表（Vocabulary）。这个词表是模型训练前就定好的，里面的每一行都有一个对应的编号。</p><ul><li><code>"Learning"</code> <spanclass="math inline">\(\rightarrow\)</span> ID <code>4521</code></li><li><code>"AI"</code> <span class="math inline">\(\rightarrow\)</span>ID <code>123</code></li><li><code>"is"</code> <span class="math inline">\(\rightarrow\)</span>ID <code>11</code></li><li><code>"fun"</code> <span class="math inline">\(\rightarrow\)</span>ID <code>988</code></li><li><code>"!"</code> <span class="math inline">\(\rightarrow\)</span> ID<code>0</code></li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第三步：输出</p></div></div><div class='timeline-item-content'><p>将 ID 序列喂给神经网络模型。（也就是本次代码的输入就是<code>vocab_ids</code>，形状为 <code>[batch_size, seq_len]</code>）</p><p>最终输入给模型的：<code>[4521, 123, 11, 988, 0]</code></p></div></div></div><h3 id="分词的三种流派">分词的三种流派</h3><h4 id="按单词分word-based">按单词分（Word-based）</h4><p>英语单词变化太多了（run, running, runs,ran…），导致词表会变得超级大（几百万个）。如果遇到没见过的词（OOV），模型就傻了，通常会标记为<code>&lt;UNK&gt;</code>（Unknown）。</p><h4 id="按字符分character-based">按字符分（Character-based）</h4><p>优点是词表很小（26个字母+符号），不会遇到不认识的词。但是缺点是序列太长了，一句话可能变成几百个ID，模型处理起来非常慢，而且单个字母没有语义（“a”是什么意思？很难说）。</p><h4 id="按子词分subword-based-目前的主流bpe">按子词分（Subword-based）——目前的主流（BPE）</h4><p>这是现在 GPT、Llama 等模型使用的方法。它是前两者的折中方案。</p><p><strong>原则：常见的词保持完整，罕见的词拆开。</strong></p><ul><li>常见的词 <code>"apple"</code> <spanclass="math inline">\(\rightarrow\)</span> <code>["apple"]</code> (1 个Token)</li><li>罕见的词 <code>"unfriendly"</code> <spanclass="math inline">\(\rightarrow\)</span><code>["un", "friend", "ly"]</code> (3 个 Token)</li></ul><p>优点：词表大小适中（通常 3 万 ~ 10万左右），既能保持语义，又能处理生僻词（拼凑出来），效率还高。</p><h3 id="model-代码实现">Model 代码实现</h3><p>首先，我们会经过一个 <code>Input Embedding</code> 层，用来将Tokenizer 分出的 ID 给升维嵌入成 <code>hidden_dim</code>维度的向量。这里我们使用的是 <code>nn.Embedding()</code> 函数。</p><p>然后，我们经过 <code>num_hidden_layers</code> 数量的 TransformerLayer，由于我们实现好了 Block 块，这里直接调用<code>nn.ModuleList()</code>，然后 <code>for</code> 循环放入<code>num_hidden_layers</code> 个 Block 块即可。</p><p>之后经过 <code>RMSNorm</code> 进行一下归一化就可以了。</p><div class="note info flat"><p>⚠️注意为了与 <code>MiniMind</code>原项目尽可能保持一致，我们在这一章节中没有实现架构图中的<code>Linear</code> 和 <code>Softmax</code> 这两层。这两层的作用是重新把<code>hidden_dim</code> 维的向量映射成 <code>vocab_size</code>个单词，并且使用 <code>Softmax</code>给进一步转化成词库中每一个词的概率，从而决定我们应该选取哪一个词作为输出的下一个词。</p></div><p>这里在写代码的时候还是遇到了一些问题，因此在此处再多写一些内容。</p><p>第一点是 <code>kv_cache</code> 的最大长度 <code>max_seq_length</code>是模型能够处理的“上下文窗口“的总长度，如果不考虑外推，这个长度限制了“输入的Prompt“和“模型生成的回复“的总和。公式表达如下： <spanclass="math display">\[\text{self.freqs_cos 的长度} \ge \text{Prompt长度} + \text{生成的 Token长度}\]</span></p><p>第二点是对于代码中的 <code>start_pos</code> 的理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config: MiniMindConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.vocab_size = config.vocab_size</span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = config.hidden_dim</span><br><span class="line">        <span class="variable language_">self</span>.num_hidden_layers = config.num_hidden_layers</span><br><span class="line">        <span class="variable language_">self</span>.head_dim = <span class="variable language_">self</span>.hidden_dim // config.num_attention_heads</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.embedding_layer = nn.Embedding(<span class="variable language_">self</span>.vocab_size, <span class="variable language_">self</span>.hidden_dim)</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(config.dropout)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.transformer_layers = nn.ModuleList([</span><br><span class="line">            Block(i, config) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.num_hidden_layers)</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.rms_norm_layer = RMSNorm(<span class="variable language_">self</span>.hidden_dim, config.rms_norm_eps)</span><br><span class="line"></span><br><span class="line">        freqs_cos, freqs_sin = precompute_freqs_cis(<span class="variable language_">self</span>.head_dim, config.max_seq_len, config.rope_base, config.rope_scale)</span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&quot;freqs_cos&quot;</span>, freqs_cos, persistent=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.register_buffer(<span class="string">&quot;freqs_sin&quot;</span>, freqs_sin, persistent=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                vocab_ids: torch.Tensor,</span></span><br><span class="line"><span class="params">                past_key_values: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="type">Tuple</span>[torch.Tensor, torch.Tensor]]],</span></span><br><span class="line"><span class="params">                use_cache: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                attention_mask: <span class="type">Optional</span>[torch.Tensor] = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        batch_size, seq_len = vocab_ids.shape</span><br><span class="line"></span><br><span class="line">        past_key_values = past_key_values <span class="keyword">if</span> past_key_values <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> [<span class="literal">None</span>] * <span class="variable language_">self</span>.num_hidden_layers</span><br><span class="line"></span><br><span class="line">        x = <span class="variable language_">self</span>.embedding_layer(vocab_ids)</span><br><span class="line">        x = <span class="variable language_">self</span>.dropout(x)</span><br><span class="line"></span><br><span class="line">        start_pos = past_key_values[<span class="number">0</span>][<span class="number">0</span>].shape[-<span class="number">1</span>] <span class="keyword">if</span> past_key_values[<span class="number">0</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        position_embeddings = (<span class="variable language_">self</span>.freqs_cos[start_pos: start_pos + seq_len], <span class="variable language_">self</span>.freqs_sin[start_pos: start_pos + seq_len])</span><br><span class="line"></span><br><span class="line">        kv_caches = []</span><br><span class="line">        <span class="keyword">for</span> layer_id, (past_key_value, layer) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(past_key_values, <span class="variable language_">self</span>.transformer_layers)):</span><br><span class="line">            x, kv_cache = layer(x, position_embeddings, past_key_value, use_cache, attention_mask)</span><br><span class="line">            kv_caches.append(kv_cache)</span><br><span class="line"></span><br><span class="line">        output = <span class="variable language_">self</span>.rms_norm_layer(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, kv_cache</span><br></pre></td></tr></table></figure><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第一步：协同任务分解与分配</p></div></div><div class='timeline-item-content'><p>协同任务通过 <span class="math inline">\(\text{SMT}\)</span>算法分配给个体机器人（与之前论文相同）。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第二步：个体构建并预处理自动机</p></div></div><div class='timeline-item-content'><p>每个机器人整合协作任务，在本地利用拼接了协同任务的 <spanclass="math inline">\(\text{LTL}\)</span>表达式构造个体的自动机。之后每个机器人在自动机上利用 <spanclass="math inline">\(\text{BFS}\)</span>算法计算每个节点到接受节点的<strong>最近距离</strong>，作为后续每次选取节点的指标。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第三步：选择下一个节点转移</p></div></div><div class='timeline-item-content'><p>从自动机的候选节点（到接收节点的距离一样近）中综合考虑<strong>路径估计</strong>和<strong>协同等待任务</strong>，选取一个好的节点的转移条件（也就是需要完成什么任务）作为目标任务执行。启发式算法衡量好节点的标准： <span class="math display">\[cost(q) = \underbrace{|SP_{p_i, p_\pi}|}_{\text{最短路径}} \underbrace{-\mathbb{I}[\pi \in \mathcal{S}_\text{colla}] \cdotr_\text{colla}}_{协同任务且正被等待}, q \in \mathcal{Q}_\text{cand}\]</span>也就是综合考虑当前到任务区域的距离（<strong>优先完成距离最近的任务</strong>），以及如果当前<strong>有协同任务正有机器人在等待</strong>了，这个任务也会提高优先级。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第四步：导航</p></div></div><div class='timeline-item-content'><p>现在我们有了当前机器人的位置，以及目标任务的位置，就可以使用未知环境下的点对点（Point-to-PointNavigation）算法搜索路径去执行，这里使用的是 <spanclass="math inline">\(\text{A*}\)</span> 算法</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>第五步：更新地图，处理潜在任务</p></div></div><div class='timeline-item-content'><p>机器人可以通过雷达实时更新地图信息。并且可能在途中发现新的任务，新的任务会上传至中央服务器，中央服务器处理后下发给对应的机器人。</p><ul><li>如果是<strong>个体任务</strong>，直接下发给对应机器人，机器人拼接新的<span class="math inline">\(\text{LTL}\)</span>表达式，构造新的自动机，<strong>恢复当前执行状态</strong>（记录之前执行的任务序列，也就是转移条件，在新的自动机上内部推演），继续执行。</li><li>如果是<strong>协同任务</strong>，需要进行分解与分配，然后也下发给机器人群，每个机器人也按照上面的方法构造新的自动机，恢复状态，继续执行，但要通过强制制定顺序来避免发生死锁问题。</li></ul></div></div></div>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch05 Block 整合</title>
      <link href="/2026/01/22/projects/minimind/minimind-Ch05-Block-%E6%95%B4%E5%90%88/"/>
      <url>/2026/01/22/projects/minimind/minimind-Ch05-Block-%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/img/minimind/architecture.png","alt":"model architecture"}]</div>    </div><h2 id="block">Block</h2><p>这一章节，我们将要整合上两章讲过的 GQA 和FFN！对应上图中的紫色框的结构。话不多说，直接开干！</p><h3 id="block-代码实现">Block 代码实现</h3><div class="note warning flat"><p>这里我们最好维护一个 <code>layer_id</code>的变量，这对应着我们当前这个 Block 的ID。因为从上图中可以看到，我们最后的架构中，Block是会重复有好几个的，每一个都会对应有一个 <code>layer_id</code>。</p></div><p>在这一部分的代码中，对于<code>position_embedding</code>、<code>attention_mask</code> 和<code>past_key_value</code>这些变量，其实还是从上游传递过来的，并不是在这一层计算的，也没有必要在这一层进行计算，因为这些变量在每一层的Block 中都是不变的，所以只需要上层计算完成后，在每一层的 Block中传进去用就可以啦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer_id: <span class="built_in">int</span>, config: MiniMindConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = config.hidden_dim</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.layer_id = layer_id</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.attention_rms_norm = RMSNorm(<span class="variable language_">self</span>.hidden_dim)</span><br><span class="line">        <span class="variable language_">self</span>.attention = Attention(config)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.ffn_rms_norm = RMSNorm(<span class="variable language_">self</span>.hidden_dim)</span><br><span class="line">        <span class="variable language_">self</span>.ffn = FFN(config)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                x: torch.Tensor,</span></span><br><span class="line"><span class="params">                position_embeddings: <span class="type">Tuple</span>[torch.Tensor, torch.Tensor],</span></span><br><span class="line"><span class="params">                past_key_value: <span class="type">Optional</span>[<span class="type">Tuple</span>[torch.Tensor, torch.Tensor]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                use_cache: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                attention_mask: <span class="type">Optional</span>[torch.Tensor] = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">        orig_x = x</span><br><span class="line">        x = <span class="variable language_">self</span>.attention_rms_norm(x)</span><br><span class="line">        x, past_key_value = <span class="variable language_">self</span>.attention(x, position_embeddings, past_key_value, use_cache, attention_mask)</span><br><span class="line">        x = x + orig_x      <span class="comment"># GQA Residual</span></span><br><span class="line"></span><br><span class="line">        orig_x = x</span><br><span class="line">        x = <span class="variable language_">self</span>.ffn_rms_norm(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.ffn(x)</span><br><span class="line">        output = x + orig_x     <span class="comment"># FFN Residual</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, past_key_value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch04 FFN 模块</title>
      <link href="/2026/01/22/projects/minimind/minimind-Ch04-FFN-%E6%A8%A1%E5%9D%97/"/>
      <url>/2026/01/22/projects/minimind/minimind-Ch04-FFN-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/img/minimind/architecture.png","alt":"model architecture"}]</div>    </div><h2 id="ffn">FFN</h2><p>FFN（Feed ForwardNetwork）前馈网络这一部分比较简单，只是多个简单网络层和激活函数的拼接，不像GQA 部分涉及很深的理论背景。</p><p>这一部分有一个 SiLU 激活函数，可以拿出来介绍一下。</p><h3 id="textsilu-激活函数"><spanclass="math inline">\(\text{SiLU}\)</span> 激活函数</h3><p>简单来说，SiLU 是 ReLU 的一个平滑、非线性、自带门控机制的升级版。</p><h4 id="silu-公式">SiLU 公式</h4><p>SiLU 的公式非常简单，就是输入乘以它自己的 Sigmoid： <spanclass="math display">\[\begin{equation}\text{SiLU}(x) = x \cdot \sigma(x) = \frac{x}{1 + e^{-x}}\end{equation}\]</span></p><p>这里的 <span class="math inline">\(\sigma(x)\)</span> 是 Sigmoid函数（输出在 0 到 1 之间）。</p><p>我们可以把它拆解来看：</p><ul><li><p><span class="math inline">\(x\)</span>：原始输入。</p></li><li><p><span class="math inline">\(\sigma(x)\)</span>：一个 0 到 1之间的系数（Gate/门控）</p><ul><li>当 <span class="math inline">\(x\)</span> 很大（正无穷）时，<spanclass="math inline">\(\sigma(x) \approx 1\)</span>，结果就是 <spanclass="math inline">\(x\)</span>（线性）</li><li>当 <span class="math inline">\(x\)</span> 很小（负无穷）时，<spanclass="math inline">\(\sigma(x) \approx 0\)</span>，结果就是0（被关门了）</li></ul></li></ul><h4 id="silu-图像">SiLU 图像</h4><img src="/img/minimind/SiLU.png" class="" title="100px SiLU 函数图像"><p>如果你画出它的图像，你会发现它和 ReLU长得很像，但有两个关键区别：</p><ul><li><p><strong>平滑（Smooth）：</strong> ReLU 处有个尖角（不可导）。SiLU则是完全平滑的曲线，这让梯度下降优化时更顺畅，不会出现梯度的突变。</p></li><li><p><strong>非单调性（Non-monotonicity）：</strong> 在负数区域（大约<span class="math inline">\(x \approx 1.28\)</span> 处），SiLU有一个轻微的下凹，最低能达到约 -0.28，然后再慢慢回到 0。</p><ul><li><strong>ReLU：</strong>负数一刀切，全是 0。</li><li><strong>SiLU：</strong>允许少量的负数信息通过，甚至在某些特定负值区间保留了负激活。这种特性被证明能帮助深层网络更好地捕捉复杂的特征分布。</li></ul></li></ul><p>其他部分没有什么好讲的了，都是简单的模块的拼凑。</p><h3 id="ffn-代码实现">FFN 代码实现</h3><p>在 FFN 中，首先我们要对归一化的输入进行升维，传统的 Standard FFN 只有2 个矩阵（升维和降维），中间层的膨胀系数通常是 4 倍。</p><p>传统的 Transformer（如 BERT，GPT-2）中只有两个矩阵：</p><ul><li>结构：<span class="math inline">\(W_1(d \rightarrow 4d), \quad\text{ReLU}, \quad W_2(4d \rightarrow d)\)</span></li><li>参数量近似：<span class="math inline">\(2 \times (d \times 4d) =8d^2\)</span></li></ul><p>Llama 的 SwiGLU FFN 中有三个矩阵（Gate, Up, Down）：</p><ul><li>结构：<span class="math inline">\(W_{gate}(d \rightarrow d_{int}),\quad W_{up}(d \rightarrow d_{int}), \quad W_{down}(d_{int} \rightarrowd)\)</span></li><li>如果我们依旧让中间层 <span class="math inline">\(d_{int}\)</span>等于 <span class="math inline">\(4d\)</span>，参数量会变成 <spanclass="math inline">\(12d^2\)</span>，这个参数量过大。因此，为了能够与前面传统的参数量保持一致，我们需要解方程<span class="math inline">\(3 \times (d \times d_{int}) =8d^2\)</span>，解得 <span class="math inline">\(d_{int} =\frac{8}{3}d\)</span>。</li></ul><p>这个 <span class="math inline">\(d_{int}\)</span> 不一定能够被 64整除。在现代 GPU（如 NVIDIA A100, H100）内部的计算单元（TensorCores）在处理矩阵乘法时，如果矩阵的维度是 2 的幂次（如 32, 64, 128,256）的倍数，效率是最高的。因此，我们通过<strong>整除 64并且上取整</strong>的方式，来将 <spanclass="math inline">\(d_{int}\)</span> 变为 64 的整数倍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FFN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config: MiniMindConfig</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = config.hidden_dim</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> config.intermediate_dim <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            intermediate_dim = <span class="built_in">int</span>(config.hidden_dim * <span class="number">8</span> / <span class="number">3</span>)</span><br><span class="line">            <span class="variable language_">self</span>.intermediate_dim = <span class="number">64</span> * ((intermediate_dim + <span class="number">64</span> - <span class="number">1</span>) // <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.intermediate_dim = config.intermediate_dim</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.up_proj = nn.Linear(<span class="variable language_">self</span>.hidden_dim, <span class="variable language_">self</span>.intermediate_dim, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.gate_proj = nn.Linear(<span class="variable language_">self</span>.hidden_dim, <span class="variable language_">self</span>.intermediate_dim, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.act = nn.SiLU()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(config.dropout)</span><br><span class="line">        <span class="variable language_">self</span>.down_proj = nn.Linear(<span class="variable language_">self</span>.intermediate_dim, <span class="variable language_">self</span>.hidden_dim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor</span>):</span><br><span class="line"></span><br><span class="line">        x1 = <span class="variable language_">self</span>.up_proj(x)</span><br><span class="line">        x2 = <span class="variable language_">self</span>.act(<span class="variable language_">self</span>.gate_proj(x))</span><br><span class="line"></span><br><span class="line">        output = x1 * x2</span><br><span class="line">        output = <span class="variable language_">self</span>.dropout(<span class="variable language_">self</span>.down_proj(output))</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch03 GQA 模块</title>
      <link href="/2026/01/21/projects/minimind/minimind-Ch03-GQA-%E6%A8%A1%E5%9D%97/"/>
      <url>/2026/01/21/projects/minimind/minimind-Ch03-GQA-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/img/minimind/architecture.png","alt":"model architecture"}]</div>    </div><p>在这一部分，我们将要对 <strong>GQA（Grouped QueryAttention）分组查询注意力</strong>模块进行详细的介绍。</p><p>作为前置知识，还是有必要先对 Attention 进行说明。</p><h2 id="attention">Attention</h2><h3 id="核心直觉">核心直觉</h3><p>Attention 的本质是一个<strong>“软寻址”（SoftAddressing）或“内容查询”</strong>的过程，能够通过算法，让你注意到为了完成这个任务，应该注意的地方。Attention通过 <span class="math inline">\(Q, K, V\)</span>三个向量来实现这一点。</p><div class="note success flat"><p>举一个🌰——想象你在图书馆找资料（或者在 SQL 数据库里查询）：</p><ul><li>Query (Q): 你手里的问题（比如“深度学习的历史”）。</li><li>Key (K): 图书馆里每本书书脊上的标签（分类号或书名）。</li><li>Value (V): 书里的具体内容。</li></ul></div><p>注意力机制的过程： <div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>匹配 (Matching)</p></div></div><div class='timeline-item-content'><p>拿你的 Query 去和所有的 Key 进行对比（计算相似度）。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>权重 (Weighting)</p></div></div><div class='timeline-item-content'><p>越相似的 Key，给的关注度（权重）越高。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>聚合 (Aggregation)</p></div></div><div class='timeline-item-content'><p>根据权重，把对应的 Value 加权求和，提取出来。</p></div></div></div></p><p>在神经网络中，<span class="math inline">\(Q、K、V\)</span>都是向量（Vectors），其形状均为 <span class="math inline">\(N \timesd_k\)</span>，其中 <span class="math inline">\(N\)</span> 表示 token的数量，<span class="math inline">\(d_k\)</span> 表示的是每一个 token被编码成的向量的维度。</p><h3 id="数学本质">数学本质</h3><p>Attention 的数学公式为 <span class="math display">\[\begin{equation}    \label{eq:attention}\text{Attetion}(Q, K, V) = \text{Softmax}(\frac{QK^T}{\sqrt{d_k}})V\end{equation}\]</span></p><h4 id="qkt相似度计算"><spanclass="math inline">\(QK^T\)</span>（相似度计算）</h4><p>这里使用的点积，因为点积能够衡量两个向量的相似度（几何夹角）。由上面的形状说明，我们可以得知，这里计算出的矩阵的大小为<span class="math inline">\(N \times N\)</span>，也就是每一个 token<span class="math inline">\(i\)</span> 与其他 token <spanclass="math inline">\(j\)</span>（也包括自身）的相似度。</p><div class="note danger flat"><p>注意，这里生成的矩阵的大小为 <span class="math inline">\(N \timesN\)</span>，行和列都是 tokens 序列的长度。其中每一行代表我们要查询的token（<span class="math inline">\(Q\)</span>），每一列代表其他 tokens的键（<spanclass="math inline">\(K\)</span>）。区分行和列是非常重要的，因为后续在进行因果推断训练的时候，我们需要用掩码去掩盖后面的token，禁止模型去“提前看”后续的 tokens。因此，这个矩阵 <spanclass="math inline">\(QK^T\)</span>的<mark class="hl-label red"><strong>上三角矩阵</strong></mark>应该被置为<span class="math inline">\(-\infty\)</span>，来确保经过 <spanclass="math inline">\(\text{Softmax}\)</span> 之后，其概率值为 0。</p></div><h4 id="sqrtd_k缩放因子"><spanclass="math inline">\(\sqrt{d_k}\)</span>（缩放因子）</h4><p>假设 <span class="math inline">\(Q\)</span> 和 <spanclass="math inline">\(K\)</span> 的元素服从均值为 0、方差为 1的分布，点积后的数值方差会变成 <spanclass="math inline">\(d_k\)</span>（维度越大，点积结果数值越大，因为<span class="math inline">\(QK^T\)</span> 运算并没有任何的平均化操作）。如果不缩放，数值过大，经过 <spanclass="math inline">\(\text{Softmax}\)</span>后会落入“饱和区”（梯度几乎为 0），导致梯度消失，模型难以训练。 除以<span class="math inline">\(\sqrt{d_k}\)</span> 将方差拉回1，保证梯度流稳定。</p><div class="note warning flat"><p>所谓的“饱和区，也就是输入过大或者太小，这个时候函数变化趋势已经很平缓了，因此梯度很小，模型难以训练。</p></div><img src="/img/minimind/image-3.png" class="" title="50% softmax"><h4 id="textsoftmax归一化"><spanclass="math inline">\(\text{Softmax}\)</span>（归一化）</h4><p>将分数转化为概率分布（和为1），这决定了模型要把多少“注意力”分配给当前的位置。</p><h4 id="times-v加权求和"><span class="math inline">\(\timesV\)</span>（加权求和）</h4><p>我们前面计算出了当前查询的 token 对于其他每一个 token的关注比例。比如，“I love you” 计算出 “I” 这个 token 对于 “I” 的概率为0.32，对于 “love” 的概率为 0.16，对于 “you” 的概率为0.52。那么，最终计算出的值是所有 <span class="math inline">\(V\)</span>的加权混合值，即 <span class="math display">\[V = 0.32V_{\text{I}} + 0.16V_{\text{love}} + 0.52V_{\text{you}}\]</span></p><h3 id="家族变体self-cross-causal">家族变体：Self, Cross, Causal</h3><h4 id="self-attention-自注意力">Self-Attention (自注意力)</h4><p><span class="math inline">\(Q, K, V\)</span> 都来自同一个输入源 <spanclass="math inline">\(X\)</span>，即 <span class="math inline">\(Q =XW_q, \quad K = XW_k, \quad V = XW_v\)</span>。如果 <spanclass="math inline">\(X\)</span> 的形状为 <span class="math inline">\(B\times N \times d_k\)</span>，其中 <spanclass="math inline">\(B\)</span> 为 batch 大小，<spanclass="math inline">\(N\)</span> 为序列长度，<spanclass="math inline">\(d_k\)</span> 表示嵌入维度。那么我们有 <spanclass="math inline">\(W_q\)</span> 和 <spanclass="math inline">\(W_k\)</span> 的形状均为 <spanclass="math inline">\(d_k \times d_{qk_{dim}}\)</span>，其中 <spanclass="math inline">\(d_{qk_{dim}}\)</span>表示键——查询的空间维度，一般会比嵌入维度 <spanclass="math inline">\(d_k\)</span> 小。而 <spanclass="math inline">\(W_v\)</span> 矩阵不同，<spanclass="math inline">\(V\)</span> 最后是要能直接加到 <spanclass="math inline">\(X\)</span> 上进行更新的，因此 <spanclass="math inline">\(W_v\)</span> 最后一维的大小为 <spanclass="math inline">\(d_k\)</span>。所以，<spanclass="math inline">\(V\)</span> 的形状为 <spanclass="math inline">\(d_k\times d_k\)</span>。可以看到，<spanclass="math inline">\(W_v\)</span> 矩阵会比 <spanclass="math inline">\(W_q\)</span> 和 <spanclass="math inline">\(W_k\)</span>大很多，因此，实际工程中，我们一般会对 <spanclass="math inline">\(W_v\)</span> 矩阵进行低秩分解，分解成形状为 <spanclass="math inline">\(d_k \times d^\prime\)</span> 和 <spanclass="math inline">\(d^\prime \times d_k\)</span>的两个小矩阵的乘积。</p><p><span class="math display">\[\begin{equation}\begin{aligned}W_v &amp;=\scriptsize{\underbrace{    \begin{pmatrix}    w_{11} &amp; w_{12} &amp; w_{13} &amp; w_{14} &amp; \cdots &amp;w_{1(d_k-1)} &amp; w_{1d_k} \\    w_{21} &amp; w_{22} &amp; w_{23} &amp; w_{24} &amp; \cdots &amp;w_{2(d_k-1)} &amp; w_{2d_k} \\    w_{31} &amp; w_{32} &amp; w_{33} &amp; w_{34} &amp; \cdots &amp;w_{3(d_k-1)} &amp; w_{3d_k} \\    w_{41} &amp; w_{42} &amp; w_{43} &amp; w_{44} &amp; \cdots &amp;w_{4(d_k-1)} &amp; w_{4d_k} \\    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;\vdots &amp; \vdots \\    w_{(d_k-1)1} &amp; w_{(d_k-1)2} &amp; w_{(d_k-1)3} &amp;w_{(d_k-1)4} &amp; \cdots &amp; w_{(d_k-1)(d_k-1)} &amp; w_{(d_k-1)d_k}\\    w_{d_k1} &amp; w_{d_k2} &amp; w_{d_k3} &amp; w_{d_k4} &amp; \cdots&amp; w_{d_k(d_k-1)} &amp; w_{d_kd_k} \\    \end{pmatrix}}_{d_k \times d_k}} \\&amp;=\scriptsize{\underbrace{    \begin{pmatrix}    w_{11} &amp; w_{12} &amp; \cdots &amp; w_{1(d^\prime-1)} &amp;w_{1d^\prime} \\    w_{21} &amp; w_{22} &amp; \cdots &amp; w_{2(d^\prime-1)} &amp;w_{2d^\prime} \\    w_{31} &amp; w_{12} &amp; \cdots &amp; w_{3(d^\prime-1)} &amp;w_{3d^\prime} \\    w_{41} &amp; w_{12} &amp; \cdots &amp; w_{4(d^\prime-1)} &amp;w_{4d^\prime} \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\    w_{(d_k-1)1} &amp; w_{(d_k-1)2} &amp; \cdots &amp;w_{(d_k-1)(d^\prime-1)} &amp; w_{(d_k-1)d^\prime} \\    w_{d_k1} &amp; w_{d_k2} &amp; \cdots &amp; w_{d_k(d^{\prime-1})}&amp; w_{d_kd^\prime} \\    \end{pmatrix}}_{W_v \uparrow \quad d_k \times d^\prime}\underbrace{    \begin{pmatrix}    w^\prime_{11} &amp; w^\prime_{12} &amp; w^\prime_{13} &amp; \cdots&amp; w^\prime_{1(d_k-1)} &amp; w^\prime_{1d_k} \\    w^\prime_{21} &amp; w^\prime_{22} &amp; w^\prime_{23} &amp; \cdots&amp; w^\prime_{2(d_k-1)} &amp; w^\prime_{2d_k} \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp;\vdots \\    w^\prime_{(d^\prime-1)1} &amp; w^\prime_{(d^\prime-1)2} &amp;w^\prime_{(d^\prime-1)3} &amp; \cdots &amp;w^\prime_{(d^\prime-1)(d_k-1)} &amp; w^\prime_{(d^\prime-1)d_k} \\    w^\prime_{d^\prime 1} &amp; w^\prime_{d^\prime 2} &amp;w^\prime_{d^\prime 3} &amp; \cdots &amp; w^\prime_{d^\prime (d_k-1)}&amp; w^\prime_{d^\prime d_k} \\    \end{pmatrix}}_{W_v \downarrow \quad d^\prime \times d_k} \\}\end{aligned}\end{equation}\]</span></p><p>而在计算 <span class="math inline">\(V\)</span>的时候，一般我们只会用 <span class="math inline">\(W_v \uparrow\)</span>这个矩阵，而把 <span class="math inline">\(W_v \downarrow\)</span>这个矩阵留作最后的 <spanclass="math inline">\(W_o\)</span>（也就是开头那张流程图 GQA中最后那里的 Linear 层。<mark class="hl-label orange">并且，最后续的 $W_o$ 这个矩阵可以把多个头的拼接起来，形成 $d_k \times d_k$ 大小的矩阵，进行一次大的矩阵运算即可</mark>，更快更高效。</p><h4 id="cross-attention-交叉注意力">Cross-Attention (交叉注意力)</h4><p>建设中💪</p><h4 id="causal-masked-attention-因果注意力">Causal / Masked Attention(因果注意力)</h4><p>因果注意力（Causal Attention），也常被称为 MaskedAttention（掩码注意力），是 GPT 类模型（Decoder-only架构）能够进行文本生成的核心机制。</p><div class="note success flat"><p>它的作用是确保模型在预测当前字的时候，只能看到前面的字，绝对不能偷看后面的字。如果没有它，ChatGPT就无法生成连贯的句子，因为训练时它会“作弊”直接看到答案。</p></div><p>假设我们要训练模型学习一句话：“我喜欢吃苹果”。在 Transformer的训练中，为了效率，我们是一次性把整句话输入进去的（并行计算）。当模型在位置2处理“喜欢”这个词时，它的任务是预测下一个词是“吃”。但是，因为整句话都在输入里，标准的自注意力机制（Self-Attention）会让“喜欢”这个词能看到“吃”和“苹果”。</p><p><strong>后果（数据泄露）：</strong>如果模型能看到“苹果”，它就不需要学习语法和逻辑了，直接把后面的字抄过来就行。这就好比考试时把答案放在了卷子旁边，模型学会了抄答案，但没学会解题。</p><p>解决办法就是把后面还没发生的词挡住（Mask）： <spanclass="math display">\[\begin{equation}    \label{eq:mask_attention}\text{Attetion}(Q, K, V) = \text{Softmax}(\frac{QK^T + M}{\sqrt{d_k}})V\end{equation}\]</span> 其中的掩码矩阵 <span class="math inline">\(M\)</span> 由 0 和<span class="math inline">\(-\infty\)</span> 构成，并且 <spanclass="math inline">\(-\infty\)</span>分布在上三角（不包括主对角线）</p><p><span class="math display">\[\scriptsize{M =\begin{pmatrix}    0 &amp; -\infty &amp; -\infty &amp; -\infty &amp; \cdots &amp;-\infty &amp; -\infty \\    0 &amp; 0 &amp; -\infty &amp; -\infty &amp; \cdots &amp; -\infty&amp; -\infty \\    0 &amp; 0 &amp; 0 &amp; -\infty &amp; \cdots &amp; -\infty &amp;-\infty \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\infty &amp; -\infty\\    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;\vdots &amp; \vdots \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\infty \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\\end{pmatrix}}\]</span></p><h3 id="multi-head-attention-多头注意力">Multi-Head Attention(多头注意力)</h3><p>“多头”能够让模型更好的理解输入，就像人看文章，既要看语法结构（主谓宾），又要看指代关系（it指谁），还要看情感色彩。一个头（一组 <spanclass="math inline">\(QKV\)</span>）不够用。</p><p>实现流程如下：</p><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>维度切分</p></div></div><div class='timeline-item-content'><p>一般来说，输入 Attention 层的 <code>x</code> 的形状通常为<code>[batch_size, seq_len, hidden_dim]</code>。之后，我们规定头的个数为<code>num_heads</code>，于是，我们会把 <code>x</code> reshape 成形状<code>[batch_size, seq_len, num_heads, head_dim]</code>，其中<code>hidden_dim = num_heads * head_dim</code>。</p><p>此处还需要注意的是，我们把每个“头”分下去，而且每个头里面都应该是完整的<code>seq_len</code> 长度。所以，我们需要对前面的 <code>x</code> 的第 1维和第 2 维再进行一次转置，将形状变为<code>[batch_size, num_heads, seq_len, head_dim]</code></p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>每个头独立做 Attention</p></div></div><div class='timeline-item-content'><p>每一个 head 拿到的输入 <code>x_h</code> 的形状为<code>[batch_size, seq_len, head_dim]</code>。然后按照前面说的算法求解注意力分数，值加权求和即可。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>把 <span class="math inline">\(h\)</span> 个结果拼接回去</p></div></div><div class='timeline-item-content'><p>这一步就相当于是步骤 1 的逆过程了，此处不再赘述。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>融合信息</p></div></div><div class='timeline-item-content'><p>最后，经过一个线性层 <span class="math inline">\(W_o\)</span>融合信息，公式为 <span class="math display">\[\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots,\text{head}_h)W_o\]</span></p></div></div></div><div class="note info flat"><p>🖊️在实际工程中，分别计算几个小的 <spanclass="math inline">\(QKV\)</span>矩阵然后再将其拼接，是比较耗时的。因此，在代码实现中，我们更倾向于整体使用一个大的<span class="math inline">\(QKV\)</span>矩阵与输入进行相乘，然后再将输出给 reshape 或者 view 成<code>[batch_size, seq_len, num_heads, head_dim]</code> 的形状！</p></div><h2 id="gqa">GQA</h2><p>接下来进入正题，正式讲解分组查询注意力。在此之前，首先我们需要了解一下<strong>MHA（Multi-HeadAttention）标准多头注意力</strong>和<strong>MQA（Multi-QueryAttention）多查询注意力</strong>。</p><h3 id="mhamulti-head-attention">MHA（Multi-Head Attention）</h3><p>这是 Transformer 原文的设计，也是 BERT、GPT-2 的做法。</p><ul><li>配置：8 个 <span class="math inline">\(Q\)</span> 头，配对 8 个<span class="math inline">\(K\)</span> 头 和 8 个 <spanclass="math inline">\(V\)</span> 头。</li><li>关系：1 对 1。每个 <span class="math inline">\(Q\)</span>头都有自己专属的 <span class="math inline">\(K\)</span> 和 <spanclass="math inline">\(V\)</span>。</li><li>优点：脑子最好使，捕捉细节能力最强。</li><li>缺点：KV Cache 太大。推理时（生成文本时），需要把所有的 <spanclass="math inline">\(K\)</span> 和 <spanclass="math inline">\(V\)</span>存下来。显存占用极高，读取速度慢（带宽瓶颈）。</li></ul><h3 id="mqamulti-query-attention">MQA（Multi-Query Attention）</h3><p>为了解决显存不够用的问题，Google 提出了 MQA（如 Falcon 模型）。</p><ul><li>配置：8 个 <span class="math inline">\(Q\)</span> 头，只配 1 个<span class="math inline">\(K\)</span> 头 和 1 个 <spanclass="math inline">\(V\)</span> 头。</li><li>关系：多对 1。所有的 <span class="math inline">\(Q\)</span>头共享同一份 <span class="math inline">\(K\)</span> 和 <spanclass="math inline">\(V\)</span>。</li><li>优点：KV Cache 极小（只有 MHA 的 1/8），推理速度飞快。</li><li>缺点：变笨了。因为所有人看同一份资料，模型的表达能力下降，容易产生幻觉或逻辑混乱。</li></ul><p>GQA (Grouped Query Attention，分组查询注意力) 是目前大语言模型（如Llama 2-70B, Llama 3,Mistral）中为了平衡推理速度和模型性能而采用的一种主流技术。简单来说，它是MHA（标准多头注意力）和 MQA（多查询注意力）之间的折中方案。</p><h2 id="attention-代码实现">Attention 代码实现</h2><p>首先是对于 GQA 所需要的工具函数进行一下实现。因为 <spanclass="math inline">\(KV\)</span> 头的数量是少于 <spanclass="math inline">\(Q\)</span> 的，因此，我们在分头之后，需要对 <spanclass="math inline">\(K、V\)</span> 这两个张量的 <code>num_heads</code>进行一下复制，让它们的大小与 <span class="math inline">\(Q\)</span>的相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat_kv</span>(<span class="params">x: torch.Tensor, n_rep: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n_rep == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    batch_size, seq_len, num_heads, head_dim = x.shape</span><br><span class="line">    <span class="keyword">return</span> x[:, :, :, <span class="literal">None</span>, :].expand(batch_size, seq_len, num_heads, n_rep, head_dim).reshape(batch_size, seq_len, num_heads * n_rep, head_dim)</span><br></pre></td></tr></table></figure><p>接下来就是 Attention的实现了，之前看视频的时候照着写过一次，但是在写此文，铺垫了前面这么多的知识后，我决定尝试自己完全再重新写一次，以检验一下自己是否真的明白了。断断续续写了1个多小时，最后还是没写出一个完美的版本，尤其是对于网络、张量的维度的理解，脑子里当时还是一片浆糊。但这也是真正理解Attention的必经之路。一边照着视频一边写，很多时候都只是一知半解，以为自己会了，实则不然。只有真正自己动手，从零开始不参照任何资料写出来，这才是理解了。</p><p>这其中，我感觉最深的就是理论与实践之间的gap。如前面所述，我们这里用的是多头注意力，我们需要先把头分出来，然后每一个头单独进行Attention的运算。当时写代码的时候，我就是按照这个来写的，这样的话需要有多个 <spanclass="math inline">\(W_q, W_k, W_v\)</span>矩阵。但这样写实在是太麻烦了，越写心里越没有底，最后还是去看了范例是怎么写的。研究之后我才恍然大悟，我们需要对输入的<span class="math inline">\(X\)</span> 分成 <spanclass="math inline">\(h\)</span> 部分，然后又要有 <spanclass="math inline">\(h\)</span> 个与之对应的 <spanclass="math inline">\(W_q, W_k, W_v\)</span>（暂不考虑 GQA，如果考虑的话<span class="math inline">\(W_k\)</span> 和 <spanclass="math inline">\(W_v\)</span>数量会少一些），那其实，我们可以先不进行划分，直接对于整体的 <spanclass="math inline">\(X\)</span> 与整体的 <spanclass="math inline">\(W_q, W_k, W_v\)</span> 进行矩阵运算，之后到了求解Attention 分数的时候，再通过 <code>transpose</code> 以及<code>reshape</code> 等操作分成 <span class="math inline">\(h\)</span>部分进行。最后在经过 <span class="math inline">\(W_o\)</span>的时候，再变回去。全程我们都是在一个整体的矩阵中计算的，并没有孤立分成多个矩阵，需要分开的时候，我们是通过<code>transpose</code> 和 <code>reshape</code>来实现的。始终在一个大整体的矩阵中进行运算，这样能够提高 GPU的运算速度。</p><div class="note warning flat"><p>注意此处完成的并不是整个绿色框全部，而是暂时忽略掉了<code>RMSNorm</code> 这一网络。<code>RMSNorm</code> 层将会在组装这一整个Block 的时候实现。</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Attention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config: MiniMindConfig</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.num_key_value_heads = config.num_key_value_heads <span class="keyword">if</span> config.num_key_value_heads <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> config.num_attention_heads</span><br><span class="line">        <span class="variable language_">self</span>.num_attention_heads = config.num_attention_heads</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="variable language_">self</span>.num_attention_heads % <span class="variable language_">self</span>.num_key_value_heads == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.n_rep = <span class="variable language_">self</span>.num_attention_heads // <span class="variable language_">self</span>.num_key_value_heads</span><br><span class="line">        <span class="variable language_">self</span>.hidden_dim = config.hidden_dim</span><br><span class="line">        <span class="variable language_">self</span>.head_dim = <span class="variable language_">self</span>.hidden_dim // <span class="variable language_">self</span>.num_attention_heads</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.q_proj = nn.Linear(<span class="variable language_">self</span>.hidden_dim, <span class="variable language_">self</span>.num_attention_heads * <span class="variable language_">self</span>.head_dim, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.k_proj = nn.Linear(<span class="variable language_">self</span>.hidden_dim, <span class="variable language_">self</span>.num_key_value_heads * <span class="variable language_">self</span>.head_dim, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.v_proj = nn.Linear(<span class="variable language_">self</span>.hidden_dim, <span class="variable language_">self</span>.num_key_value_heads * <span class="variable language_">self</span>.head_dim, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.o_proj = nn.Linear(<span class="variable language_">self</span>.head_dim * <span class="variable language_">self</span>.num_attention_heads, <span class="variable language_">self</span>.hidden_dim, bias=<span class="literal">False</span>)</span><br><span class="line">        <span class="variable language_">self</span>.attention_dropout = nn.Dropout(config.dropout)</span><br><span class="line">        <span class="variable language_">self</span>.residual_dropout = nn.Dropout(config.dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                x: torch.Tensor,</span></span><br><span class="line"><span class="params">                position_embeddings: <span class="type">Tuple</span>[torch.Tensor, torch.Tensor],</span></span><br><span class="line"><span class="params">                past_key_value: <span class="type">Optional</span>[<span class="type">Tuple</span>[torch.Tensor, torch.Tensor]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                use_cache: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                attention_mask: <span class="type">Optional</span>[torch.Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                </span>):</span><br><span class="line"></span><br><span class="line">        batch_size, seq_len, hidden_dim = x.shape</span><br><span class="line">        <span class="comment"># now x.shape is [batch_size, seq_len, num_heads, head_dim]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. projection</span></span><br><span class="line">        xq = <span class="variable language_">self</span>.q_proj(x).view(batch_size, seq_len, <span class="variable language_">self</span>.num_attention_heads, <span class="variable language_">self</span>.head_dim)</span><br><span class="line">        xk = <span class="variable language_">self</span>.k_proj(x).view(batch_size, seq_len, <span class="variable language_">self</span>.num_key_value_heads, <span class="variable language_">self</span>.head_dim)</span><br><span class="line">        xv = <span class="variable language_">self</span>.v_proj(x).view(batch_size, seq_len, <span class="variable language_">self</span>.num_key_value_heads, <span class="variable language_">self</span>.head_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. RoPE rotation</span></span><br><span class="line">        <span class="comment"># now xq.shape is [batch_size, num_heads, seq_len, intermediate_dim]</span></span><br><span class="line">        freqs_cos, freqs_sin = position_embeddings</span><br><span class="line">        xq, xk = apply_rotary_position_embedding(xq, xk, freqs_cos[: seq_len], freqs_sin[: seq_len])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. kv cache update</span></span><br><span class="line">        <span class="keyword">if</span> past_key_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            xk = torch.cat([past_key_value[<span class="number">0</span>], xk], dim=<span class="number">1</span>)</span><br><span class="line">            xv = torch.cat([past_key_value[<span class="number">1</span>], xv], dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        past_key_value = (xk, xv) <span class="keyword">if</span> use_cache <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># convert to [batch_size, num_heads, seq_len, head_dim]</span></span><br><span class="line">        xq = xq.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        xk = repeat_kv(xk, <span class="variable language_">self</span>.n_rep).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        xv = repeat_kv(xv, <span class="variable language_">self</span>.n_rep).transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        score = xq @ xk.transpose(-<span class="number">2</span>, -<span class="number">1</span>) / math.sqrt(<span class="variable language_">self</span>.head_dim)</span><br><span class="line">        mask = torch.triu(torch.full((seq_len, seq_len), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), device=score.device), diagonal=<span class="number">1</span>)</span><br><span class="line">        score = score + mask</span><br><span class="line"></span><br><span class="line">        <span class="comment"># attention_mask.shape [seq_len, seq_len]</span></span><br><span class="line">        <span class="keyword">if</span> attention_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            attention_mask.unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">            score = score + (<span class="number">1</span> - attention_mask) * <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        output = torch.nn.functional.softmax(score.<span class="built_in">float</span>(), dim=-<span class="number">1</span>) @ xv    <span class="comment"># [batch_size, num_heads, seq_len, hidden_dim]</span></span><br><span class="line">        output = <span class="variable language_">self</span>.attention_dropout(output)</span><br><span class="line"></span><br><span class="line">        output = output.transpose(<span class="number">1</span>, <span class="number">2</span>)     <span class="comment"># [batch_size, seq_len, num_heads, hidden_dim]</span></span><br><span class="line">        output = output.reshape(batch_size, seq_len, <span class="variable language_">self</span>.num_attention_heads * <span class="variable language_">self</span>.head_dim)</span><br><span class="line">        output = <span class="variable language_">self</span>.o_proj(output)</span><br><span class="line">        output = <span class="variable language_">self</span>.residual_dropout(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, past_key_value</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>❌ <strong>犯错点</strong></p><ol type="1"><li>使用 <code>kv_cache</code> 的时候，将当前计算的 <code>xk</code>与之前的 <code>cache</code> 进行拼接的时候，拼接的维度为<code>dim=1</code>，也就是 <code>seq_len</code> 这个维度；</li><li>训练的时候不需要 <code>kv_cache</code>，因为每次计算出的 <spanclass="math inline">\(W_k\)</span> 和 <spanclass="math inline">\(W_v\)</span>在下一步的时候就被更新了，缓存的值没有任何意义了；</li><li><code>torch.nn.functional.softmax(score.float(), dim=-1)</code>最好带上 <code>dim=-1</code>；</li><li><code>mask</code> 在推理阶段会报错。（有待商榷）</li><li>建议在 reshape 前显式调用.contiguous()，否则在某些内存布局下会报错。（有待商榷）</li></ol></div>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch02 RoPE/YaRN 旋转位置编码</title>
      <link href="/2026/01/21/projects/minimind/minimind-Ch02-RoPE-YaRN-%E6%97%8B%E8%BD%AC%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/"/>
      <url>/2026/01/21/projects/minimind/minimind-Ch02-RoPE-YaRN-%E6%97%8B%E8%BD%AC%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="rope">RoPE</h2><h3 id="rope-理论">RoPE 理论</h3><p>RoPE (Rotary Position Embedding)意思是旋转位置编码，这是一种<mark class="hl-label blue">用绝对位置编码，来实现相对位置编码</mark>的算法。</p><p>首先，我们需要复习一下高中学习过的正余弦的<strong>和差化积</strong>公式：</p><p><span class="math display">\[\begin{aligned}\cos(m-n) &amp;= \cos m \cos n + \sin m \sin n \\\sin(m-n) &amp;= \sin m \cos n - \cos m \sin n\end{aligned}\]</span></p><p>关于 RoPE 的具体推导过程，可见 RoPE 论文一作苏剑林的博客<ahref="%22https://spaces.ac.cn/archives/8265%22">Transformer升级之路：2、博采众长的旋转式位置编码</a>，以下为个人的一些简单理解。</p><p>RoPE 的具体思想是，既然 Attention的核心运算是内积，那么我们<strong>希望内积的结果带有相对位置信息</strong>，因此假设存在恒等关系：<span class="math display">\[\begin{equation}\langle \boldsymbol{f}(\boldsymbol{q}, m),\boldsymbol{f}(\boldsymbol{k}, n)\rangle =\boldsymbol{g}(\boldsymbol{q},\boldsymbol{k},m-n)\end{equation}\]</span>其实，满足上述等式的解是有很多的，但是为了解简单起见，作者在推导过程中做了许多假设（似乎凭直觉已经知道了最终会是上述的三角函数的和差化积形式，因此许多假设感觉都有意往这上面靠🤔）</p><p>最终，作者得到了在 2 维情况下的解： <span class="math display">\[\begin{equation}\boldsymbol{f}(\boldsymbol{q}, m) = R_f (\boldsymbol{q},m)e^{\text{i}\Theta_f(\boldsymbol{q}, m)}= \Vert q\Vert e^{\text{i}(\Theta(\boldsymbol{q}) + m\theta)} =\boldsymbol{q} e^{\text{i}m\theta}\end{equation}\]</span> 可以看到，这相当于是将 2 维向量 <spanclass="math inline">\(\boldsymbol{q}\)</span> 逆时针旋转 <spanclass="math inline">\(m\theta\)</span> 角度。写成矩阵的形式，如下所示：<span class="math display">\[\begin{equation}\boldsymbol{f}(\boldsymbol{q}, m) =\begin{pmatrix}\cos m\theta &amp; -\sin m\theta\\ \sin m\theta &amp; \cos m\theta\end{pmatrix}\begin{pmatrix}q_0 \\ q_1\end{pmatrix}\end{equation}\]</span></p><h4 id="复数形式的检验">复数形式的检验</h4><div class="note warning flat"><p>🧀对于两个复数向量 <span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span>，它们的标准内积（对应实数向量的点积）可以写成：<span class="math display">\[\langle x, y \rangle = \text{Re}(x \cdot y^*)\]</span> 其中，<span class="math inline">\(y^*\)</span> 表示 <spanclass="math inline">\(y\)</span> 的共轭复数，<spanclass="math inline">\(\text{Re}\)</span> 表示取实部。</p></div><p>我们可以用复数的公式来进行一下检验，我们取 <spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{q}, m) = \boldsymbol{q}e^{\text{i}m\theta}, \boldsymbol{g}(\boldsymbol{k}, n) = \boldsymbol{k}e^{\text{i}n\theta}\)</span>，两者做内积，我们会有如下公式成立：</p><p><span class="math display">\[\begin{equation}\begin{aligned}\langle \boldsymbol{f}(\boldsymbol{q}, m),\boldsymbol{f}(\boldsymbol{k}, n)\rangle &amp;= \text{Re} \left((\boldsymbol{q} e^{\text{i}m\theta}) (\boldsymbol{k}e^{\text{i}n\theta})^* \right) \\&amp;= \text{Re} \left( \boldsymbol{q} \boldsymbol{k}^* \cdote^{\text{i}(m\theta - n\theta)} \right) \\&amp;= \text{Re} \left( \boldsymbol{q} \boldsymbol{k}^* \cdote^{\text{i}(m - n)\theta} \right)\end{aligned}\end{equation}\]</span></p><h4 id="矩阵形式的检验">矩阵形式的检验</h4><div class="note warning flat"><p>🧀在矩阵代数中，向量 <spanclass="math inline">\(\boldsymbol{a}\)</span> 和 <spanclass="math inline">\(\boldsymbol{b}\)</span> 的内积等于 <spanclass="math inline">\(\boldsymbol{a}^T\boldsymbol{b}\)</span>（转置乘原向量）。</p></div><p>所以，我们分别设 <spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{q}, m)\)</span> 和<span class="math inline">\(\boldsymbol{f}(\boldsymbol{k}, n)\)</span>对应的旋转矩阵为 <span class="math inline">\(\mathcal{R}_m\)</span> 和<span class="math inline">\(\mathcal{R}_n\)</span>，所以，我们有 <spanclass="math display">\[\begin{equation}\begin{aligned}\text{Score}&amp;= (\mathcal{R}_m\boldsymbol{q})^T(\mathcal{R}_n\boldsymbol{k}) \\&amp;= (\boldsymbol{q}^T\mathcal{R}_m^T)(\mathcal{R}_n\boldsymbol{k}) \\&amp;= \boldsymbol{q}^T(\mathcal{R}_m^T\mathcal{R}_n)\boldsymbol{k} \\&amp;=\boldsymbol{q}^T\left((\mathcal{R}_m^T\mathcal{R}_n)\boldsymbol{k}\right)\end{aligned}\end{equation}\]</span></p><p>旋转矩阵的转置，相当于绕反方向进行旋转对应的角度。因此，<spanclass="math inline">\(\mathcal{R}_m^T\mathcal{R}_n\)</span>相当于先逆时针旋转 <span class="math inline">\(n\theta\)</span>度，然后再顺时针旋转 <span class="math inline">\(m\theta\)</span>度，所以整体上逆时针旋转了 <spanclass="math inline">\((n-m)\theta\)</span> 度。我们将这个旋转矩阵记为<span class="math inline">\(\mathcal{R}_{n-m}\)</span>，并将其与 <spanclass="math inline">\(\boldsymbol{k}\)</span>结合一下，这样的话，与最初开始的 <spanclass="math inline">\(\boldsymbol{q}\boldsymbol{k}\)</span>相比，就等价于 <span class="math inline">\(\boldsymbol{q}\)</span> 与逆时针旋转了 <span class="math inline">\((n-m)\theta\)</span> 度的 <spanclass="math inline">\(\boldsymbol{k}\)</span> 做了内积。</p><p>但是上述的只是 2维的情况，实际的向量都是成百上千维的，那我们应该怎么处理呢？这里我们的处理方法就是<strong>两两进行分组</strong>，将<span class="math inline">\(d\)</span> 维的向量，分成 <spanclass="math inline">\(\frac{d}{2}\)</span>组，每一组都有一个唯一的基本旋转角度 <spanclass="math inline">\(\theta_i\)</span>，分别进行旋转。</p><div class="note danger flat"><p><strong><span class="math inline">\(\theta_i\)</span>的选取原则</strong></p><p>在 RoPE 中，作者沿用了 Sinusoidal 位置编码的方式，即 <spanclass="math inline">\(\theta_i = 10000^{-2i/d}\)</span></p></div><p>如果我们写成矩阵的形式，就会是下面这样： <spanclass="math display">\[\begin{equation}\scriptsize{\underbrace{    \begin{pmatrix}    \cos m\theta_0 &amp; -\sin m\theta_0 &amp; 0 &amp; 0 &amp; \cdots&amp; 0 &amp; 0 \\    \sin m\theta_0 &amp; \cos m\theta_0 &amp; 0 &amp; 0 &amp; \cdots&amp; 0 &amp; 0 \\    0 &amp; 0 &amp; \cos m\theta_1 &amp; -\sin m\theta_1 &amp; \cdots&amp; 0 &amp; 0 \\    0 &amp; 0 &amp; \sin m\theta_1 &amp; \cos m\theta_1 &amp; \cdots&amp; 0 &amp; 0 \\    \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp;\vdots &amp; \vdots \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos m\theta_{d/2-1}&amp; -\sin m\theta_{d/2-1} \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \sin m\theta_{d/2-1}&amp; \cos m\theta_{d/2-1} \\    \end{pmatrix}}_{\boldsymbol{\mathcal{R}}_m}    \begin{pmatrix}    q_0 \\ q_1 \\ q_2 \\ q_3 \\ \vdots \\ q_{d-2} \\ q_{d-1}    \end{pmatrix}}\end{equation}\]</span></p><p>可以看到，这个矩阵很是稀疏，其中的绝大部分元素都是0，只有对角线附近的数据有意义。因此，为了计算效率更高，节省内存，一般在代码层面实现的时候，我们都是用的下面这一计算方法。</p><p><span class="math display">\[\begin{equation}    \label{eq:efficient_calc}\begin{pmatrix}q_0 \\ q_1 \\ q_2 \\ q_3 \\ \vdots \\ q_{d-2} \\ q_{d-1}\end{pmatrix}\otimes\begin{pmatrix}\cos m\theta_0 \\ \cos m\theta_0 \\ \cos m\theta_1 \\\cos m\theta_1 \\ \vdots \\ \cos m\theta_{d/2-1} \\ \cos m\theta_{d/2-1}\end{pmatrix}+\begin{pmatrix}-q_1 \\ q_0 \\ -q_3 \\ q_2 \\ \vdots \\ -q_{d-1} \\ q_{d-2}\end{pmatrix}\otimes\begin{pmatrix}\sin m\theta_0 \\ \sin m\theta_0 \\ \sin m\theta_1 \\\sin m\theta_1 \\ \vdots \\ \sin m\theta_{d/2-1} \\ \sin m\theta_{d/2-1}\end{pmatrix}\end{equation}\]</span></p><p>其中 <span class="math inline">\(\otimes\)</span> 是逐位对应相乘，即Numpy、Tensorflow 等计算框架中的 <span class="math inline">\(*\)</span>运算。从这个实现也可以看到，RoPE 可以视为是乘性位置编码的变体。</p><h3 id="rope-代码实现">RoPE 代码实现</h3><h4 id="预计算位置编码信息">预计算位置编码信息</h4><div class="note danger flat"><p>注意如果 Attention 有多个头的话，RoPE是在<strong>每一个头中</strong>都要进行编码！并且<strong>每一个头的旋转位置编码都是相同的。（因为不同的头，本质上处理的还是相同位置的那些toekn，只不过处理的编码维度不同而已）</strong></p><p>代码的实现通常是：</p><p>输入 <span class="math inline">\(x\)</span> -&gt; 投影成 <spanclass="math inline">\(Q, K\)</span> -&gt; 拆分成多头 -&gt; 应用 RoPE-&gt; 计算 <span class="math inline">\(QK^T\)</span></p></div><p>首先是预先计算所有需要的正弦和余弦的值。我们输入的 tokens 的长度为<spanclass="math inline">\(l\)</span>，由于使用的是绝对位置编码，因此，我们的<span class="math inline">\(m\theta\)</span> 中的 <spanclass="math inline">\(m \in [0, l)\)</span> 我们还有一堆的 <spanclass="math inline">\(\theta_i\)</span> 需要计算，由上面所述，<spanclass="math inline">\(\theta_i =\frac{1}{\text{rope_base}^{\frac{2i}{\text{dim}}}}\)</span>所以，计算出的正余弦矩阵的形状应该是<code>[l, dim // 2]</code>。然后，为了能够正常进行计算，需要对其进行重复，像公式<span class="math inline">\(\eqref{eq:efficient_calc}\)</span>中的一样，每一个正余弦的元素都应该被重复一次。</p><p>注意在下面的公式中，我们并不是像公式 <spanclass="math inline">\(\eqref{eq:efficient_calc}\)</span>中一样是相邻的进行配对的，而是将向量分成了前后分成了两大部分，每一部分的对应位置进行配对，如公式<span class="math inline">\(\eqref{eq:efficient_calc2}\)</span>所示。</p><p><span class="math display">\[\begin{equation}    \label{eq:efficient_calc2}\begin{pmatrix}q_0 \\ q_1 \\ \vdots \\ q_{d/2-1} \\ q_{d/2} \\ \vdots \\ q_{d-1}\end{pmatrix}\otimes\begin{pmatrix}\cos m\theta_0 \\ \cos m\theta_1 \\ \vdots \\ \cosm\theta_{d/2-1} \\ \cos m\theta_0 \\ \vdots \\ \cos m\theta_{d/2-1}\end{pmatrix}+\begin{pmatrix}-q_{d/2} \\ -q_{d/2+1} \\ \vdots \\ -q_{d-1} \\ q_0 \\ \vdots \\q_{d/2-1}\end{pmatrix}\otimes\begin{pmatrix}\sin m\theta_0 \\ \sin m\theta_1 \\ \vdots \\ \sinm\theta_{d/2-1} \\ \sin m\theta_0 \\ \vdots \\ \sin m\theta_{d/2-1}\end{pmatrix}\end{equation}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">precompute_freqs_cis</span>(<span class="params">head_dim: <span class="built_in">int</span>, max_seq_len: <span class="built_in">int</span>, rope_base: <span class="built_in">float</span> = <span class="number">1e4</span>, rope_scale</span>):</span><br><span class="line">    <span class="comment"># 1 / base^(2i / dim)</span></span><br><span class="line">    <span class="keyword">assert</span> head_dim % <span class="number">2</span> == <span class="number">0</span>, <span class="string">&quot;We assume that head_dim must be even.&quot;</span></span><br><span class="line">    i = torch.arange(<span class="number">0</span>, head_dim, <span class="number">2</span>)[:head_dim // <span class="number">2</span>].<span class="built_in">float</span>()</span><br><span class="line">    exps = rope_base ** ((<span class="number">2</span> * i) / head_dim)</span><br><span class="line">    theta = <span class="number">1.</span> / exps</span><br><span class="line"></span><br><span class="line">    <span class="comment"># m\theta_0 ~ n\theta_k</span></span><br><span class="line">    t = torch.arange(<span class="number">0</span>, max_seq_len, device=theta.device)</span><br><span class="line">    angle = torch.outer(t, theta).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the length of freqs_cos and freqs_sin are both head_dim // 2, we need to expand them</span></span><br><span class="line">    <span class="comment"># cos/sin.shape = [max_seq_len, head_dim]</span></span><br><span class="line">    freqs_cos = torch.cat([torch.cos(angle), torch.cos(angle)], dim=-<span class="number">1</span>)</span><br><span class="line">    freqs_sin = torch.cat([torch.sin(angle), torch.sin(angle)], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freqs_cos, freqs_sin</span><br></pre></td></tr></table></figure><h4 id="应用位置编码">应用位置编码</h4><p>这一部分就比较简单了，只需要将公式 <spanclass="math inline">\(\eqref{eq:efficient_calc2}\)</span>翻译成代码语言即可。 <div class="note success flat"><p>Python的广播机制会将两个张量<strong>从右向左</strong>进行对齐操作，因此下方代码中的<code>q * freqs_cos.unsqueeze(1)</code> 是可以正常运算的，Python会自动给 <code>freqs_cos.unsqueeze(1)</code> 再补上一个<code>batch_size=1</code> 的维度。</p></div></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_rotary_position_embedding</span>(<span class="params"></span></span><br><span class="line"><span class="params">    q: torch.Tensor,</span></span><br><span class="line"><span class="params">    k: torch.Tensor,</span></span><br><span class="line"><span class="params">    freqs_cos: torch.Tensor,</span></span><br><span class="line"><span class="params">    freqs_sin: torch.Tensor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate_half</span>(<span class="params">x: torch.Tensor</span>):</span><br><span class="line">        <span class="comment"># [a, b] -&gt; [-b, a]</span></span><br><span class="line">        mid = x.shape[-<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> torch.cat([-x[..., mid: ], x[..., : mid]], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># q.shape = [batch_size, max_seq_len, heads, head_dim]</span></span><br><span class="line">    <span class="comment"># cos/sin.shape = [max_seq_len, head_dim] -&gt; [max_seq_len, 1, head_dim]</span></span><br><span class="line">    q_embedded = q * freqs_cos.unsqueeze(<span class="number">1</span>) + rotate_half(q) * freqs_sin.unsqueeze(<span class="number">1</span>)</span><br><span class="line">    k_embedded = k * freqs_cos.unsqueeze(<span class="number">1</span>) + rotate_half(k) * freqs_sin.unsqueeze(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q_embedded, k_embedded</span><br></pre></td></tr></table></figure><h2 id="yarn">YaRN</h2><p>YaRN (Yet another RoPE for Non-standard lengths)的出现，主要是为了解决<strong>大模型在推理时如何“低成本”且“无损”地拓展上下文长度（ContextWindow）</strong>的问题。</p><p>此处依旧参考苏剑林的博客<ahref="%22https://spaces.ac.cn/archives/9948%22">Transformer升级之路：16、“复盘”长度外推技术</a></p><h3 id="为什么会有-yarn">为什么会有 YaRN</h3><p>假设你训练了一个 Llama 2，它的训练长度是 4096 (4k)。如果你强行输入 8k的长度，RoPE 会发生什么？</p><h4 id="直接外推">直接外推</h4><p>RoPE 依赖正弦/余弦函数旋转。当位置索引 <spanclass="math inline">\(m\)</span> 超过 4096时，模型从未见过如此大的旋转角度，模型的困惑度（Perplexity）会瞬间爆炸，输出乱码。<strong>（这里应该指的是最后那一部分<span class="math inline">\(\theta_i\)</span>较小的情况，也就是低频维度，这个时候 <spanclass="math inline">\(l_{max}\theta\)</span>还没有走完一圈，因此当位置索引 <span class="math inline">\(m &gt;l_{max}\)</span> 的时候，角度 <spanclass="math inline">\(m\theta\)</span>到了从未到过的弧上，模型未训练过，因此表现的效果很差）</strong></p><div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/img/minimind/image.png","alt":"alt text"},{"url":"/img/minimind/image-1.png","alt":"alt text"}]</div>    </div><h4 id="线性插值">线性插值</h4><p><span class="math display">\[\begin{equation}\begin{aligned}&amp;\text{训练阶段}:\,(1,2,\cdots,n-1,n)\\[5pt]&amp;\text{预测阶段}:\,(1,2,\cdots,n,\underbrace{n+1,\cdots,4n-1,4n}_{\text{远处越界}})\xrightarrow{\quad\text{内插}\quad}\big(\underbrace{\frac{1}{4},\frac{2}{4},\frac{3}{4}}_{\text{局部失真}},\cdots,n-\frac{1}{4},n\big)\end{aligned}\end{equation}\]</span></p><p>然而，位置内插之后同样会有 PPL爆炸的问题。原因也不难理解，尽管位置内插避免了远处的位置越界问题，但这同时压缩了邻近Token的距离，严重扰乱了模型的局部分辨率，而众所周知语言模型本身就是一个非常依赖于局部关系的任务，所以扰乱了局部自然就没法预测准了。</p><p>以之前 4k 和 8k 的例子说明，原来两个 Token 间的距离是 1，现在变为了0.5，两个 Token的位置编码会有显著的变化<strong>（尤其是在高频维度上，这也是 YaRN的核心洞察点）</strong>，比如 <span class="math inline">\(\theta_i =\pi\)</span>，原本 <span class="math inline">\(m - n = 1 \rightarrow (m- n) \theta_i = \pi\)</span>。而现在 <span class="math inline">\(m - n =0.5 \rightarrow (m - n) \theta_i =\frac{\pi}{2}\)</span>，两者的正余弦值会有很显著的差别！因此模型的表现就会下降很多。</p><h4 id="ntk-aware-的局限">NTK-Aware 的局限</h4><p>YaRN 的作者 Bowen Peng 首先提出了 NTK-RoPE 算法。NTK-RoPE的思路很简单，仅改一下 RoPE 的 base 就行，即原本是 <spanclass="math inline">\(\theta_i = 10000^{-2i/d}\)</span>，现在改为 <spanclass="math inline">\(\theta_i = (10000\kappa)^{-2i/d}\)</span>。当时Bowen Peng 基于自己对 NTK（Neural TangentKernel）相关结果的经验，判断高频（<span class="math inline">\(i\rightarrow 0\)</span>）是学习相对距离的，所以不用改变，低频（<spanclass="math inline">\(i \rightarrowd/2−1\)</span>）是学习绝对距离的，因此要进行内插，总结起来就是“高频外推、低频内插”，于是他通过令<span class="math inline">\(i=d/2−1\)</span> 时的 Scale 正好等于内插Scale <spanclass="math inline">\(\frac{L_{train}}{L_{test}}\)</span>，得出方程<span class="math display">\[\begin{equation}(10000\kappa)^{-2i/d}|_{i=d/2-1} =\left.\frac{L_{train}}{L_{test}}10000^{-2i/d}\right|_{i=d/2-1}\end{equation}\]</span></p><p>即 <span class="math display">\[\text{新的频率} = \text{旧的频率}\times \text{线性插值系数}\]</span></p><p>计算得到 <span class="math display">\[\begin{equation}\kappa =\left(\frac{L_{test}}{L_{train}}\right)^{d/(d-2)}\label{eq:kappa}\end{equation}\]</span></p><p>回忆我们之前的线性插值，我们没有区分高频和低频，一视同仁地将它们进行了线性插值，而直觉来看，高频的部分对它进行插值会有着非常剧烈的变化，而低频部分线性插值又无关痛痒。也许低频部分影响少一些，而高频部分影响多一些，会有更好的效果。我们计算出式<span class="math inline">\(\eqref{eq:kappa}\)</span>就做了这一件事。由于 RoPE 的指数性质，改变 Base会对不同频率产生非线性的影响：</p><ul><li>对于高频 (<span class="math inline">\(i\)</span>很小)：频率变化微乎其微。 -&gt; 保留了局部注意力能力。</li><li>对于低频 (<span class="math inline">\(i\)</span>很大)：频率变化非常剧烈，被大幅压缩了。 -&gt;解决了长距离外推的问题。</li></ul><p>然而，也正是由于非线性的问题，最后一个频率匹配上了线性插值，但倒数第二个、倒数第三个这些，并没有很好的进行匹配，因此，还是会出现OOD 的问题。</p><h3 id="yarn-理论">YaRN 理论</h3><p>这一段感觉苏老师讲的太好了，我就直接拿过来引用了，绝对不是因为懒！</p><p>假设训练长度为 <span class="math inline">\(L_{train}\)</span>，那么<span class="math inline">\(m−n \in[0,L_{train}−1]\)</span>，接下来让我们充分发挥想象力：较大的 <spanclass="math inline">\(\theta_i\)</span> 意味着转速越快，周期越短，于是在<span class="math inline">\(m−n\)</span> 从 0 到 <spanclass="math inline">\(L_{train}−1\)</span>期间，它已经被转了很多圈，也就是说圆上的每一个点几乎都被训练过，因此这些<span class="math inline">\(\theta_i\)</span> 几乎不存在 OOD问题；相反，对于较小的 <span class="math inline">\(\theta_i\)</span>，当<span class="math inline">\(m−n\)</span> 从 0 到 <spanclass="math inline">\(L_{train}−1\)</span>时它可能还没转完一圈，这种情况下被训练过的点顶多只是圆上的一条弧，如果测试时遇到更大的<spanclass="math inline">\(L_{test}\)</span>，那么就超出了训练过的弧范围，从而有无法预估的表现，这时候就需要通过内插将它压缩到原本的弧内。说白了，<mark class="hl-label green">位置标号 $m−n$ 是否 OOD 根本不重要，重要的是单位圆上的点是否被充分训练过，如果是，那么就可以不做改动（直接外推），否则就要想办法将它压缩到已经被充分训练过的那段弧上（位置内插）</mark>。</p><p>具体来说，对于 <spanclass="math inline">\(\theta_i\)</span>，我们可以算出周期为 <spanclass="math inline">\(T_i =\frac{2\pi}{\theta_i}\)</span>，然后可以算出在训练过程中它所转的“圈数”为<span class="math inline">\(r_i = \frac{L_{train}}{T_i} =\frac{\theta_i}{L_{train}}2\pi\)</span>，我们可以设一个圈数的阈值 <spanclass="math inline">\(\tau\)</span>，圈数超过 <spanclass="math inline">\(\tau\)</span>的，就认为已经充分训练了，可以不加改动；圈数少于 1 的，<spanclass="math inline">\(\theta_i\)</span> 改为 <spanclass="math inline">\(\theta_i\frac{L_{test}}{L_{train}}\)</span>，意味着要把超出弧范围的重新缩放到弧内；至于剩下的部分，就在两者之间线性插值过渡。用公式表达就是：</p><p><span class="math display">\[\begin{equation} \label{eq:yarn}\theta_i^{new} = \left[\gamma_i + (1 -\gamma_i)\frac{L_{train}}{L_{test}}\right]\theta_i,\quad\gamma_i = \left\{\begin{aligned} &amp;1, &amp;r_i &gt; \tau \\&amp;0, &amp;r_i &lt; 1 \\&amp;\frac{r_i - 1}{\tau - 1},&amp;\text{others}\end{aligned}\right.\end{equation}\]</span></p><div class="note success flat"><p>YaRN 改进了 RoPE在处理超过训练长度时的插值策略，它通过区分“高频”和“低频”维度，完美解决了“长上下文拓展”和“短距离注意力保持”之间的矛盾。并且YaRN 只改变 <span class="math inline">\(\theta_i\)</span> 的值，不改变Attention 和 RoPE 的形式，因此不会有额外的实现成本和推理成本。</p></div><h3 id="yarn-代码实现">YaRN 代码实现</h3><p>根据上面的绿色框框中所述，YaRN 只是修改了 <spanclass="math inline">\(\theta_i\)</span>的值，并没有修改其他任何框架形式，因此，我们只需要在 RoPE 的<code>precompute_freqs_cis()</code> 代码中稍做添加即可。</p><p>首先，让我们规定，当转的圈数大于阈值 <spanclass="math inline">\(\beta_{fast} \triangleq \tau\)</span>时，我们不进行任何的插值处理。当圈数小于 <spanclass="math inline">\(\beta_{slow}\)</span>时，我们进行完全的线性插值。此外，一个向量的不同维度，对应转的圈数一般是不同的。因此，转的圈数与向量的维度之间存在着单调映射关系。（此处考虑的是<span class="math inline">\(\frac{d}{2}\)</span>维，也就是已经两两配对后的维度）</p><p>那么，接下来，我们需要求解出 <spanclass="math inline">\(\beta_{fast}\)</span> 和 <spanclass="math inline">\(\beta_{slow}\)</span> 分别对应的维度 <spanclass="math inline">\(i\)</span> 是多少。求解步骤如下:</p><p>首先写出 <span class="math inline">\(\theta_i\)</span>的定义式：<span class="math inline">\(\theta_i =\frac{1}{\text{base}^{\frac{2i}{\text{dim}}}}\)</span>。这也就是每相隔一个token，这个维度 <span class="math inline">\(i\)</span>会转的角度。因此，对于一整圈 <span class="math inline">\(2 \pi\)</span>来说，周期 <spanclass="math inline">\(T_i=\frac{2\pi}{\theta_i}\)</span>，<spanclass="math inline">\(T_i\)</span> 也就是一个周期所经历的 token数量。我们一共有 <span class="math inline">\(l_{max}\)</span> 个tokens，所以最多能转 <spanclass="math inline">\(\frac{l_{max}}{T_i}\)</span> 圈。因此，我们令<span class="math display">\[\frac{l_{max}}{T_i} = \beta\]</span> 代入 <span class="math inline">\(T_i\)</span> 和 <spanclass="math inline">\(\theta\)</span>，最终可以解得 <spanclass="math display">\[i = \frac{\text{dim} \cdot \log \left( \frac{l_{max}}{2 \pi\beta}\right)}{2 \log(\text{base})}\]</span> 因此可以有 <span class="math display">\[\begin{equation}i_{low} = \frac{\text{dim} \cdot \log \left( \frac{l_{max}}{2 \pi\beta_{fast}}\right)}{2 \log(\text{base})} \quadi_{high} = \frac{\text{dim} \cdot \log \left( \frac{l_{max}}{2 \pi\beta_{slow}}\right)}{2 \log(\text{base})}\end{equation}\]</span>而我们又是低维会转的快，高维的转的慢，所以我们就可以设定对应的阈值，维度低于<span class="math inline">\(i_{low}\)</span>的，不需要任何插值，维度高于 <spanclass="math inline">\({i_{high}}\)</span> 的，需要完全的线性插值；而在<span class="math inline">\([i_{low}, i_{high}]\)</span>之间的，综合两者进行插值。</p><p>注意，公式 <span class="math inline">\(\eqref{eq:yarn}\)</span> 中的<span class="math inline">\(r_i\)</span>是转的圈数，而我们这里所讨论的，都是从“向量的维度”的角度，两者恰好是倒数关系，向量维度越低，转的越快，转的圈数就会越多。因此，后面在代码实现的时候，代码中的<code>ramp</code> 实际就是公式中的 <span class="math inline">\(1 -\gamma_i\)</span> 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">precompute_freqs_cis</span>(<span class="params"></span></span><br><span class="line"><span class="params">    head_dim: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    max_seq_len: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    rope_base: <span class="built_in">float</span> = <span class="number">1e4</span>,</span></span><br><span class="line"><span class="params">    rope_scale: <span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">    <span class="comment"># 1 / base^(2i / dim)</span></span><br><span class="line">    <span class="keyword">assert</span> head_dim % <span class="number">2</span> == <span class="number">0</span>, <span class="string">&quot;We assume that head_dim must be even.&quot;</span></span><br><span class="line">    i = torch.arange(<span class="number">0</span>, head_dim, <span class="number">2</span>)[:head_dim // <span class="number">2</span>].<span class="built_in">float</span>()</span><br><span class="line">    exps = rope_base ** ((<span class="number">2</span> * i) / head_dim)</span><br><span class="line">    theta = <span class="number">1.</span> / exps</span><br><span class="line"></span><br><span class="line">    <span class="comment"># m\theta_0 ~ n\theta_k</span></span><br><span class="line">    t = torch.arange(<span class="number">0</span>, max_seq_len, device=theta.device)</span><br><span class="line">    angle = torch.outer(t, theta).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rope_scaling <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        original_max, factor, beta_fast, beta_slow, attention_factor = (</span><br><span class="line">            rope_scaling.get(<span class="string">&quot;original_max_seq_length&quot;</span>, <span class="number">2048</span>),</span><br><span class="line">            rope_scaling.get(<span class="string">&quot;factor&quot;</span>, <span class="number">16</span>),</span><br><span class="line">            rope_scaling.get(<span class="string">&quot;beta_fast&quot;</span>, <span class="number">32.0</span>),</span><br><span class="line">            rope_scaling.get(<span class="string">&quot;beta_slow&quot;</span>, <span class="number">1.0</span>),</span><br><span class="line">            rope_scaling.get(<span class="string">&quot;attention_factor&quot;</span>, <span class="number">1.0</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> max_seq_length &gt; original_max:</span><br><span class="line">            <span class="comment"># beta_fast and beta_slow are both the number of circles</span></span><br><span class="line">            inv_dim = <span class="keyword">lambda</span> b: (head_dim * math.log(original_max / (b * <span class="number">2</span> * math.pi))) / (<span class="number">2</span> * math.log(rope_base))</span><br><span class="line">            low, high = <span class="built_in">max</span>(math.floor(inv_dim(beta_fast)), <span class="number">0</span>), <span class="built_in">min</span>(math.ceil(inv_dim(beta_slow)), head_dim // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">            ramp = torch.clamp((torch.arange(head_dim // <span class="number">2</span>, device=freqs.device).<span class="built_in">float</span>() - low) / <span class="built_in">max</span>(high - low, <span class="number">0.001</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            freqs = freqs * (<span class="number">1</span> - ramp + ramp / factor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the length of freqs_cos and freqs_sin are both head_dim // 2, we need to expand them</span></span><br><span class="line">    <span class="comment"># cos/sin.shape = [max_seq_len, head_dim]</span></span><br><span class="line">    freqs_cos = torch.cat([torch.cos(angle), torch.cos(angle)], dim=-<span class="number">1</span>)</span><br><span class="line">    freqs_sin = torch.cat([torch.sin(angle), torch.sin(angle)], dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freqs_cos, freqs_sin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch01 RMSNorm 归一化层</title>
      <link href="/2026/01/21/projects/minimind/minimind-Ch01-RMSNorm-%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82/"/>
      <url>/2026/01/21/projects/minimind/minimind-Ch01-RMSNorm-%E5%BD%92%E4%B8%80%E5%8C%96%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>在本章节中，我们将要学习一个现在最常用的<strong>归一化算法</strong>，那就是<code>RMSNorm</code> 层归一化。</p><p>给定一个 <span class="math inline">\(n\)</span> 维向量 <spanclass="math inline">\(x = [x_1, x_2, ..., x_i, ...,x_n]\)</span>，输出为同样是 <span class="math inline">\(n\)</span>维的向量 <span class="math inline">\(y\)</span>，公式为： <spanclass="math display">\[y_i = \frac{x_i}{\sqrt{\frac{1}{n}\sum^n_{i=1}(x_i)^2 + \epsilon}}\]</span></p><p><span class="math inline">\(\epsilon\)</span> 的目的是防止当 <spanclass="math inline">\(x_i\)</span> 均为 0的时候，发生<strong>除零溢出</strong>的问题。这一操作在 AI算法中将会经常见到。</p><p>对应的 Python 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RMSNorm</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim: <span class="built_in">int</span>, eps: <span class="built_in">float</span> = <span class="number">1e-5</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.input_dim = input_dim</span><br><span class="line">        <span class="variable language_">self</span>.eps = eps</span><br><span class="line">        <span class="variable language_">self</span>.weight = nn.Parameter(torch.ones(input_dim))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_norm</span>(<span class="params">self, x: torch.Tensor</span>):</span><br><span class="line">        <span class="keyword">return</span> x * torch.rsqrt(torch.<span class="built_in">pow</span>(x, <span class="number">2</span>).mean(-<span class="number">1</span>, keepdim=<span class="literal">True</span>) + <span class="variable language_">self</span>.eps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor</span>):</span><br><span class="line">        x = _norm(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.weigth * x</span><br></pre></td></tr></table></figure><p>注意这里我们的 <code>.mean()</code> 需要指定<code>keepdim=True</code> 以满足广播机制的要求。因为<code>x.shape = [..., input_dim]</code>，而如果进行了取平均的操作，但不保留这个维度的话，那么<code>x_mean.shape = [...]</code>。然后我们让 <code>x</code> 去和<code>x_mean</code> 做除法，最终就会导致维度不匹配而报错。但是，如果我们使用了 <code>keepdim=True</code>，那么<code>x_mean.shape = [..., 1]</code>，依据 Python的广播机制，这两者能够进行正确的运算操作。</p><p>在代码中，我们对于归一化后的 <spanclass="math inline">\(x\)</span>，又乘以了一个可学习的权重参数 <spanclass="math inline">\(w\)</span>。这里的 <spanclass="math inline">\(w\)</span> 是一个向量，它的长度等于特征维度<code>input_dim</code>。这意味着每一个特征维度 <spanclass="math inline">\(x_i\)</span> 都会有一个属于自己的权重。</p><div class="note success flat"><p>🥖<strong>结论：</strong>归一化负责把数据“整理整齐”（方便计算），而<span class="math inline">\(w\)</span>负责让神经网络有权利“把重要的特征再放大，把不重要的特征缩小”。</p></div>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minimind-Ch00 项目介绍</title>
      <link href="/2026/01/21/projects/minimind/minimind-Ch00-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2026/01/21/projects/minimind/minimind-Ch00-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> project </category>
          
          <category> minimind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 常用快捷键（持续学习更新中）</title>
      <link href="/2025/02/26/vim-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2025/02/26/vim-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="normal-模式"><code>normal</code> 模式</h2><p><code>h</code>，<code>j</code>，<code>i</code>，<code>k</code>用来移动光标的位置，前面可以加入数字，指定一次要移动多少行，例如<code>10j</code> 表示向下移动 10 行。</p><div class="note danger flat"><p>注意，当进行了行折叠的时候，使用 <code>h</code> 和 <code>j</code>进行移动的时候会直接将整体的这一行全部移过去，因为 vim内部仍将其视为完整的一行。要想解决这一点，使得行是按我们显示的来移动，请使用<code>gj</code> 和 <code>gk</code> 命令。个人建议可以将原本的<code>j</code> 映射成 <code>gj</code> 来使用，<code>k</code> 同理！</p></div><p><strong>复制粘贴相关：</strong></p><ul><li><code>dd</code>用来删除一行，并会将删除内容放置在寄存器中供拷贝使用。如果不想让其起到类似剪切的效果，可以使用<code>"_dd</code>指令，这样只会删除，而不是剪切并覆盖寄存器。同样，前方也可以指定数字，用来表示向下要删除多少行。</li><li><code>yy</code>用来复制一行，前方可以指定数字，表示向下要复制多少行。</li><li>使用 <code>x</code>可以删除单个字符，配合可视模式下也是可以选择连续多个字符进行删除。同样，它也会将内容存放在reg 中。</li><li>使用 <code>:</code> 进入命令模式，然后输入 <code>reg</code>可以查看当前的多个寄存器存储的内容。例如 <code>"2</code> 表示<code>"2</code>这个寄存器中存储的内容。之后，如果我们想要粘贴出这个寄存器中的内容，我们可以使用<code>"2p</code> 这个命令，即在 <code>p</code>前显式指定出寄存器即可。</li></ul><p><strong>进入插入模式：</strong></p><ul><li><code>i</code> 表示 insert，在当前字符前方进入插入模式。</li><li><code>a</code> 表示 append，在当前字符后方进入插入模式。</li><li><code>I</code>将光标置于本行第一个非空字符处，并在该字符前方进入插入模式。</li><li><code>A</code>将光标置于本行最后一个非空字符处，并在该字符后方进入插入模式。</li></ul><p><strong>进入可视模式：</strong></p><ul><li><code>v</code> 可以选中当前字符串，后续可以使用 <code>NORMAL</code>模式下的其他指令来扩大想要选择的范围。</li><li><code>V</code> 进入行选中的可视化模式。</li></ul><p><strong><code>g*</code> 相关指令</strong></p><ul><li><p><code>gg</code> 跳至第一行，<code>G</code>跳至最后一行。两者可以配合 <code>V</code> 行选中指令来实现全选的操作，即<code>ggVG</code>。</p></li><li><p><code>gsp</code> 打开/关闭左侧的项目树视图</p></li><li><p><code>gd</code> 跳至函数的定义</p></li><li><p><code>gx</code> 打开光标下的网页链接🔗</p></li><li><p><code>gf</code> 打开光标下的文件</p></li><li><p><code>gcc</code> 注释当前行</p></li><li><p><code>.</code>用来重复上一次修改（或插入）的操作。前面可以指定数字来表示需要重复执行多少次。这一操作在进行大量相似文本操作的时候十分有用！</p></li></ul><h2 id="insert-模式"><code>insert</code> 模式</h2><ul><li><code>jj</code> 或 <code>&lt;Esc&gt;</code> 回到普通模式</li></ul><h2 id="visual-模式"><code>visual</code> 模式</h2><ul><li>上述的大多数移动指令都是可以配合使用的，用来选中从当前位置到移动后的位置这一片区域。</li><li>使用 <code>v</code> 或 <code>V</code>可以切换是字符选中还是行选中状态。再按一次对应的 <code>v</code> 或<code>V</code> 可以退出 <code>visual</code> 模式。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法——字符串</title>
      <link href="/2024/12/18/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/12/18/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串匹配问题">字符串匹配问题</h2><h3 id="z-算法">Z 算法</h3><p>  首先，先了解一下 Z 算法的返回值。对于一个长度为 <code>n</code>的字符串 <code>str</code>，它返回的是一个长度依旧为 <code>n</code>的数组。那么每个数组中的值代表的含义是什么意思呢——<code>z[i]</code>表示以 <code>str[i]</code> 开头的字符串与 <code>str[0]</code>开头的字符串的最长匹配长度。</p><p>  首先我们可以想到的是朴素暴力匹配，复杂度为 <spanclass="math inline">\(O(n^2)\)</span>。算法如下，测试使用<a href="https://leetcode.cn/problems/sum-of-scores-of-built-strings/description/">LeetCode2223. 构造字符串的总得分和</a> 这一道题目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumScores</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 我们不需要对以 0 开头的字符串遍历检查，因为以 0 开头的字符串肯定是和它本身完全匹配的，因此 z[0] = n</span></span><br><span class="line">        z[<span class="number">0</span>] = n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于从 1, 2, ..., n-1 索引开头的所有字符串，我们将它与从 0 开头的进行匹配，求解最大匹配长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前匹配长度为 0</span></span><br><span class="line">            <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要还相等，我们就继续检查后面的，直到不相等或者到了末尾</span></span><br><span class="line">            <span class="keyword">while</span> (s[curr] == s[i + curr] &amp;&amp; i + curr &lt; n) &#123;</span><br><span class="line">                ++curr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 赋值得到 z[i]</span></span><br><span class="line">            z[i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解 z[i] 的和，这部分与题目要求相关，可以忽略</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : z) res += val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种暴力求解的做法在 133/150 测试用例的时候 TLE 了。</p><p>  上述做法的一个显著问题在于遍历到 <code>j</code>的时候没有使用前面比如 <code>i</code>时获取到的信息，而是从头又开始全新的暴力匹配。而 Z算法就是在这一方面下手，将复杂度降到了 <spanclass="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumScores</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 未超出 [l, r)，直接复用先前计算的结果</span></span><br><span class="line">            <span class="keyword">if</span> (z[i - l] &lt; r - i) &#123;</span><br><span class="line">                z[i] = z[i - l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超出了 [l, r] 的 z-box，超出部分需要暴力匹配</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> curr_matched = <span class="built_in">max</span>(<span class="number">0</span>, r - i);</span><br><span class="line">                <span class="keyword">while</span> ((i + curr_matched &lt; n) &amp;&amp; s[curr_matched] == s[i + curr_matched]) &#123;</span><br><span class="line">                    ++curr_matched;</span><br><span class="line">                &#125;</span><br><span class="line">                z[i] = curr_matched;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 z-box</span></span><br><span class="line">                l = i;</span><br><span class="line">                r = l + z[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += z[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  上述是我第一次了解算法之后按自己理解写出来的，感觉比较好理解，因此保留在了这里。之后参考了别人的写法之后优化了一下，可读性会弱一点，但更加优雅简明了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumScores</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z[i - l] &lt; r - i)</span><br><span class="line">                z[i] = z[i - l];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                z[i] = <span class="built_in">max</span>(<span class="number">0</span>, r - i);</span><br><span class="line">                <span class="keyword">while</span> ((i + z[i] &lt; n) &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];</span><br><span class="line">                l = i;</span><br><span class="line">                r = l + z[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res += z[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  算法通过维护一个类似滑动窗口的区间 <code>[l, r)</code>作为从先前获取到的知识，表示这一区间内的所有数据是可以与从<code>str[0]</code> 开始的字符串完全进行匹配的。之后，如果我们要获取<code>z[i]</code>，从 <code>str[i]</code> 开始的字符串，要与<code>str[0]</code> 开始的字符串进行匹配，如果 <code>i</code> 位于<code>[l, r)</code> 区间内部，那么我们就可以利用 <code>[l, r]</code>以及先前的 <code>z[1 : r - l]</code> 的信息进行求解。</p><p>  要知道，<code>[l, r)</code> 这一部分完全是可以看作<code>[0, r - l)</code> 区间使用的（由定义）。之后我们有当前遍历的<code>i</code> 位于该区间，我们求它对于 <code>l</code> 的偏移长度<code>i - l</code>，之后，我们去 <code>z[i - l]</code> 找对应的数值。看<code>i + z[i - l]</code> 与 <code>r</code> 的关系：</p><ul><li>如果 <code>i + z[i - l] &lt; r</code>，说明连 <code>[l, r)</code>这一区间你都没有匹配完就开始不相等了，因此我们的 <code>z[i]</code>直接复用 <code>z[i - l]</code> 的值就可；</li><li>反之，说明对于 <code>[l, r)</code>内的所有字符，都能够匹配成功了。这个时候没办法了，我们只能对于区间外的利用从<code>str[r - l]</code> 开始进行匹配了。</li></ul><div class="note info flat"><p><code>z-box</code> 也就是 <code>[l, r)</code>这一区间就像是一个傀儡一样，它和 <code>[0, r - l)</code>这部分区间的字符完全相等，你要匹配，首先和这个傀儡进行匹配。如果你连这个傀儡都匹配不完全，那么不必劳烦本体，活直接由傀儡干，给你返回数据。如果你把傀儡匹配完全了，这个时候没办法了，因为傀儡没有后续的字符信息了，只好去找它的本体<code>[0, r - l)</code>，然后再从 <code>r - l</code>往后进行匹配了。之后，本体再把这一部分作为新的，实力更强的傀儡使用。</p></div><p>  附：对于如何判断是否与傀儡匹配完全，我们不需要暴力匹配，因为之前我们其实已经计算过了！！这里不太好解释，算法的详解可以参考<a href="https://www.bilibili.com/video/BV1it421W7D8/">灵神的视频讲解</a>  Z 算法演示可以见此<a href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm">Z算法可视化网站</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——代数</title>
      <link href="/2024/12/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BB%A3%E6%95%B0/"/>
      <url>/2024/12/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="快速幂算法">快速幂算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quick_mul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n; n /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * x % MOD;</span><br><span class="line">        x = x * x % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>其中 <code>MOD</code> 是为了防止数据溢出所做的取余操作，一般定义为<code>#define MOD 1'000'000'007</code>。其中使用 <code>'</code>分隔符使数据更加可读是 <code>C++14</code>的新特性，编译时请确保编译器支持 <code>C++14</code> 及以上！</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录4——主页部分</title>
      <link href="/2024/12/11/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%954%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E9%83%A8%E5%88%86/"/>
      <url>/2024/12/11/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%954%E2%80%94%E2%80%94%E4%B8%BB%E9%A1%B5%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="副标题一言">副标题一言</h2><p>  用了一段时间的 <code>"https://v1.hitokoto.cn"</code> 的一言API，感觉不是很适合我的风格，还是更喜欢一些网抑云系列的QAQ。因此，查看了 <code>butterfly</code> 的关于 <code>subtitle</code>部分的源代码，决定修改一下，不如不调用 <code>API</code>了，我自己整个语录集放在本地，每次随机抽一个打印出来好了，这样都是我自己收集的，百分百合我自己的胃口😋</p><p>  源码有 <code>1/2/3</code> 3 个选项，选择调用不同的 <code>API</code>获取一言。那我们再写一个 <code>4</code>的分支就好啦。稍微看懂一下源码，直接 <code>Ctrl C+V</code>复制修改一下就搞定了。</p><p>  找到 <code>subtitle.pug</code>，在相应的 <code>JS</code> 代码段添加<code>when 4</code>的判断语句（目前不是很想写这随机抽取调用部分的代码，先留个小坑，暂时用这固定的一句很喜欢的文案代替一下～）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">when <span class="number">4</span></span><br><span class="line">script.</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">subtitleType</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!&#123;effect&#125;) &#123;</span><br><span class="line">            <span class="comment">//- const from = &#x27;出自 &#x27; + data.from</span></span><br><span class="line">            <span class="keyword">const</span> sub = !&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(subContent)&#125;</span><br><span class="line">            sub.<span class="title function_">unshift</span>(<span class="string">&quot;愿有岁月可回首，且以深情共白头。&quot;</span>)</span><br><span class="line">            typedJSFn.<span class="title function_">init</span>(sub)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;subtitle&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">hitokoto</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedJSFn.<span class="title function_">run</span>(subtitleType)</span><br></pre></td></tr></table></figure><hr /><p><em>- 2025-3-2 更新</em>   闲来无事，将之前留下的坑完成了一下~<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">when <span class="number">4</span></span><br><span class="line">script.</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">subtitleType</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="string">&quot;愿有岁月可回首，且以深情共白头。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;所有的承诺到最后，都变成了一句对不起。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;实际上，有些事只有你一个人在遗憾。&quot;</span>,</span><br><span class="line">    <span class="string">&quot;风太大，把心吹凉，就再回不去以前的样子了。&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> (!&#123;effect&#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> content = !&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(subContent)&#125;</span><br><span class="line">      <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)</span><br><span class="line">      content.<span class="title function_">unshift</span>(arr[index])</span><br><span class="line">      typedJSFn.<span class="title function_">init</span>(content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;subtitle&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">hitokoto</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  typedJSFn.<span class="title function_">run</span>(subtitleType)</span><br></pre></td></tr></table></figure></p><div class="note danger flat"><p><strong><code>pug</code>代码语法是缩进敏感的，复制粘贴时注意缩进！！</strong></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——关键字</title>
      <link href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="static"><code>static</code></h2><h3 id="前置">前置🧀</h3><p>  在学习 <code>static</code> 之前，我们应该知道以下的知识点：</p><ol type="1"><li><strong>变量的作用域(scope)：</strong>表明一个变量是否能够被访问。它包含了两大部分：<ol type="1"><li><strong>局部或块作用域 (Local or Block Scope)</strong>。</li><li><strong>全局作用域 (Global Scope)</strong>。</li></ol></li><li><strong>变量的持续时间(duration)：</strong>表明一个变量何时创建以及何时销毁。它也包含了两大部分：<ol type="1"><li><strong>自动存储持续时间 (Automatic StorageDuration)</strong>（对于具有本地或块作用域的变量，出了这个作用域后就会自动销毁）。</li><li><strong>静态存储时间 (Static StorageDuration)</strong>（对于具有全局作用域的变量或带有静态说明符的局部变量（在函数或代码块中））。</li></ol></li><li><strong>链接(linkage)：</strong>确定变量是否可以在另一个文件中访问（或链接）。它有两种类型：<ol type="1"><li><strong>内部链接 (InternalLinkage)</strong>（对于具有块作用域和全局作用域 / 文件作用域 /全局命名空间作用域的变量）。</li><li><strong>外部链接 (Enternal Linkage)</strong>（对于仅具有全局作用域 /文件作用域 / 全局命名空间作用域的变量）</li></ol></li></ol><p>  <code>static</code> 既可以修饰变量，也可以修饰函数。接下来我们的<code>static</code> 关键字将从以下几个部分讲解：</p><h3 id="在结构体或类的外部使用">在结构体或类的外部使用</h3><h4 id="static-修饰的全局变量"><code>static</code> 修饰的全局变量</h4><p>  对于全局变量而言，未使用 <code>const</code> 修饰的变量的链接(linkage) 属性默认是<code>Enternal Linkage</code>。也就是说默认其他的翻译单元 (translationunit) 是可以访问的，例如如下的代码：</p><div class="note info flat"><p><strong>翻译单元 (translation unit)</strong>:</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样，我们使用 <code>extern</code> 可以使 <code>main.cpp</code>访问 <code>other.cpp</code> 中的 <code>a</code>。而若此时，我们把<code>other.cpp</code> 中的 <code>a</code> 变量加上 <code>const</code>关键字修饰，这时候在 <code>main.cpp</code>中就不能再进行访问了，会报错<strong>找不到 <code>a</code>的符号定义</strong>，因为加入 <code>const</code>修饰之后变量的链接属性就变成了<code>Internal Linkage</code>，无法在其他翻译单元中访问。但如果我们就是想要访问<code>const</code> 变量修饰的 <code>a</code> 呢？我们就要使用<code>extern</code> 关键字来强制改变 <code>a</code> 的链接属性。于是<code>other.cpp</code> 修改为以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意，对于非常量定义的全局变量，使用 <code>extern</code>关键字来表明它是可以在其他翻译单元访问是多余的，因为这是默认的 (EnteralLinkage)。例如对于上述 <code>other.cpp</code> 中，可以直接指定<code>int a = 2</code>，而不需要 <code>extern int a = 2</code>。但对于<code>const int a = 2</code> 来说，<code>extern</code>就是必不可少的了！ 同理，对于 <code>const</code>修饰的全局变量，如果我们不想让它在外部翻译单元被访问，也无需显性指定<code>static const a = 2</code>，因为对于 <code>const</code>来说这也是默认的 (Internal Linkage).</p></div><p>  因此，对于全局变量而言，<code>static</code>关键字的作用就是改变变量的链接属性。我们有了一个非 <code>const</code>修饰的全局变量，并且不想让它在其他翻译单元中访问，我们就可以使用<code>static</code> 进行修饰。这一点上功能与 <code>extern</code>关键字相对。</p><h4 id="static-修饰的局部变量"><code>static</code> 修饰的局部变量</h4><p>  局部静态变量一般都是在函数中使用（在一般的匿名代码块中使用不常见。因为匿名代码块只会在当时执行，后续无法再调用执行，且其内部的静态变量无法在代码块外部使用（作用域限制），因此一般无意义）。  还记得前面说过，局部变量是自动存储持续时间，出了相应的作用域之后就会销毁。而如果我们在这个时候使用了<code>static</code>关键字对其进行了修饰，那么就会改变它的持续时间属性，使其变为静态存储时间。<strong>其生命周期是程序的整个持续时间，这意味着它具有固定的内存位置，其值仅在程序启动之前初始化一次，如<a hred="https://en.cppreference.com/w/c/language/static_storage_duration">cppreference</a> 中所述（初始化不应与赋值混淆）。</strong>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_static_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_a</span>();  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">f_static_a</span>();   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，<code>f_a</code> 每次都是一个新的<code>int a = 0</code>，每次都是 <code>a++</code>后打印，所以每次输出的结果都是 <code>1</code>。而<code>f_static_a</code> 仅在第一次进入函数的时候声明定义 1次，拥有固定的内存位置，而不是像 <code>f_a</code>只是在当前的函数栈上分配内存。之后不会再重新初始化，所以每次调用，都是在前面基础上自增。</p><p>  此外，局部静态变量也常用在创建单例模式的类中，例如如下的代码是在类中使用静态成员变量创建单例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *instance; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton *instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>一个很有意思的问题：</strong><strong>不知道你有没有发现上述代码的一个致命<code>bug</code>——这里我们初始化了<code>instance = nullptr</code>，后续使用了 <code>Get()</code>解引用得到了该单例 <code>*instance</code>，并且随后调用了<code>Hello()</code> 这个成员函数。我们仿佛做了 <code>*nullptr</code>这样一件事情。而众所周知这样做程序应该会崩溃，并报错<code>Segmentation fault</code>。但如果运行后你会发现它能够正常打印<code>Hello</code>，看似一切正常？你知道这是为什么吗？其实答案已经藏在了<code>C++ 学习</code> 的某一篇文章中了 :-)</strong></p></div><p>可以看到，这种做法是比较繁琐的。如果我们使用静态局部变量，就可以用更少的代码实现相同的效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>全局 <code>static</code> 变量和局部 <code>static</code>变量的区别：</strong>全局静态变量虽然无法被其他的翻译单元访问，但在同一个翻译单元内部，任意的地方都能够对其进行访问。局部的静态变量只有在函数的内部有效，在函数外面无法访问，相当于比全局的静态变量还要多了一层访问权限。可以想到，既然同一个翻译单元都不一定能够访问到局部静态变量，那更不用说不同的翻译单元之间了。</p></div><h4 id="static-修饰的函数"><code>static</code> 修饰的函数</h4><p>  不考虑 <code>lambda</code> 表达式，一般函数而言都是全局的，因此对于<code>static</code>修饰的函数，行为与全局变量类似，修改的是它的链接属性。一般而言，函数的链接属性是<code>Enternal Linkage</code>，也就是可以被其他翻译单元被访问。于是，我们可以使用<code>static</code> 关键字修饰，使其限制在本翻译单元内部。</p><h3 id="在结构体或类的内部使用">在结构体或类的内部使用</h3><h4 id="static-修饰的成员变量"><code>static</code> 修饰的成员变量</h4><p>  静态成员变量在所有的实例中只有一份，也就是所有的实例共享这一个静态成员变量，对其中任意一个进行修改，都会对所有的实例的该变量产生影响。例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    e.x = <span class="number">2</span>;</span><br><span class="line">    e.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    e<span class="number">1.</span>x = <span class="number">5</span>;</span><br><span class="line">    e<span class="number">1.</span>y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    e.<span class="built_in">Print</span>();  <span class="comment">// 5 8</span></span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>(); <span class="comment">// 5 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  输出的结果是 <code>e</code> 和 <code>e1</code> 的 <code>x</code> 和<code>y</code> 都是 <code>5</code> 和 <code>8</code>。  <strong>在前面的例子中，<code>static</code> 成员（包括<code>public</code> 和 <code>private</code>）都是非常量。ISO标准禁止在类中初始化非常量静态成员。因此我们必须在类定义之后初始化它们，并注意需要省略<code>static</code> 关键字。而对于 <code>const</code>成员变量来说，它符合其他 <code>const</code> 成员变量初始化的约定，即类的<code>const</code>静态成员变量可以在声明时初始化，也可以在类声明结束时初始化，但需要注意的是，在类定义后初始化时，需要将关键字<code>const</code>添加到静态成员中。推荐在声明的同时进行初始化！</strong></p><div class="note danger flat"><p>注意我们在类或者结构体中写下的成员变量只能算<font color="red"><strong>声明</strong></font>而非定义。<font color="red"><strong>声明</font>是让编译器知道这个变量的存在以及类型</strong>。而我们需要在类或结构体的外面<font color="red"><strong>定义</strong></font>这个变量，<strong>以便在此处分配实际的内存</strong>。因此，我们需要在类或结构体的外面写下类似<code>int Entity::x</code> 这样的语句。</p></div><p>  其实严谨来说，上述代码虽然没有报错，但并不合适。实际上静态成员变量可以看作不属于任何一个实例，因为尽管没有创造实例<code>e</code> 和 <code>e1</code>，我们依旧可以访问 <code>x</code> 和<code>y</code>，因为我们在外部初始化定义了<code>int Entity::x</code>，而不是像普通成员变量一样要依靠实例来进行初始化。例如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line">    std::cout &lt;&lt; Entity::x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Entity::y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  因此，之前的代码可以写成下列的形式，这样更有助于我们理解静态成员变量在所有的实例中共享，修改其中一个会影响其余的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    Entity::x = <span class="number">2</span>;</span><br><span class="line">    Entity::y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    e.<span class="built_in">Print</span>();</span><br><span class="line">    e<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="static-修饰的成员函数"><code>static</code> 修饰的成员函数</h4><p>  与普通的成员函数不同，静态成员函数与实例无关，即它不属于任何实例，<strong>因此它没有<code>this</code>指针</strong>。如果要深入剖析原理的话，对于普通的成员函数，例如前面的<code>e.Print()</code>，编译器编译过后会变成<code>Print(e)</code>，也就是会把调用者作为第一个参数传进成员函数中，因此<code>this</code> 就会指代<code>e</code>，也因此成员函数中可以任意使用类中的变量，因为它都会由第一个参数，也就是调用者这个类实例提供。而对于静态成员函数来说，它不与任何实例有关系，即使没有实例，也是可以调用静态成员函数的，因此它没有<code>this</code> 指针，尽管仍然可以使用例如 <code>e.function</code>这种形式调用（严格来说要以 <code>className::staticFunc()</code>这种形式调用）。  由于即使没有实例，我们也可以调用静态函数，因此我们可以推断出，<font color="red"><strong>在静态成员函数中，我们不能使用普通的成员变量。</strong></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y;    <span class="comment">// declaration</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;      <span class="comment">// defination</span></span><br><span class="line"><span class="type">int</span> Entity::y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity::x = <span class="number">5</span>;</span><br><span class="line">    Entity::y = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">Print</span>();    <span class="comment">// 5 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="auto"><code>auto</code></h2><p>  <code>auto</code>可以帮助我们自动填补该变量的类型，而不需要我们手动指定，我们只需要在变量前面使用<code>auto</code> 即可，例如 <code>auto a = 5</code>。对于迭代器或<code>&lt;chrono&gt;</code>时间库等一些类型名十分冗长的数据类型来说，<code>auto</code>十分好用，可以直接为我们指定出应有的类型。  当然，它是一把双刃剑，也会有不好的一面。考虑如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,  world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = name.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码可以正常运行并输出，<code>name</code> 的类型是<code>std::string</code>。但是考虑如果我们把 <code>getName()</code>的返回类型改为<code>char *</code>，这个时候事情就不一样了。<code>name</code>的类型被改为了 <code>char *</code>，而后面的 <code>name.size()</code> 是<code>std::string</code> 才有的成员函数，因此就会报错！  而若我们使用的是<code>std::string name = getName()</code>，这里就没问题了。因为最坏的情况下你修改了函数的返回值，类型不兼容会报错，我们修改成对应的类型即可。但好的情况编译器会为我们做隐式类型转换，将<code>char *</code> 转为 <code>std::string</code>，程序依旧能正常运行。  并且 <code>auto</code>使用过多后我们不方便知道一个变量到底是什么类型，例如上方，我们可能要去查看<code>getName()</code> 的返回类型，之后才能确定 <code>name</code>的类型，当然现在大多数的代码编辑器支持鼠标悬停查看类型。但始终也不如直接显性规定变量类型，一眼看上去就知道要来的快。  下面再举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;<span class="built_in">getDeivce</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> dm;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; dm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DeviceManager *dm = <span class="keyword">new</span> DeviceManager;</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;d = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> d2 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;d3 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> deviceType = std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;;</span><br><span class="line">    <span class="type">const</span> deviceType &amp;d4 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; deviceType2;</span><br><span class="line">    <span class="type">const</span> deviceType2 &amp;d5 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，这个 <code>dm</code>的类型是一个很长很长的类型，我们有以上的几种方法可以来实现对类型的声明。第一种就是正常的写法，全部写出来。第二种和第三种使用<code>auto</code> 关键字自己确定。第四种使用 <code>using</code>起类型别名。而第五种则是用 <code>typedef</code> 起类型别名。</p><div class="note danger flat"><p><strong>注意，使用 <code>auto</code> 关键字内部并不会给你自动指定<code>const</code> 和引用<code>&amp;</code>，尽管你函数的返回值表明了常量引用。因此上述第二种仅仅只是声明了这个类型，并没有加<code>const &amp;</code>，第三种才是 <code>auto</code>的正确写法！</strong></p></div><h2 id="宏-macros">宏 <code>macros</code></h2><p>  宏的本质就是替换，在正式执行编译之前，编译器会进行预处理操作，把所有的宏替换成你所在后面定义的语句。这个过程就是纯文本的查找与替换。例如如下例子就能很好的说明这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_CURLY &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> OPEN_CURLY</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码依旧能够正常编译运行。在这段代码中，我们做了一个很疯狂的操作，我们用宏<code>OPEN_CURLY</code> 来代替左花括号<code>&#123;</code>，因此，之后在任何能够使用到 <code>&#123;</code>的地方，我们都可以把它替换成 <code>OPEN_CURLY</code>。</p><p>  当然，这不是宏的正确打开方式！宏至少有以下的几种用法：</p><ul><li>将常用的函数用宏来代替，减少了代码量。注意最好是一些可读性较强的代码，替换成宏之后意义依旧十分明确，否则还要去跟踪宏的定义看看到底实现的是什么功能。因此这一用法尽量少用！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p><strong>一般来说，定义的宏值后面的代码语句不要添加<code>;</code>，而是在实际使用时在宏的后面添加。</strong>例如<code>LOG("");</code>。因为如果在定义宏的时候添加了<code>;</code>，那么后续使用的时候如果不加，是正确的做法，但是对于<code>C++</code> 来说，一般所有的代码语句都要以 <code>;</code>结尾。因此一个宏后面没有<code>;</code>，就会显得很突兀。而如果加了的话，就相当于一个语句后面有 2个 <code>;</code>，造成了一个空语句。</p></div><ul><li>与 <code>#if</code> 配合食用用于快速注释多行代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样的话，<code>#if 0</code> 和 <code>#endif</code>之间的所有代码都不会被执行。</p><ul><li>切换程序的运行版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PRO_DEBUG == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PRO_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们希望在程序的调试阶段，打印一些运行信息来观察程序执行是否有误。而在发行版本中，就不要打印任何信息。我们可以利用宏来快速完成这一点。也就是说在<code>DEBUG</code> 阶段，<code>LOG()</code> 函数被定义成一个<code>std::cout</code> 的实现，而在 <code>RELEASE</code> 下，我们让<code>LOG()</code> 为空，不要执行任何功能即可。</p><p>  使用<code>g++ -std=c++17 -DPRO_DEBUG=1 main.cpp -o main &amp;&amp; ./main</code>来运行上述代码，可以观察到打印出了信息。而当我们使用<code>g++ -std=c++17 -DPRO_RELEASE main.cpp -o main &amp;&amp; ./main</code>，程序就不会有任何输出。而如果我们不定义这两者之一，程序就会报错，因为找不到<code>LOG</code> 宏定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main &amp;&amp; ./main              </span><br><span class="line">main.cpp:14:5: error: use of undeclared identifier &#x27;LOG&#x27;</span><br><span class="line">    LOG(&quot;Hello, world&quot;);</span><br><span class="line">    ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><div class="note info flat"><p>使用 <code>g++</code> 时，通过<code>-D&lt;MACROS&gt;=&lt;VALUE&gt;</code>的参数可以为我们在编译执行代码的时候往程序里添加一个或多个宏定义。其中<code>=&lt;VALUE&gt;</code>部分可选，即我们可以只定义该宏，而不指定其为任何值。</p></div><h2 id="模板-template">模板 <code>template</code></h2><h3 id="模板的概念">模板的概念</h3><p>  模板 <code>template</code> 指 <code>C++</code>程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。<code>C++</code>的标准库提供许多有用的函数大多结合了模板的观念，如 <code>STL</code> 以及<code>IO Stream</code>。  例如对于如下的代码，如果我们不使用模板，而我们想对不同的类型，例如<code>int</code>、<code>std::string</code> 以及 <code>double</code>写一个函数进行打印，那么就得写多个 <code>Print</code>函数，其接收的参数不同，因此可以对其进行重载。  可以看到，这种方式要多写很多的代码，明明每个函数内部的代码都是相同的，仅仅是接收的参数类型不同而已。我们能不能将参数的数据类型也指定成为一个参数<code>T</code>，然后编译的时候由 <code>Print()</code>函数接收的参数的数据类型对这个参数 <code>T</code> 进行填值，生成对应的<code>Print</code> 函数呢？答案是可以的，模板就是来干这个的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">double</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板的使用">模板的使用</h3><p>  我们首先需要在要定义的函数前面声明这是一个模板函数，通过<code>template &lt;typename T&gt;</code> 可以做到这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用模板要注意的地方">使用模板要注意的地方</h3><p>  <font color="darkred"><strong>注意，如果并没有调用<code>Print()</code> 函数，那么 <code>Print()</code>函数并不会被创建出来。只有调用的时候，编译器才会将对应参数类型的<code>Print</code> 函数创建出来。例如我们调用了<code>Print(5)</code>，那么 <code>void Print(int value) &#123;&#125;</code>这个函数就会被创建出来。而不调用 <code>Print("hello")</code>之前，<code>void Print(const char *value) &#123;&#125;</code>是不存在的！</strong></font></p><p>  要证明这一点，我们可以通过如下的代码验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  很明显 <code>void Print(T value)</code> 函数内部有错误，我们把<code>value</code> 故意改成了<code>val</code>，如果这个函数在编译阶段被创建出来了的话，那么编译器会因为找不到<code>val</code>变量而报错的。但是我们编译执行，发现并没有错误！因为我们没有任何调用<code>Print</code> 的地方，因此这个函数并不会被创建出来。</p><div class="note warning flat"><p><strong>注意，普通函数即使不被调用，如果函数内部实现有错误，编译器仍然会报错，因为普通函数即使没有被调用，但也是会被创建出来的。</strong></p></div><p>  因此，模板的实现原理就是：我们有了一个被标记为模板函数的函数，编译器执行到这里的时候并不会将其进行创建，因为编译器也不知道要创建接收什么数据类型的函数。直到我们后续的函数中有了一个使用这个模板函数的地方，编译器便会对传入的参数进行类型推断，比如推断出<code>5</code> 是一个<code>int</code>，因此，它会回去<strong>由模板函数创建出一个接收参数为<code>int</code> 类型的普通函数</strong>。之后又遇见了接收<code>"hello"</code> 的模板函数，它推断 <code>"hello"</code> 是一个<code>const char *</code>，因此就会创建一个<code>void Print(const char *)</code> 的普通函数。</p><p>  由上述我们可以发现，我们传入的参数都是由编译器自己进行推断的。这在大多数情况下都很方便，但有些时候可能与我们所设想的不同。例如，之前我们所传入的<code>"hello"</code> 我们可能希望它是一个 <code>std::string</code>而不是 <code>const char *</code>，因为我们可能想在函数内部调一些例如<code>.size()</code> 等只有 <code>std::string</code>这些类才有的成员函数。因此，我们可以显性指定要用什么类型的模板函数，只要像<code>Print&lt;int&gt;(5)</code>、<code>Print&lt;std::string&gt;("hello")</code>这样写即可。</p><h3 id="在类中使用模板">在类中使用模板</h3><p>  在 <code>C++</code> 中，以下的代码是不被允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>因为在普通函数中定义数组时，<code>size</code>可以是编译时常量或允许的动态大小，视编译器和语言标准而定。而在类中，数组的大小必须<font color="red">在编译时已知</font>，不能使用非静态成员变量来定义，因此需要采用其他方法来管理动态大小数组。</strong></p><p>  例如，以下是几种解决方法：</p><ul><li>动态分配内存：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] array; <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>std::vector</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; array; <span class="comment">// 使用 std::vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">array</span>(size) &#123;&#125; <span class="comment">// 初始化 vector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  而在这一节，我们要提出第三种方法，那就是使用模板。因为前面说了，在类中定义数组的时候，其大小必须是编译时可以确定大小的数据。而前前面我们又说了，模板就是在编译期间确定其具体的数据类型。<strong>因此两者完美契合！！！</strong>这里我们可以引申一下，因为模板不仅可以通过<code>&lt;typename T&gt;</code>来将数据类型作为参数在编译期间确定，也可以将一些常用类型的变量具体值作为参数。例如<code>template &lt;int N&gt;</code>，我们就指定了一个 <code>int</code>类型的变量 <code>N</code>，其大小会编译期间确定下来。所以，我们的<code>Array</code> 可以像如下代码这样定义和使用（我们同时将<code>array</code> 的数据类型也从 <code>int</code> 变为模板<code>T</code>，因此可以接收 <code>std::string</code>等的类型！此外还实现了一些小功能，例如支持下标索引，打印数组元素等）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[] (<span class="type">int</span> index) &#123; <span class="keyword">return</span> array[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T array[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Array&lt;std::string, <span class="number">5</span>&gt; arr1;</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    arr1[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    arr1[<span class="number">4</span>] = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main -Wall &amp;&amp; ./main</span><br><span class="line">hello , world ! ? </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="explicit"><code>explicit</code></h2><p>  使用 <code>explicit</code>指定构造函数或转换函数（<code>C++11</code>起）是显式的，也就是说，它不能用于隐式转换和拷贝初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>) &#123;&#125;      <span class="comment">// converting constructor</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>) &#123;&#125; <span class="comment">// converting constructor (C++11)</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK: copy-initialization selects A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects A::A(int)</span></span><br><span class="line">    A a3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK: copy-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (a1) &#123; &#125;    <span class="comment">// OK: A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na1 = a1; <span class="comment">// OK: copy-initialization selects A::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> na2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(a1); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects B::B(int)</span></span><br><span class="line">    B b3 &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;   <span class="comment">// OK: direct-list-initialization selects B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // error: copy-list-initialization does not consider B::B(int, int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast</span></span><br><span class="line">    <span class="keyword">if</span> (b2) &#123; &#125;    <span class="comment">// OK: B::operator bool()</span></span><br><span class="line"><span class="comment">//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()</span></span><br><span class="line">    <span class="type">bool</span> nb2 = <span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(b2); <span class="comment">// OK: static_cast performs direct-initialization</span></span><br><span class="line"> </span><br><span class="line">    [](...)&#123;&#125;(a4, a5, na1, na2, b5, nb2); <span class="comment">// suppresses “unused variable” warnings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>if (b2) { }</code>语句是合法的，因为条件语句中的表达式可以使用显式转换运算符<code>operator bool()</code>。<code>C++</code> 语言允许在控制流语句（如<code>if</code>）中使用显式转换，因为这是一种上下文相关的转换。尽管<code>operator bool()</code> 是显式的，但在 <code>if</code>语句的上下文中，编译器会尝试调用它。</li><li>而 <code>bool nb1 = b2;</code>这一行代码会导致编译错误。原因是赋值操作中使用了拷贝初始化。拷贝初始化是指编译器尝试将<code>b2</code> 转换为 <code>bool</code> 类型，但由于<code>operator bool()</code> 是显式的，编译器不会在这里进行调用。为了从<code>B</code> 转换到 <code>bool</code>，必须使用显式转换。</li></ul></div><h2 id="const"><code>const</code></h2><h3 id="常规用法">常规用法</h3><p>  对于常规的变量来说，使用 <code>const</code>关键字修饰后，就表示你自己做了承诺，这个值将不会被修改，后续都会作为一个常值被使用。例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针中的用法">指针中的用法</h3><p>  对于指针来说，会有两种意义的<code>const</code>。因为我们可以想到：</p><ul><li>一方面，<strong>指针的指向是可变的，我可以让它指向这块内存，也可以让它指向另一块内存。</strong></li><li>此外，<strong>对于指向的某一块具体内存，其指向的内容也是可变的，我们可以通过解引用来修改地址中存储的值。</strong></li></ul><p>  因此，这种用法的 <code>const</code>根据其修饰的位置不同，会有两种完全不同的意义。</p><p>  如果我们想要其<strong>指针的指向固定不变</strong>，我们要在<code>*</code> 的后面添加 <code>const</code>，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这句代码仍然是正确的</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时下面的代码是错误的，因为它试图改变指针的指向</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>  而如果我们想要指向的内存中的内容数据是固定不变的，我们要在<code>*</code> 的前面添加<code>const</code>，例如如下的两种方法都是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为它试图修改内存中的数据</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>   <code>const</code> 大杂烩：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的 3 个 const 分别用 0), 1), 2) 从左往右进行表示</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> <span class="title">get_ptr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// m_ptr = 0x2;        // 2) 处的 const 错误——试图在标记为 const 的成员函数内修改成员变量的值</span></span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e;</span><br><span class="line">    <span class="comment">// int *p = e.get_ptr();       // 0) 处的 const 错误——试图用 const int * 初始化 int *，这会丢失 const 限定符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p = e.<span class="built_in">get_ptr</span>();</span><br><span class="line">    <span class="comment">// *p = 20;                    // 1) 处的 const 错误，试图对内存数据进行修改，int * const 保证内存数据不可被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  一点有意思的事情：我们可以声明定义一个常量，例如<code>const int a = 10;</code>，此时，我们直接修改 <code>a</code>是会报错的。但我们可以取 <code>a</code> 的地址，然后用普通的<code>int *</code> 来接收它。但这时候还是会报错，因为<code>&amp;a</code> 是 <code>const int *</code> 类型，无法用<code>int *</code>接收。于是我们可以硬着头皮强制转换！然后转成了普通指针，这个时候就能修改<code>p</code> 指向的内存的数据，也就是 <code>a</code>的值了？这种行为是未定义的行为！说不准会有什么现象，取决于不同的编译器以及一些优化策略。例如，下面是我在<code>MacOS</code> 上用 <code>g++</code>（其实本质还是<code>Clang</code>）的代码和运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *(&amp;a) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out                               </span><br><span class="line">0x16b1872c8</span><br><span class="line">0x16b1872c8</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>  可以看到，<code>a</code> 的地址和 <code>p</code> 是相同的，但解引用<code>p</code> 可以得到修改后的 <code>20</code>，但是这个时候打印<code>a</code>，仍然会得到<code>10</code>。神奇诶！emmm…还是不要这么做了——<spanstyle="font-size: 20px; color: red"><strong><em>You’re treadingdangerouswaters…</em></strong></span>这里有一篇<a href="https://stackoverflow.com/questions/771100/changing-the-value-of-a-const-pointer">帖子</a>就是说这个事情的。</p><h3 id="类中的用法">类中的用法</h3><p>  在类中使用，多在成员函数中使用。如果我们想要标记一个成员函数，它的内部不会修改成员变量的值，那么就可以在这个函数的参数列表之后添加<code>const</code> 关键字。多用于 <code>getter</code> 函数中使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="type">int</span> data)</span> : m_data(data) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_entity</span><span class="params">(<span class="type">const</span> Entity &amp;e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">get_data</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_entity</span>(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但一般来说建议提供 <code>getter()</code> 函数的 <code>const</code>和非 <code>const</code> 两种版本。因为比如对于上面的<code>print_entity(const Entity &amp;e)</code>函数，它接收的是常量引用类型的传入参数，这个时候，如果它的内部调用了<code>e.get_data()</code>，那么这个 <code>get_data()</code>函数必须是要被标记为 <code>const</code>的！！否则，就会出现以下的问题：我明明在参数列表中承诺这个函数接收的是<code>const &amp;</code> 类型，也就是我内部是不会修改 <code>e</code>以及它的成员变量的。但是！如果你内部的成员函数没有承诺这一点，而利用自己的非<code>const</code>属性修改了成员变量……事情就会变得令人困惑了——我这个函数<code>print_entity()</code> 确实没修改<code>e</code>，但是我内部调用的其他函数 <code>e.get_data()</code>修改了 <code>e</code>。因此，为了避免这一情况发生，请给<code>const &amp;</code> 传入参数 <code>e</code> 调用的成员函数都加上<code>const</code> 修饰！</p><h2 id="mutable"><code>mutable</code></h2><p>  <code>mutable</code>关键字用来显性指定一个变量或者函数的内部的某些变量是可以 “被修改”的。一般来说，<code>mutable</code> 关键字有两种用法。</p><ul><li>一种是在类中。我们知道，类中的成员函数如果声明了 <code>const</code>关键字，那么它内部是不可以对成员变量的值进行修改的。有些时候，我们确实需要某些成员变量是可以被修改的，而其他的变量不应该被修改。因此，问题就变成了<strong>如何在仍然保持函数实现是<code>const</code>的情况下，允许某些变量是可以被修改的？</strong>通过在我们想要修改的成员变量前添加<code>mutable</code> 关键字就可以做到这一点！</li><li>第二种是在 <code>lambda</code> 表达式中。这一点可以详见 《C++学习——内存》 部分的函数指针章节。在最后我们拓展出了 <code>lambda</code>表达式，并在那里说明了一些问题，使用到了 <code>mutable</code>关键字。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-1-shell</title>
      <link href="/2024/11/27/Unix-1-shell/"/>
      <url>/2024/11/27/Unix-1-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="shell">Shell</h2><h3 id="查看当前系统下的-shell">查看当前系统下的 <code>shell</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat etc/shells</span><br></pre></td></tr></table></figure><h3 id="查看当前使用的-shell">查看当前使用的 <code>shell</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><h3 id="常用的快捷键">常用的快捷键</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>Ctrl + p</code></td><td>显示上一条命令，同方向键上</td></tr><tr><td><code>Ctrl + n</code></td><td>显示下一条命令，同方向键下</td></tr><tr><td><code>Ctrl + b</code></td><td>光标向后移动一格，同方向键左</td></tr><tr><td><code>Ctrl + f</code></td><td>光标向前移动一格，同方向键右</td></tr><tr><td><code>Ctrl + a</code></td><td>将光标置于最开始的位置</td></tr><tr><td><code>Ctrl + e</code></td><td>将光标置于末尾的位置</td></tr><tr><td><code>Ctrl + u</code></td><td>清空当前写下的命令</td></tr><tr><td><code>Ctrl + d</code></td><td>删除后面的一个字符，同 <code>delete</code></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">closestRoom</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = rooms.<span class="built_in">size</span>(), k = queries.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> comp = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[a][<span class="number">1</span>] &gt; rooms[b][<span class="number">1</span>] || rooms[a][<span class="number">1</span>] == rooms[b][<span class="number">1</span>] &amp;&amp; rooms[a][<span class="number">0</span>] &gt; rooms[b][<span class="number">0</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indices</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            indices[i] = i;</span><br><span class="line">        <span class="built_in">sort</span>(indices.<span class="built_in">begin</span>(), indices.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            std::cout &lt;&lt; indices[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> pref = queries[i][<span class="number">0</span>], min_size = queries[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> min_gap = INT_MAX, id = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; </span><br><span class="line">                <span class="type">int</span> idx = indices[j];</span><br><span class="line">                <span class="keyword">if</span> (rooms[idx][<span class="number">1</span>] &gt;= min_size) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (min_gap &gt;= <span class="built_in">abs</span>(rooms[idx][<span class="number">0</span>] - pref)) &#123;</span><br><span class="line">                        min_gap = <span class="built_in">abs</span>(rooms[idx][<span class="number">0</span>] - pref);</span><br><span class="line">                        id = rooms[idx][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——算法</title>
      <link href="/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法部分">算法部分</h2><h3 id="排序算法">排序算法</h3><p>  <code>C++</code> 内部集成了排序算法，即<code>std::sort()</code>，时间复杂度为 <spanclass="math inline">\(O(NlogN)\)</span>。具体的使用见下面的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());      <span class="comment">// output: 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());     <span class="comment">// outpupt: 6, 5, 4, 3, 2, 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;); <span class="comment">// output: 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 4</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;        <span class="comment">// output: 2, 3, 4, 5, 6, 1</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   对于类似 <code>case 3</code> 中的 <code>lambda</code>表达式，如果返回值为 <code>true</code>，表示 <code>a</code> 和<code>b</code> 不交换位置，否则交换位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习——杂项</title>
      <link href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="c-的参数计算顺序"><code>C++</code> 的参数计算顺序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; (a + b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sum</span>(value++, value++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">main.cpp:5:1: warning: non-void function does not return a value [-Wreturn-type]</span><br><span class="line">&#125;</span><br><span class="line">^</span><br><span class="line">main.cpp:9:14: warning: multiple unsequenced modifications to &#x27;value&#x27; [-Wunsequenced]</span><br><span class="line">    sum(value++, value++);</span><br><span class="line">             ^        ~~</span><br><span class="line">2 warnings generated.</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">0 + 1 = 1</span><br></pre></td></tr></table></figure><p>  可以看到，程序在编译的时候就会报出警告，说对 <code>value</code>存在多个无序的修改。也就是说这种行为是未定义的(undefined)，取决于运行的平台以及编译器优化等等。因此并不能给出具体的计算顺序以及结果。<div class="note info flat"><p>但是从 <code>C++17</code>起，规定了后缀表达式必须按顺序进行计算。因为对于上述的两个<code>value++</code>，如果编译器存在优化，这两个参数很有可能是会并行计算的，也就是两者互不干扰，可能会出现<code>0 + 0 = 0</code> 的情况。<strong>但 <code>C++17</code>中明确表示两个后缀表达式必须按顺序进行计算。但是具体是按什么顺序并没有明说，也就是这种行为实际上还是未定义的。</strong></p></div></p><h2 id="c-中的空指针"><code>C++</code> 中的空指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity *parent, std::string name) : <span class="built_in">parent</span>(parent), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity *entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="literal">nullptr</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// part 1</span></span><br><span class="line">    std::cout &lt;&lt; entity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>)entity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; ((Entity *)((<span class="type">uint64_t</span>)entity))-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(entity) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// part 2</span></span><br><span class="line">    Entity *e = <span class="literal">nullptr</span>;</span><br><span class="line">    std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    e-&gt;<span class="built_in">printType</span>();     <span class="comment">// equal to: (*e).printType();</span></span><br><span class="line">    e-&gt;<span class="built_in">printName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述的代码中，<code>part 1</code> 是我用来验证自己平台的指针都是 64位的。<code>part 2</code> 就比较有意思了，如果我们设置 <code>e</code>为空指针<code>nullptr</code>，然后调用它的两个成员函数，神奇的是，<code>e-&gt;printType()</code>能够正常输出 <code>"Entity"</code> 字符串，而<code>e-&gt;printName()</code> 就会报段错误<code>Segmentation Fault</code>。为什么会这样呢？两者不都是它的成员函数吗？  首先，一般对于编程语言来说，定义了一个类的实例<code>e</code>，然后编写它的成员函数<code>member_fn(arg1, arg2)</code>，自己调用的时候是<code>e.member_fn(arg1, arg2)</code>，实际上底层处理的时候是这样的——<code>member_fn(e, arg1, arg2)</code>，即并没有谁调用这一说，都是把调用者作为第一个参数传了进去。上述的代码等价于<code>C</code> 语言时期的下面代码（仅演示在 <code>C</code>中结构体内部不可声明函数类型的特性）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(Entity *e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity *e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e-&gt;name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这也是 <code>C++</code> 处理后可以得到的代码。因此，对于<code>printType()</code> 来说，尽管你传入进来了<code>nullptr</code>，但在内部并没有实际解引用它的值，因此不会引起段错误。而在<code>printName()</code> 中，你试图对 <code>nullptr</code>指向的再进行偏移后 <code>name</code>所在的地址进行解引用，这显然就会引起段错误了。<strong>因此，本质上在于我们对一个非法内存解引用获取成员变量。</strong></p><p>  接下来不妨再来说说 <code>e-&gt;name</code>这类获取成员变量实现的原理。   <code>e-&gt;name</code>这类获取成员变量，实际上就是取了一个偏移量。例如，对于下述的代码如果一个<code>Entity *</code> 指针的指向地址为 <code>0xf0e1b0</code>，那么<code>parent</code> 变量的地址就是 <code>0xf0e1b0</code>，而<code>name</code> 的地址就是<code>0xf0e1b0 + 0x8 = 0xf0e1b8</code>，因为 <code>parent</code>的大小为 8字节，我们跳过它就可以了。可以看到，我们此处获取的是绝对地址，那如果我们想获取相对地址，也就是偏移量呢？一种方法是我们减去基地址，例如获取<code>name</code> 的偏移量，就是它的地址 <code>0xf0e1b8</code>减去基地址 <code>0xf0e1b0</code> 得到 8字节，但这种方法还是会涉及减法运算操作，不够高效。</p><p>  其实 <code>C++</code> 内部有 <code>offsetof</code>函数，它接收两个参数，第一个是类的类型，第二个是类中的成员变量，返回值就是这个成员变量在这个类中的偏移量。它的实现就十分的巧妙了。思想是：<font color="darkred"><strong>我们仍然用绝对地址，但是我们怎么能够让绝对地址表示的相当于是相对地址呢？没错，我们让它的基地址是0 就可以了！！</strong> </font> 我们将基地址 <code>0x0</code> 强制转为<code>Entity *</code>指针类型，然后取它相应的成员变量，注意一定要取地址，不可解引用！！否则会造成段错误！！这就是这个成员变量的绝对地址，又因为它的基地址是<code>0x0</code>，因此偏移量就是绝对地址本身啦。两种方法的代码示例见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity *parent, std::string name) : <span class="built_in">parent</span>(parent), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity *entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="literal">nullptr</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;parent offset: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Entity, parent) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name offset: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Entity, name) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 1</span></span><br><span class="line">    std::cout &lt;&lt; ((<span class="type">u_int64_t</span>)&amp;(entity-&gt;name) - (<span class="type">uint64_t</span>)entity) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 2</span></span><br><span class="line">    std::cout &lt;&lt; &amp;(((Entity *)<span class="number">0</span>)-&gt;name) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">u_int64_t</span>)&amp;(((Entity *)<span class="number">0</span>)-&gt;name) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">allocating 32 bytes</span><br><span class="line">parent offset: 0</span><br><span class="line">name offset: 8</span><br><span class="line">8</span><br><span class="line">0x8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="如何在一个函数中返回多个值">如何在一个函数中返回多个值</h2><p>  在 <code>C++</code> 中，一个函数只能返回一个数据类型，例如返回一个<code>int</code> 或返回一个<code>std::string</code>，那如果我们想要返回多个数据，例如一个同时返回一人的名字<code>std::string</code> 类型，同时 Ta 的年龄 <code>int</code>类型呢？至少有以下几种方式可以做到在 <code>C++</code>中返回多个数据：</p><ul><li><strong>将输出作为 ”传出参数“以指针或者引用的方式传进这个函数中。</strong>这也是许多 <code>C</code>库函数以及 <code>Unix</code> 系统调用的做法，例如创建一个管道<code>int pipe(int fd[2])</code>，其函数返回值是<code>int</code>，<code>-1</code> 表示创建失败，而 <code>0</code>表示创建成功。而创建成功的话写端就是 <code>fd[1]</code>，读端就是<code>fd[0]</code>。这两个 <code>fd</code>就是作为传出参数进入函数中，赋完值之后再在后续进行使用，因此也是函数的返回值的一部分。</li></ul><div class="note info flat"><p>函数的参数可以分为 “传入参数” 和 “传出参数”。“传入参数”仅仅只是为函数正常执行提供必要的数据，通常直接是数据类型，或者为了避免拷贝使用<code>const &amp;</code>形式。这种参数仅在内部使用，不会在函数返回的后续继续使用。而 “传出参数”则是要在函数执行过程中得到所需的值并保存起来，后续要在函数返回后使用这个值，可以说函数的执行大部分目的就是为了得到值并把它赋给对应的传出参数。因此，传出参数多是以指针或者引用的方式传进函数内部。</p></div><ul><li><p><strong>使用数组或者 <code>vector</code> 或者 <code>array</code>等，将多个返回值塞进一个容器中整体返回。</strong>这种的弊端是所有的返回值的类型必须相同，才能够塞进一个容器中。</p></li><li><p><strong>使用 <code>pair</code> 或者<code>tuple</code>。</strong>这种比较常见，相比于上面的优点是数据可以是不同的类型了，例如如下的代码：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::tuple&lt;std::string, <span class="type">int</span>&gt; person = <span class="built_in">createPerson</span>();</span><br><span class="line">    std::string name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">    <span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">    std::string name2;</span><br><span class="line">    <span class="type">int</span> age2;</span><br><span class="line">    std::<span class="built_in">tie</span>(name2, age2) = <span class="built_in">createPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  但是缺点是访问起来较为麻烦，要使用<code>std::get&lt;index&gt;(pair | tuple)</code> 进行访问。对于<code>pair</code> 由于只有两个元素，因此也可以使用 <code>.first</code>以及 <code>.second</code> 访问。虽然也可以使用<code>std::tie</code>，但也比较麻烦。但后续的新特性 <code>C++17</code>中引入了<strong>结构化绑定 (structed binding)</strong>，这个用起来类似于<code>Python</code> 的多返回值处理，还是比较方便的。</p><ul><li><strong>使用结构体。</strong>我们还可以将所有要返回的值构造一个结构体，之后返回的时候只需要用相应的值填好一个结构体，然后返回结构体即可。这种方法的好处是相比于前面的这种靠索引的方法相比更加直观，我可以清晰的知道我在用的是什么，例如<code>ret.name</code> 说明我正在用 <code>name</code>的数据。放在前面使用索引，我可能是<code>std::get&lt;0&gt;(ret)</code>，我必须要记住参数顺序，索引<code>0</code> 表示的是 <code>name</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCombinations</span><span class="params">(vector&lt;string&gt;&amp; pieces, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pieces.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">table</span>(<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;position : positions) &#123;</span><br><span class="line">            table[position[<span class="number">0</span>]][position[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 2 3</span></span><br><span class="line">        <span class="comment">// 4 5 6</span></span><br><span class="line">        <span class="comment">// 7 8 9</span></span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&gt;&gt; <span class="built_in">dest</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pieces.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = positions[i][<span class="number">0</span>], y = positions[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (pieces[i] == <span class="string">&quot;rook&quot;</span> || pieces[i] == <span class="string">&quot;queen&quot;</span>) &#123;</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">6</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>, y));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x, <span class="number">8</span>));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, y));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pieces[i] == <span class="string">&quot;queen&quot;</span> || pieces[i] == <span class="string">&quot;bishop&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x_margin = <span class="number">8</span> - x, y_margin = <span class="number">8</span> - y;</span><br><span class="line">                <span class="type">int</span> val1 = <span class="built_in">min</span>(x, y), val2 = <span class="built_in">min</span>(y, x_margin), val3 = <span class="built_in">min</span>(x_margin, y_margin), val4 = <span class="built_in">min</span>(y_margin, x);</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x - val1, y - val1));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x + val2, y - val2));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x + val3, y + val3));</span><br><span class="line">                dest[i].<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x - val4, y + val4));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">mem</span>(n, );</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dest[index][]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMovesToCaptureTheQueen</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vis_a</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">9</span>, <span class="number">0</span>)), <span class="built_in">vis_b</span>(<span class="number">9</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">9</span>, <span class="number">0</span>));</span><br><span class="line">        vis_a[a][b] = <span class="number">1</span>;</span><br><span class="line">        vis_b[c][d] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> prev, <span class="type">int</span> dir_index) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x0 == e &amp;&amp; y0 == f || x1 == e &amp;&amp; y1 == f)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> min_step = INT_MAX;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rook</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [dx, dy] = dirs[i];</span><br><span class="line">                <span class="type">int</span> x = x0 + dx, y = y0 + dy;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">8</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">8</span> &amp;&amp; !vis_a[x][y]) &#123;</span><br><span class="line">                    vis_a[x][y] = <span class="number">1</span>;</span><br><span class="line">                    min_step = <span class="built_in">min</span>(min_step, <span class="built_in">dfs</span>(x, y, x1, y1) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// bishop</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [dx, dy] = dirs[i];</span><br><span class="line">                <span class="type">int</span> x = x1 + dx, y = y1 + dy;</span><br><span class="line">                <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">8</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; y &lt;= <span class="number">8</span> &amp;&amp; !vis_b[x][y]) &#123;</span><br><span class="line">                    vis_b[x][y] = <span class="number">1</span>;</span><br><span class="line">                    min_step = <span class="built_in">min</span>(min_step, <span class="built_in">dfs</span>(x0, y0, x, y) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> min_step;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(a, b, c, d, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习——设计模式</title>
      <link href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式">单例模式</h2><p>  单例模式就是在程序运行过程中这个类只能有一个实例，不允许存在多个该类的实例。例如一个随机数生成器，我们只希望在程序初始化的时候利用一个随机数种子初始化一个生成器，之后每次使用随机数只需对该生成器调用例如<code>get()</code> 函数即可，我们不需要再次实例化一个生成器类。  以下是一个简单的单例模式的模板。可以看到，与普通的类对比，我们要做如下几点：</p><ol type="1"><li>我们需要在类中声明一个静态的该类的成员变量；</li><li>我们还需要将类的构造函数设置为<code>private</code>，这将不允许我们调用构造函数实例化一个类；</li><li>还需要删除拷贝构造函数，否则我们可以使用 <code>Get()</code>函数获取这个实例，之后利用 <code>Singleton s = Singleton::Get()</code>来获取一份拷贝，这两份是独立的内存空间，因此我们便绕过构造函数创建了两个实例了；</li><li>我们还需要有要用到的成员变量及对应的访问接口函数；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::singleton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton &amp;s = Singleton::<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; Singleton::<span class="built_in">Get</span>().<span class="built_in">Float</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但这样每次我们调用这个实例的相关结构的时候，总是要写<code>Singleton::Get().Float()</code>这么一大长串，十分不便，以下是解决措施：</p><ul><li>首先，我们可以把 <code>Singleton::Get()</code>引用一下，之后每次在这个引用的变量上调用函数即可：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;s = Singleton::<span class="built_in">Get</span>();</span><br><span class="line">std::cout &lt;&lt; s.<span class="built_in">Float</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>另一种方法是修改类的成员函数，将<code>Singleton::Get().Float()</code> 再次进行包装，如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 我们将原先的函数作为内部接口，添加前缀<code>I</code>（仅个人喜好，可任意命名），作为私有成员函数，之后，我们对外开放的<code>Float</code> 函数可以调用这个函数。</p><p> 再次改进，我们可以将 <code>static Singleton singleton</code> 移入到<code>Get()</code> 里面，这样就不需要再在类的外面声明使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton singleton;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——一些新特性</title>
      <link href="/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="结构化绑定">结构化绑定</h2><p>  这是在 <code>C++17</code>中新引入的特性，用于处理函数多返回值的问题。在旧版本的 <code>C++</code>中，如果我们想要处理一个函数具有多返回值，而且返回值的类型可能不同时，我们可以通过结构体、<code>pair</code>或者 <code>tuple</code>的形式，但他们都十分地繁琐，不管是对于函数返回类型还是接收部分处理。以下是一个使用<code>tuple</code> 的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::tuple&lt;std::string, <span class="type">int</span>&gt; person = <span class="built_in">createPerson</span>();</span><br><span class="line">    std::string name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">    <span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">    std::string name2;</span><br><span class="line">    <span class="type">int</span> age2;</span><br><span class="line">    std::<span class="built_in">tie</span>(name2, age2) = <span class="built_in">createPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，如果使用 <code>std::tie</code>，会比使用<code>std::get&lt;&gt;</code> 要方便许多，但仍然需要 3行代码。而结构化绑定只需要一行代码！下面是使用结构化绑定修改的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [name, age] = <span class="built_in">createPerson</span>();</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意这是 <code>C++17</code> 的新特性，确保你的编译器在<code>C++17</code> 以上。如果使用 <code>g++</code>，可以使用命令<code>-std=c++17</code> 来指定版本。</strong></p></div><h2 id="stdoptional-可选数据"><code>std::optional&lt;&gt;</code>可选数据</h2><p>  在一些情况下，我们需要读取一个文件，但我们怎么知道文件是否存在以及是否被成功读取呢？一般来说，如果成功读取，我们可以返回文件的字符串表示，而失败时，由于返回类型必须一致，我们可以返回一个空字符串<code>""</code>。但是这样就有一个问题，如果我们成功读取到了文件内容，但文件中恰恰没有任何内容，也就是我们成功读取了，但返回的内容仍然是<code>""</code>。这样我们又该如何分辨到底有没有读取成功呢？  一种解决思路是再引入一个额外的布尔变量 <code>success_flag</code>专门用于标明是否读取成功。但这样会有额外的开销。能否只用一个变量就能做到呢。这就是<code>C++17</code> 引入的新特性可选 <code>std::optional&lt;&gt;</code>可选数据类型。   我们只需要把返回值 <code>string</code>设置为可选的，读取成功时给它赋值，而失败时留空，不做任何操作。那么我们就可以通过它里面是否有值来判断文件是否读取成功啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">readFileAsString</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (stream) &#123;</span><br><span class="line">        std::string result;</span><br><span class="line">        stream.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::optional&lt;std::string&gt; data = <span class="built_in">readFileAsString</span>(<span class="string">&quot;./data2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string str = data.<span class="built_in">value_or</span>(<span class="string">&quot;No present&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>std::optional&lt;&gt;</code> 有成员函数<code>has_value()</code>返回布尔值表示是否有值，但类本身也是有布尔运算符的，所以可以直接<code>if (data)</code> 来进行判断。   <code>value_or()</code>函数非常有用，作用如其函数名所述，如果本身有值，那么就用本身的值，否则，就用传入的参数作为值，起到了一种“默认” 值的作用。</p><h2 id="stdvariant-单变量存放多数据类型"><code>std::variant</code>单变量存放多数据类型</h2><h3 id="stdvariant-的用法"><code>std::variant</code> 的用法</h3><p>  <code>std::variant</code> 也是 <code>C++17</code>引入的新特性，允许我们在一个变量中存放多个类型的值，只需要我们将这些类型在声明变量的时候显性列举出来即可。以下是它的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(data) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; data.<span class="built_in">index</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access more safely</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> value = std::<span class="built_in">get_if</span>&lt;std::string&gt;(&amp;data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取对应类型的值，我们可以通过 <code>std::get&lt;type&gt;</code>来获取，但首先要确保这个变量目前存的值与该类型相匹配，否则会抛出异常！更安全的做法是使用<code>std::get_if&lt;type&gt;(ptr)</code>来获取，它接收的该变量的地址，如果类型匹配，返回指向该变量的指针，否则，返回空指针。</li><li><code>data.index()</code>可以返回当前变量值对应的类型的索引。例如在上述代码中，如果<code>data</code> 的类型是 <code>std::string</code>，那么会返回<code>0</code>，如果是 <code>int</code>，会返回 <code>1</code>。</li></ul><h3 id="与-union-比较">与 <code>Union</code> 比较</h3><p>  两者似乎都是在单一变量中能够存储多个值，但两者有很大的不同，例如在存储方式上。对于<code>Union</code> 来说，不同的变量占据的是同一块内存，因此<code>Union</code>的总大小取决于所包含的所有类型中最大的那一个。<del>而对于<code>std::variant</code>，它更像是为每一个类型单独分配一个变量来接收，例如在内部类似<code>std::string data1, int data2</code>这种。因此它的大小是所有类型的总和。</del><strong>更正：经过后续测试发现，<code>std::variant</code>的大小并不是各个类型大小之和，而是最大类型的占用大小，再加上额外的<code>size_t index</code> 的 8字节大小。似乎不同的平台结果会不同。。。</strong> &gt;<strong><em>Currently class variant has data members<code>std::size_t type_index</code> and <code>data_type data</code>.Here sizeof(data_type) will be the size of the largest type the variantincludes. But together they will be at least sizeof(size_t) == 8larger.</em></strong></p><div class="note info flat"><p>使用 <code>g++</code> 编译器，在 <code>macos M3 arm64</code>架构下，<code>sizeof(std::string) == 24</code>，因为<code>char * s; size_t capacity; size_t length;</code> 总共需要<code>3 x 8 = 24</code> 字节。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">u</span> &#123;</span><br><span class="line">    <span class="type">double</span> x1;</span><br><span class="line">    <span class="type">float</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;       <span class="comment">// 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;        <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(u) &lt;&lt; std::endl;            <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;          <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(std::string) &lt;&lt; std::endl;  <span class="comment">// 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(data) &lt;&lt; std::endl;         <span class="comment">// 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  总体来说，<code>Union</code> 占用的内存大小更少，但<code>std::variant</code> 在技术上访问起来更加安全。</p><h2 id="stdany-存放任意类型的数据"><code>std::any</code>存放任意类型的数据</h2><h3 id="stdany-的用法"><code>std::any</code> 的用法</h3><p>  <code>std::any</code> 是 <code>C++17</code>引入的新特性，允许我们将一个任意类型的数据存放进一个变量中。下边是它的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::any data;</span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    data = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string str = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(data);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data2;</span><br><span class="line">    data2 = <span class="number">2</span>;</span><br><span class="line">    data2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(data2);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，上述程序的前半部分会在运行时抛出异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">libc++abi: terminating due to uncaught exception of type std::bad_any_cast: bad any cast</span><br><span class="line">zsh: abort      ./main</span><br></pre></td></tr></table></figure><p>  意思就是 <code>any_cast&lt;&gt;</code> 转换失败，因为我们想要将一个<code>const char *</code> 的类型转成一个 <code>std::string</code>类型。可见，这个函数是不支持隐式转换的。而下半部分是用<code>std::variant</code> 做的对比，这一部分不会抛出异常，因为<code>get&lt;&gt;</code> 能够做隐式的类型转换。  此外，<code>std::any</code>的实现原理是如果要存储的类型较小，那么它会像 <code>std::variant</code>那样工作。而如果要存储的类型较大，那么它会做动态内存分配，这样会导致性能的下降。与之对比，<code>std::variant</code>就不会做动态内存分配。</p><h3 id="stdany-的应用场景"><code>std::any</code> 的应用场景</h3><p>  emmm…一般来说，<code>std::any</code> 并不像前述的<code>std::optional</code> 和 <code>std::variant</code>那样广泛，甚至可以说是基本无用。如果你的程序必须要用一个变量存储多个值，那么你可以使用<code>std::variant</code>，指定好可能出现的类型，使得编程更加安全。<code>std::any</code> is just funny.</p><h2 id="string_view-获取字符串"><code>string_view</code> 获取字符串</h2><h3 id="string_view-的用法"><code>string_view</code> 的用法</h3><p>  <code>string_view</code> 是在 <code>C++17</code>中引入的新特性，目的是尽量避免字符串的动态分配操作，加快字符串的操作处理速度。例如我们可以通过以下代码重载全局<code>new operator</code>，来监测内存的动态分配情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mallocCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocationg &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mallocCnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printString: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string name = <span class="string">&quot;sagsdhgdagsdhgdagsdhgdagsdhgdagsdhgddf sagagsdhgdagsdhgdagsdhgdsdhgd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string firstName = name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>);</span><br><span class="line">    std::string lastName = name.<span class="built_in">substr</span>(<span class="number">40</span>, <span class="number">74</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printString</span>(name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; mallocCnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>亲测在 <code>g++</code> 下，<strong>这里的字符串 <code>name</code>需要一定的长度（大于等于 24 字节，基于sso（小字符串优化），不同平台长度有所不同）才能够触发动态分配到堆上的操作，否则只是在栈上。</strong></p></div><p>  像上述的代码运行后，一共会进行 4 次动态内存分配。  但是实际上我们知道，<code>firstName</code> 和 <code>lastName</code>其实根本没有必要重新分配一块内存创建，我们可以简单地从 <code>name</code>上截取即可。这样我们就可以使用 <code>string_view</code> 类型，仅仅只是<code>view</code> 观察👀而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mallocCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRING_VIEW</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocationg &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mallocCnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STRING_VIEW</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printString: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(std::string_view str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string_view&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string name = <span class="string">&quot;sagsdhgdagsdhgdagsdhgdagsdhgdagsdhgddf sagagsdhgdagsdhgdagsdhgdsdhgd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STRING_VIEW</span></span><br><span class="line">    std::string firstName = name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    std::string lastName = name.<span class="built_in">substr</span>(<span class="number">41</span>, <span class="number">74</span>);</span><br><span class="line">    <span class="built_in">printString</span>(name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">std::string_view <span class="title">firstName</span><span class="params">(name.c_str(), <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">lastName</span><span class="params">(name.c_str() + <span class="number">40</span>, <span class="number">74</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    firstName = <span class="string">&quot;ADGAEHTEHEThtenheinirhwrihwihriwhrithwihtiafdiafhdaij&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; firstName &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; mallocCnt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果没有设置 <code>STRING_VIEW</code> 宏的话，同之前的代码，会进行4 次动态内存分配。而当我们设置 <code>STRING_VIEW</code> 这个宏之后，只有1 次动态分配了，这 1 次来源于最开始的用字符串字面量来初始化<code>std::string name</code>。   <code>name.c_str()</code> 用来获取一个<code>string</code> 类型的 <code>const char *</code> 表示。<div class="note danger flat"><p><code>string_view</code>定义的变量是只读，不可修改的。例如上述代码若执行<code>firstName[0] = "a"</code> 就会报错<strong>“必须是可修改的左值”</strong>。 但是对 <code>firstName</code>整体赋一个字符串字面量是允许的，这相当于将 <code>firstName</code>的指针指向了当前的这个字符串字面量。<strong>因为<code>string_view</code> 本质上就是一个 <code>const char *</code>指针，加上一个截取的长度<code>size</code>。并且这部分不会进行动态内存分配。</strong></p></div></p><p>下面是标准库中 <code>std::string_view</code> 的成员变量定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">basic_string_view</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some other implementaion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> value_type* __data_;</span><br><span class="line">  size_type __size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="与-const-string-的比较">与 <code>const string &amp;</code>的比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::string_view bar)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; bar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void foo(const std::string &amp;bar) &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; bar &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;Helllllaldsfllasdlflsdfsdfasdlfl lsdfallafs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于以上代码，两个 <code>foo</code>函数不可以同时出现，否则会有歧义报错。如果我们使用<code>string_view</code>，不会有内存动态分配操作，而如果我们使用<code>const string &amp;</code>，则会先将字符串字面量转为<code>string</code>类型，这里就会涉及内存的动态分配问题。尽管这部分内存会在该作用域结束后自动销毁，但也是一件比较耗时的操作。  但 <code>string_view</code> 也有自己的缺点，例如同<code>const string &amp;</code>一样只是引用了别人的，因此只是一个哑指针指向了其他变量的内存空间，其次，<code>string_view</code>字符串没有终止符，它的字符串具体是多少只取决于首地址以及长度，是不会给自动添加<code>'\0'</code>在末尾的（话说作为只是一个观察者，自己并不拥有实际内存，貌似也无法添加终止符，因为它没有修改这部分内存的权利，实在说的话可以自己在自己类的内部实现一下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(arr)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string_view <span class="title">sv</span><span class="params">(str)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sv: &quot;</span> &lt;&lt; sv &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; sv.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data: &quot;</span> &lt;&lt; sv.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string_view sv2 = sv.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sv: &quot;</span> &lt;&lt; sv2 &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; sv<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data: &quot;</span> &lt;&lt; sv<span class="number">2.</span><span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">str: Hello,worldk size: 13</span><br><span class="line">sv: Hello,worldk size: 13 data: Hello,worldk</span><br><span class="line">sv: Hel size: 3 data: Hello,worldk</span><br></pre></td></tr></table></figure><p>  可以看到，由于我是以数组的形式提供了字符串，必须要显性指定终止符<code>'\0'</code>，没有的话后续的操作字符串后面就会跟一些奇奇怪怪的字符，因为它只认终止符<code>'\0'</code>，没有遇到的话之前所有的字符都会算在这个字符串里面！  另一个发现就是 <code>string_view</code> 的 <code>data()</code>返回的是遇到终止符之前的所有字符，而非仅仅只是 <code>size</code>长度的。这也就说明了 <code>string_view</code>是没有终止符的，它之所以能够控制长度，完全是因为 <code>size</code>的存在，让它知道应该取几个字符。<strong>但如果后续我们把它作为了一个地址用于其他地方，可以预想的是它不一定会按照预期显示<code>sv</code> 的那几个字符，而是会显示 <code>data()</code>输出的这些字符！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——编译链接</title>
      <link href="/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译头文件">预编译头文件</h2><h3 id="概念">概念</h3><p>  预编译的头文件实际上是让你抓取一堆头文件，并将它们转换成编译器可以使用的格式，而不必一遍又一遍地读取这些头文件。  使用预编译的头文件目的是加快程序的编译速度。我们平常所用的例如<code>&lt;iostream&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;algorithm&gt;</code>，甚至是操作系统层面的例如<code>Window.h</code>等这些库在我们每次运行程序（尽管这个程序很小，可能只有<code>std::cout &lt;&lt; someInfo &lt;&lt; std::end;</code>这么一段打印的信息）都会全部被包含进来，然后编译、链接运行。因此，为了加快程序的编译速度，我们可以在编译编译主程序之前先将这些头文件编译一次，然后生成二进制文件缓存下来，之后每次读取这个二进制文件作为头文件使用即可。可以预见的是，自己的<code>main</code>程序只有寥寥几行代码，而头文件这一堆就可能有几十万行，因此程序的编译速度是会有明显提升的。</p><h3 id="什么样的头文件适合写入-stdafx.h">什么样的头文件适合写入<code>stdafx.h</code></h3><p>  为了能够有更快的编译速度，是不是所有的头文件都应该写入<code>stdafx.h</code>？答案是否定的。因为这个文件首次被编译出来成二进制文件，后面我们就不会再次生成或更新了，都是直接拿过来用。因此，我们频繁修改的头文件不应该写在这里面，不然每次修改都要重新编译，那和没有用预编译没什么区别了。<div class="note warning flat"><p><strong>频繁修改的文件不要放入 <code>stdafx.h</code>中进行预编译！</strong></p></div></p><h3 id="小小的缺点">小小的缺点</h3><p>  使用预编译头文件也不是没有缺点，我们对于自己的每一个<code>.cpp</code>源文件，此时不用有选择性的只引入自己需要用到的头文件，而是一棍子打死，直接一个<code>#include "stdafx.h</code>引入全体了。例如数组相关，我们本来只会引入<code>&lt;vector&gt;</code>，但现在把 <code>&lt;thread&gt;</code>也引入进来了。当然这没有什么损失，因为既然 <code>stdafx.h</code> 中有<code>&lt;thread&gt;</code>，说明它在某些地方肯定能用到。而<code>stdafx.h</code>本质是一个巨大的共享库。但这会使得我们对于相关依赖不太清楚了。例如，自己的一个源文件被另一个人拿来用，另一个人不想用预编译头文件，就想用了几个库就引入几个，那么他并不知道究竟这里面具体用到了哪几个库，只能自己查看代码，或根据报错缺失库进行添加。</p><h3 id="c-测试"><code>C++</code> 测试</h3><p>  在测试目录下新建 3 个文件：</p><ul><li><code>main.cpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>stdafx.cpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>stdafx.cpp</code> 只是一个<code>helper file</code>，没有什么具体的实际意义。</p></div><ul><li><code>stdafx.hpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br></pre></td></tr></table></figure><p>  之后我们使用 <code>g++</code> 进行编译测试。（使用<code>time</code> 可以输出编译所消耗的时间，便于比较）</p><ul><li>预编译头文件：<code>time g++ stdafx.h</code>   这会生成一个<code>stdafx.h.gch</code>文件，可以看到，这个文件占用空间很大，仅仅包含这几个头文件就有了<code>11.2 MB</code>。</li><li>编译主源文件：<code>time g++ main.cpp</code>  这会生成可执行文件</li></ul><h3 id="测试结果">测试结果</h3><ul><li>不使用预编译头文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.19s user 0.05s system 81% cpu 0.298 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 105% cpu 0.228 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.19s user 0.04s system 103% cpu 0.221 total</span><br></pre></td></tr></table></figure><ul><li>使用预编译头文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ stdafx.hpp </span><br><span class="line">g++ stdafx.hpp  0.21s user 0.04s system 96% cpu 0.256 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp  </span><br><span class="line">g++ main.cpp  0.19s user 0.04s system 103% cpu 0.219 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 105% cpu 0.223 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 107% cpu 0.224 total</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——类与子类</title>
      <link href="/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB/"/>
      <url>/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="成员初始化列表">成员初始化列表</h2><p>  在构造函数中对成员变量初始化有两种方法，一种是在函数内部进行初始化赋值，另一种则是在构造函数定义后，函数主体前以列表的形式进行初始化。具体的代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>() &#123;</span><br><span class="line">        m_data = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Examle&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> data) &#123;</span><br><span class="line">        m_data = data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created Example with &quot;</span> &lt;&lt; m_data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化方法一，在函数内部进行初始化赋值</span></span><br><span class="line">    <span class="built_in">Entity</span>() &#123;</span><br><span class="line">        m_name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        m_example = <span class="built_in">Example</span>(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法二，在函数主体部分前以列表初始化的方式赋值</span></span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string &amp;name) : <span class="built_in">m_name</span>(name), <span class="built_in">m_example</span>(<span class="number">8</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example m_example;</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----- without member initialize: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Entity e;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;------ with member initialize: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Entity <span class="title">e2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，我们在 <code>main</code> 中定义了两个 <code>Entity</code>实例，其中第一个 <code>e</code>是用第一种方法，也就是在函数的内部赋值初始化。而 <code>e2</code>则是调用了传入一个 <code>const std::string &amp;</code>的构造函数，这个我们是用初始化列表进行初始化的。可以看到，使用成员初始化列表，我们的函数主体部分就可以更加清晰明了，可以写入一些初始化<code>Init()</code> 函数等，而将一些成员变量赋值挪到了前面。</p><p>  推荐在任何时候都优先考虑使用列表初始化，不仅仅是因为更加简便明了，还涉及到了性能的问题。使用普通的赋值初始化，我们相当于对每一个类成员初始化构造了两次。首先是在<code>private</code>部分，也就是我们声明类成员的地方构造了一次。然后，在我们调用构造函数内部赋值初始化的时候，又会再初始化一次，而这次会覆盖掉之前的那次初始化。但使用列表初始化就不会这样，只会在列表初始化的时候构造一次。为了证明这一点，我们再定义一个<code>Example</code> 类，在其构造函数内打印一些信息，并将其作为<code>Entity</code> 的一个成员变量，然后构造 <code>Entity</code>实例，观察打印的信息即可。代码还是上面的这一份，输出的结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ test.cpp -o test.out -Wall -std=c+<span class="number">+11</span></span><br><span class="line">test.cpp:<span class="number">25</span>:<span class="number">39</span>: warning: field <span class="string">&#x27;m_name&#x27;</span> will be initialized after field <span class="string">&#x27;m_example&#x27;</span> [-Wreorder-ctor]</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> std::string &amp;name) : <span class="built_in">m_name</span>(name), <span class="built_in">m_example</span>(<span class="number">8</span>) &#123;</span><br><span class="line">                                      ^~~~~~~~~~~~  ~~~~~~~~~~~~</span><br><span class="line">                                      <span class="built_in">m_example</span>(<span class="number">8</span>)  <span class="built_in">m_name</span>(name)</span><br><span class="line"><span class="number">1</span> warning generated.</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out                               </span><br><span class="line">----- without member initialize: </span><br><span class="line">Created Examle</span><br><span class="line">Created Example with <span class="number">8</span></span><br><span class="line"></span><br><span class="line">------ with member initialize: </span><br><span class="line">Created Example with <span class="number">8</span></span><br></pre></td></tr></table></figure><p>  首先有一个警告，我们先不去管他。可以看到，没有使用成员初始化列表，我们确实是进行了两次构造，一次是默认的无参构造，另一次是我们显性指定参数的构造。而使用列表初始化，只有一次。</p><p>  此时再回过头去看一下这个警告，它的意思是 <code>m_name</code>的初始化必须在 <code>m_example</code>的后面，也就是我们要把这两个的初始化调一下位置。<strong>这里是因为我们的初始化列表的顺序必须与我们定义成员变量时的顺序一致。</strong>我们在上方定义的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Example m_example;</span><br><span class="line">    std::string m_name;</span><br></pre></td></tr></table></figure><p>  因此初始化的时候也要 <code>m_example</code>在前，<code>m_name</code> 在后！</p><h2 id="this-指针"><code>this</code> 指针</h2><p>  直接上代码解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        x = x;</span><br><span class="line">        y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity *e = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; e-&gt;x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; e-&gt;y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  考虑上述代码，你认为输出打印出来的会是什么？</p><p>  不妨我们编译运行一下。首先，编译时它就会出现两个警告（推荐编译的时候加入<code>-Wall</code>参数，显示所有的警告，否则警告不会显示！虽然有些小的警告确实可以忽略，但有很多是语法上支持，但是语义上是错误的警告是不容忽略的！）下面显示编译及运行的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ test.cpp -o test.out -Wall</span><br><span class="line">test.cpp:7:11: warning: explicitly assigning value of variable of type &#x27;int&#x27; to itself; did you mean to assign to member &#x27;x&#x27;? [-Wself-assign]</span><br><span class="line">        x = x;</span><br><span class="line">        ~ ^ ~</span><br><span class="line">        this-&gt;</span><br><span class="line">test.cpp:8:11: warning: explicitly assigning value of variable of type &#x27;int&#x27; to itself; did you mean to assign to member &#x27;y&#x27;? [-Wself-assign]</span><br><span class="line">        y = y;</span><br><span class="line">        ~ ^ ~</span><br><span class="line">        this-&gt;</span><br><span class="line">2 warnings generated.</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out                    </span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><p>  竟然是 <code>0 0</code>诶！其实我们查看警告信息就可以知道为什么了。我们不巧将成员变量<code>x</code> 和传入的参数 <code>x</code>都定义成了一样的变量名，因此我们左边的 <code>x</code>并没有像我们预想的那样指向类的成员变量<code>x</code>，而仍然是传入参数的<code>x</code>。要指定我们是要对成员变量的 <code>x</code>进行赋值，就需要显性指定这个 <code>x</code>应该是这个类的成员变量，也就是用 <code>this-&gt;x</code>。</p><p>  其中，<code>this</code> 就是一个指针，指向了当前这个实例对象，因此<code>this-&gt;x</code> 就是当前类中的成员变量<code>x</code>。既然指向当前实例，我们就可以用<code>Entity *e = this</code> 来获取它，但没什么必要，因为<code>e</code> 和 <code>this</code> 本身就是等价的。</p><div class="note warning flat"><p>注意，<code>this</code>指针只能用在<strong>非静态成员函数</strong>中，成员函数声明<code>static</code> 是不可以使用的！原因可以详见关键字部分<code>static</code> 的用法，此处不再赘述。</p></div><h2 id="虚析构函数">虚析构函数</h2><p>  对于一般成员函数来说，虚函数的意思就是这个函数可以被子类中的其他函数覆写。<strong>但对于析构函数来说，虚析构函数的意思是，不是覆写析构函数，而是加上一个新的析构函数。这是只在一个类具有子类的情况下我们才会要思考的地方。</strong>例如对于如下的代码，我们创建了两个类<code>Base</code> 和继承自它的类<code>Derived</code>。可以看到，它们都有对应的构造和析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Contructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    Base *base = <span class="keyword">new</span> Base;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Base *c = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Base Constructor.</span><br><span class="line">Base Destructor.</span><br><span class="line">-------------</span><br><span class="line">Base Constructor.</span><br><span class="line">Derived Constructor.</span><br><span class="line">Derived Contructor.</span><br><span class="line">Base Destructor.</span><br><span class="line">-------------</span><br><span class="line">Base Constructor.</span><br><span class="line">Derived Constructor.</span><br><span class="line">Base Destructor.</span><br></pre></td></tr></table></figure><p>  <code>case 1</code> 和 <code>case 2</code>输出的结果也都符合预期。但对于 <code>case 3</code>来说，我们发现它没有调用 <code>Derived</code>类的析构函数，这就会导致内存泄漏，因为一般来说，子类是在父类的基础上延伸拓展的，也就是子类占用的内存都会大于父类，我们只清理了父类那部分内存，专属于子类的那部分内存便泄漏了。造成这种结果的原因便是我们用一个父类类型来接收了一个子类的类型，于是删除的时候，他不知道调用的父类的析构函数层次下可能还会有子类的析构函数没有被调用。而这我们可以通过将父类的析构函数标记为虚函数来解决。  所以，我们只需要将父类的虚构函数改为<code>virtual ~Base() &#123;...&#125;</code> 便可以解决内存泄漏问题。</p><div class="note warning flat"><p><strong>当我们在写一个要拓展的类或者子类的时候，这一点非常重要。只要你允许一个类拥有子类，那么你百分之一百需要声明父类的析构函数是虚函数！否则没有人能够安全地拓展这个类，因为子类的析构函数永远不会被调用。</strong></p></div><h2 id="拷贝与拷贝构造函数">拷贝与拷贝构造函数</h2><p>  在 <code>C++</code>的类中，有一个叫做拷贝构造的函数，用于传入一个相同类的实例，然后根据这个实例来创建出一个新的实例。</p><div class="note warning flat"><p><strong>在 <code>C++</code>中，一切默认的赋值都是浅拷贝</strong>，也就是把一切的成员变量直接拷贝一份过去给一个新的实例。这样做的问题就是如果类中一个指针，指向一块新分配的内存。我们只是单纯地复制了指针，也就是现在有两个指针指向了同一块内存。后续在调用析构函数的时候就会造成一块内存连续释放了两次，产生错误。</p></div><p>以下是一段代码，我们构造了一个自定义的 <code>String</code>类，没有实现拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        m_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(m_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, str, m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_buffer;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> String &amp;str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;stream, <span class="type">const</span> String &amp;str) &#123;</span><br><span class="line">    stream &lt;&lt; str.m_buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    String str2 = str;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行程序，打印出两次 <code>"Hello, world"</code>之后返回时，程序崩溃报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out                    </span><br><span class="line">Hello, world</span><br><span class="line">Hello, world</span><br><span class="line">test.out(69554,0x1f6b1cf40) malloc: Double free of object 0x11d605e30</span><br><span class="line">test.out(69554,0x1f6b1cf40) malloc: *** set a breakpoint in malloc_error_break to debug</span><br><span class="line">zsh: abort      ./test.out</span><br></pre></td></tr></table></figure><p>  原因就是因为对于内存区 <code>0x11d605e30</code>释放了两次！如果我们不自己定义拷贝构造函数，类会给我们启用默认的构造函数，也就是浅拷贝版本，单纯地将每个成员变量复制一份。上述的代码可以验证这是一份浅拷贝版本，那如何说明是调用了默认的构造函数呢？很简单，我们只要显性地声明<code>String(const String &amp;other) = delete;</code>，也就是删除拷贝构造函数，上述的代码<code>String str2 = str;</code> 就会报错。</p><p>  接下来提供我们自己的拷贝构造函数，同时修复 <code>String</code>没有终止符 <code>'\0'</code> 的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        m_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(m_size + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, str, m_size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;other) &#123;</span><br><span class="line">        m_size = other.m_size;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, other.m_buffer, m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_buffer;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> String &amp;str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;stream, <span class="type">const</span> String &amp;str) &#123;</span><br><span class="line">    stream &lt;&lt; str.m_buffer;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">    String str2 = str;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">get_size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个时候，我们的程序就能够正常运行并退出了。</p><div class="note info flat"><p>实际上，这里我们的 <code>=</code>赋值能够使用拷贝构造函数，是因为进行了隐式类型转换。如果我们在拷贝构造函数前声明这是一个<code>explicit</code>，也就是这个函数必须要显性调用，则再使用<code>=</code> 赋值就会报错了。</p></div><h2 id="关于拷贝和移动构造的一些补充">关于拷贝和移动构造的一些补充</h2><p>  从 <code>C++</code> 标准产生一直到<code>C++17</code>，<code>C++</code>标准一直在试图减少某些临时变量或者拷贝的操作，虽然经过优化后，可能在实际执行中不需要调用拷贝或者移动构造，但是它必须隐式或者显式存在，如下面的案例，如果在类中禁止编译器默认生成拷贝构造和移动构造函数，代码将不会被编译通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> data) : <span class="built_in">m_data</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_entity</span><span class="params">(<span class="type">const</span> Entity &amp;e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">get_data</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e = <span class="built_in">Entity</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_entity</span>(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  使用 <code>C++17</code> 前的标准对上述代码进行编译，例如<code>-std=c++14</code>，编译时会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ test.cpp -o test.out -Wall -std=c++14</span><br><span class="line">test.cpp:31:12: error: call to deleted constructor of &#x27;Entity&#x27;</span><br><span class="line">    Entity e = Entity(10);</span><br><span class="line">           ^   ~~~~~~~~~~</span><br><span class="line">test.cpp:18:5: note: &#x27;Entity&#x27; has been explicitly marked deleted here</span><br><span class="line">    Entity(Entity &amp;&amp;other) = delete;</span><br><span class="line">    ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>  这很符合我们的预期，因为我们把移动构造和拷贝构造都给显性标记为了删除。但在<code>C++17</code>中，上述代码竟然能够正常运行。无意间发现后，困惑了好久，搜索了相关资料（例如<a href="https://cloud.tencent.com/developer/article/1979760">这一篇</a>），大概就是因为<code>C++17</code>的一个新特性——<strong>强制省略拷贝或传递未实质化的对象 (unmaterializedobject)</strong>。也就是对于<strong>一些临时变量</strong>，编译器会省略掉拷贝或者移动构造的操作，因此会绕过我们标记为删除的这两个函数。</p><p>  之所以说是<strong>一些临时变量</strong>，因为有些临时变量，它还是会调用我们的拷贝和移动构造函数的，比如下边的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">int</span> data) : <span class="built_in">m_data</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    Entity &amp;<span class="keyword">operator</span>=(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> Entity &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_entity</span><span class="params">(<span class="type">const</span> Entity &amp;e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">get_data</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法运行，报错 Entity::Entity(Entity &amp;&amp;other) 已删除</span></span><br><span class="line"><span class="function">Entity <span class="title">create_entity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create an entity...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 e 也是一个临时变量</span></span><br><span class="line">    <span class="function">Entity <span class="title">e</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确执行，因为该对象实例不具名</span></span><br><span class="line"><span class="function">Entity <span class="title">create_entity2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create an entity...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Entity</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法运行，报错 Entity::Entity(const Entity &amp;other) 已删除</span></span><br><span class="line"><span class="function">Entity <span class="title">return_entity</span><span class="params">(<span class="type">const</span> Entity &amp;obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确执行，这里只是引用，并没有构造新的 Entity</span></span><br><span class="line"><span class="function"><span class="type">const</span> Entity &amp;<span class="title">return_entity2</span><span class="params">(<span class="type">const</span> Entity &amp;obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entity e = <span class="built_in">Entity</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entity e2(create_entity());</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_entity</span>(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  若要详细研究理解，应该要学一下更深入的 <code>C++</code>的值类型分类 (valuecategory)，<a href="https://en.cppreference.com/w/cpp/language/copy_elision">cppreference</a>上有对于这一现象以及值分类的详细说明。</p><h2 id="重载运算符-operator">重载运算符 <code>operator</code></h2><p>  当我们自定义类的时候，有些时候我们可能希望有下标索引的功能，或者对于一些几何的类，我们可能希望能够进行加减乘除等操作。一种方法是我们定义成员函数，例如两个<code>Vector2</code> 类型的 <code>v1</code> 和 <code>v2</code> 相加，有<code>v1.add(v2)</code>这种成员函数。这种的弊端是不太有可读性，我们能否实现<code>v1 + v2</code> 这种操作呢？答案是可以的，我们可以在类中重载<code>operator+</code> 运算符，然后实现它应该实现的功能即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="built_in">Vector2</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="type">const</span> Vector2 &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;other.x + x, other.y + y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;stream, <span class="type">const</span> Vector2 &amp;vec) &#123;</span><br><span class="line">    stream &lt;&lt; vec.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec.y;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector2 <span class="title">pos</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    Vector2 vel&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Vector2 res = pos + vel;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>+</code> 明明是二元运算符，为什么我们只传入一个参数<code>v2</code> 就可以了？🤔这是因为 <code>operator+</code>已经在类的内部，它的左边部分 <code>v1</code> 就是调用 <code>+</code>的实例，而它在调用 <code>v1.operator+(v2)</code>的时候，已经把自己作为第一个参数传入进去了，因此只需要传入<code>v2</code> 就可以了。</p><p>  对于上面的<code>std::ostream &amp;operator&lt;&lt;()</code>，这个比较特殊，它有一部分的重载函数是定义在类的内部，可以作为成员函数使用的，而另一部分则是定义在类外的。</p><p>  考虑如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout.<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  按理来说如果 <code>std::cout</code> 中有<code>operator&lt;&lt;(const char *)</code>重载运算符的话，两者是等价的，应该输出两次<code>"Hello"</code>，但是运行后会发现，第二个会输出<code>"Hello"</code> 字符串的地址！这是因为 <code>std::cout</code>类的内部有 <code>operator&lt;&lt;(void *)</code> 这个函数，而没有<code>const char *</code> 或 <code>char *</code> 版本的，所以传入<code>const char *</code>，会调用这个函数打印出地址。  <a href="https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt">这里</a>可以查看在类内部的<code>opeartor&lt;&lt;</code>成员重载运算符，而<a href="https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2">这里</a>可以查看类外部的<code>operator&lt;&lt;</code> 重载运算符。   因此，我们必须调用外部的<code>operator&lt;&lt;</code>，格式是<code>operator&lt;&lt;(std::cout, "Hello");</code>，这样就可以打印出<code>"Hello"</code> 字符串了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——基本数据类型</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="string-literal-字符串字面量">string literal 字符串字面量</h2><p>  <code>C++</code> 中形如 <code>"hello world"</code>的字符串即为字符串字面量（常量）。与之对比的是字符串变量，也即字符数组，形如<code>char arr[] = "hello world"</code>。两者在用法上有很多相似之处，但两者的存储属性是截然不同的。</p><p>  字符串字面量和字符数组有一个很重要的差别：前者是只读的，若程序试图修改字符串字面量，那么结果是未定义的；后者是可读可写的（除非主动使用const修饰）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用指针，尽管没有声明 const 关键字，但仍是字符串字面量，因此不可修改字符串中的字符</span></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的做法是错误的！！</span></span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// str2 使用数组声明，只要没有声明 const 关键字限定，就是可变的</span></span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的做法是正确的</span></span><br><span class="line">    str2[<span class="number">2</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译运行上述的代码，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ string_li.cpp -o string_li.out -Wall</span><br><span class="line">string_li.cpp:5:17: warning: conversion from string literal to &#x27;char *&#x27; is deprecated [-Wc++11-compat-deprecated-writable-strings]</span><br><span class="line">    char *str = &quot;hello, world!&quot;;</span><br><span class="line">                ^</span><br><span class="line">1 warning generated.</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./string_li.out                         </span><br><span class="line">zsh: bus error  ./string_li.out</span><br></pre></td></tr></table></figure><p>  可以看到，我们将字符串字面量赋给 <code>char *</code>类型会导致编译器给出警告，尽管我们没有声明 <code>const</code>关键字，<code>str</code> 也是不可以被修改的！而添加了 <code>const</code>关键字之后，就没有该报错了，当然，这个时候有 <code>const</code>限制更是不可以修改 <code>str</code>。</p><p>  而当我们使用数组声明的时候，只要不带 <code>const</code>关键字，后续我们是可以对其进行修改的。</p><h2 id="string-字符串"><code>string</code> 字符串</h2><h3 id="sso小字符串优化">SSO（小字符串优化）</h3><p>  众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用<code>const char *</code>，也要尽量避免使用<code>std::string</code>。<code>C++</code>意识到了这一点，因此对于小字符串做了一定的优化。  具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是仅仅分配到缓冲区的栈上，借此来加快程序的运行。这个具体的内部给定参考值依据不同平台有所变化，可能是15 或 23或其他值。一旦<strong>严格超过</strong>了这个值，就会触发动态分配<code>Alloc</code> 机制。</p><h2 id="类型双关">类型双关</h2><h3 id="定义">定义</h3><p>  维基百科对类型双关的定义是这样：类型双关是计算机科学的术语，指任何编程技术能颠覆或者绕过一门程序设计语言的类型系统，以达成在形式语言内部难以甚至不可能实现的效果。</p><h3 id="用法">用法</h3><p>  首先，下面的这种操作并不是类型双关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = a;   <span class="comment">// equal to: double b = (double)a</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;    <span class="comment">// output: 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  因为 <code>a</code> 和 <code>b</code>本质是两段内存，而且里面存的数据并不一样，只是各自能够通过自己的类型解读成相同的数值<code>50</code>。例如 <code>a</code> 在内存中占用 4 个字节，按小端序为<code>32 00 00 00</code>，而 <code>b</code> 在另一段内存中占用 8个字节，小端序为 <code>00 00 00 00 00 00 49 40</code>。</p><p>  真正的“类型双关”是我能够让<strong>同一段数据</strong>既能够按照<code>int</code> 类型进行读取，也能够按照 <code>double</code>的类型进行读取，尽管不同读取方式读取出的内容可能不同。</p><p>  那么如何做到这一点呢？使用指针！我们可以先把这个变量取地址，之后我们再对这个地址进行处理，我们让它按照另一个类型的方式取内存地址，之后再解引用，取得该变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = *(<span class="type">double</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此处 <code>b</code> 的值并不固定，因为 <code>a</code> 的类型是<code>int</code>，而 <code>int</code> 一般是占用 4 个字节，而<code>double</code> 一般占用 8 个字节，因此紧跟在 <code>a</code>的内存后面还有 4个字节会被使用到，而每次运行分配的内存不同，后面紧跟的内存中的值也会不同，因此<code>b</code>的值不确定。<strong>一般情况下由于引用了未分配定义的额外内存，会导致程序崩溃！</strong></p><p>  掌握了这种方法，对于内存如果有更深刻的理解，我们可以做一些更加crazy 的操作。例如对于一个结构体 <code>Pos</code> 做下述的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pos</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pos pos&#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.x</span></span><br><span class="line">    <span class="type">int</span> pos_x = *(<span class="type">int</span> *)&amp;pos;</span><br><span class="line">    <span class="type">int</span> pos_x2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">0</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_x2 &lt;&lt; std::endl;  <span class="comment">// output: 3, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.y</span></span><br><span class="line">    <span class="type">int</span> pos_y = *(<span class="type">int</span> *)((<span class="type">char</span> *)&amp;pos + <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> pos_y2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_y2 &lt;&lt; std::endl;  <span class="comment">// output: 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合体-union">联合体 <code>Union</code></h2><p>  多个变量共用同一块内存，改变了其中一个变量的值，其他变量的值同样也会跟随变化。多个变量可以是不同的类型，这样读取的时候就相当于进行了类型双关的操作了。<del>经过<code>g++</code>编译器实测，两者的大小不同时也并不会报错，应该也是进行了内存越界访问，与类型双关类似。</del><strong>更正：<code>union</code>的大小取决于其中最大的那个变量类型。</strong>   一般来说<code>union</code> 是匿名使用的，而匿名 <code>union</code>不能够有成员函数。   例如对于如下的代码，我们发现其实<code>Vector4</code> 是可以使用 <code>Vector2</code> 的打印函数<code>print_vector2</code> 进行打印的，无非是将其分成两个<code>Vector2</code> 类型即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, w, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  那么我们如何做到这一点呢？答案是使用 <code>union</code>，我们对<code>Vector4</code> 内部可以声明一个别名，就是两个<code>Vector2</code>，它们和正常的那 4 个 <code>int</code>数据占用的是同一块内存，因此修改其中一方，另一方也会进行修改，并且没有引入额外的内存或副本。当然，我们也可以利用前面刚学习的类型双关技术，强制将<code>Vector4</code> 转成两个 <code>Vector2</code>进行读取，此处就不展开了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// form 1</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">int</span> x, y, w, v;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// form 2</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            Vector2 a, b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Vector4 vec4&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>w &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>v &lt;&lt; std::endl;</span><br><span class="line">    vec<span class="number">4.</span>x = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>a);</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意 <code>struct</code> 和 <code>union</code>这些匿名使用的时候，只是作为了一种数据结构在使用，由于没有名称，在结构体或类的内部使用时也无法使用<code>.name.member_var</code> 获取内部的成员变量，可以直接<code>.member_var</code> 获取。例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Union</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Union u = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><p>  <code>C++</code>是一种强类型语言，每一个变量必须对应有自己的数据类型，但不同的数据类型之间一般是可以进行类型转换的。早在<code>C</code> 中，我们便可以使用例如如下的代码进行转换，我们称之为<code>C-style</code> 类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a = <span class="number">5.4</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (int)a = 5</span></span><br><span class="line">    <span class="type">double</span> c = (<span class="type">int</span>)a + b;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;    <span class="comment">// output: 10.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  而在 <code>C++</code>中，我们共有四种类型转换的函数可供使用，分别是<code>static_cast&lt;&gt;</code>、<code>reinterpret_cast&lt;&gt;</code>、<code>dynamic_cast&lt;&gt;</code>、<code>const_cast</code>。<div class="note info flat"><p><code>C++</code> 的这些不过只是语法糖，只能能做 <code>C-style</code>能做的一切而已。它可能会做其他的事情，但实际的结果也只是一个成功的类型转换而已。</p></div></p><ul><li><code>static_cast&lt;&gt;</code>为静态类型转换，是最一般的用法，它会做一些编译时检查，看看这种转换是否真的可能。</li><li><code>reinterpret_cast&lt;&gt;</code>类似类型双关，是要将这一段内存重新解释为其他数据类型。</li><li><code>const_cast&lt;&gt;</code> 移除或添加变量的 <code>const</code>限定。</li><li><code>dynamic_cast&lt;&gt;</code>运行时检查某种转换是否能够发生。</li></ul><p>  搞这么多 <code>cast</code>的好处是，除了可能收到那些编译时检查之外，还可以在代码库中搜索它们，便于全部替换某种类型转换。同时，还能帮助我们减少在尝试类型转换的时候可能会意外犯的错误，例如类型不兼容。</p><p>  对于如下代码，我们显然知道一个 <code>double</code>数据是不能够转成一个我们自定义的类的，因此使用 <code>static_cast</code>会直接在编译期间报错。而我们使用 <code>reinterpret_cast</code>便可以以重新解读该内存的方式进行转换。   对于<code>dynamic_cast</code>，这是在运行时进行类型检查，它与运行时类型信息RTTI 紧密相关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">5.23</span>;</span><br><span class="line">    <span class="comment">// wrong</span></span><br><span class="line">    <span class="type">double</span> s = <span class="built_in">static_cast</span>&lt;AnotherDerived&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s2 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s3 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successs</span></span><br><span class="line">    <span class="type">double</span> s4 = <span class="built_in">reinterpret_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    Base *base = derived;</span><br><span class="line"></span><br><span class="line">    AnotherDerived *ad = <span class="built_in">dynamic_cast</span>&lt;AnotherDerived *&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (!ad) std::cout &lt;&lt; <span class="string">&quot;failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;convert successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行上述代码，最后的 <code>ad</code> 为空，输出<code>failed.</code>。因为它是一个 <code>Derived</code>类型，我们不能先用父类接收它，然后反手把它转成<code>AnotherDerived</code>的。这里并不会在编译阶段报错，我们需要在运行时手动捕获观察。</p><h2 id="dynamic_cast-再探"><code>dynamic_cast</code> 再探</h2><p>  <code>dynamic_cast</code>更像是一个函数，因为它不是在编译时检查，而是在运行时进行类型检查，因此有相关的运行成本。它是专门用于沿继承层次结构进行的强制类型转换，例如从子类到父类，或者从父类到子类的转换。如果是子类转成父类，过程相对简单，甚至不需要<code>static_cast</code>也可以隐式转换。但反过来就会有问题了。例如我有一个 <code>Entity</code>实体类，表示游戏中的所有实体，<code>Enemy</code> 和 <code>Player</code>都继承自它。那么我现在有一个 <code>Entity</code>的指针，指向一个实体，我想把它转成 <code>Player</code>类，是否可以做到？我们知道，这个 <code>Entity</code> 有 3 中可能，可能是<code>Player</code>，也可能是<code>Enemy</code>，还有可能是除这两者外的其他实体。因此我们需要判断是否能够进行转换，否则如果我们把一个<code>Enemy</code> 转成了 <code>Player</code>，访问了<code>Player</code> 的独有数据，就可能会造成程序的崩溃。</p><p>  如果转换失败，那么会返回<code>NULL</code>，否则，返回转换后指向这种类型的一个指针。</p><p>  示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player *player = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it is easy to cast a derived class to base class.</span></span><br><span class="line">    Entity *e = player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong!!</span></span><br><span class="line">    <span class="comment">// Player *p = e;</span></span><br><span class="line"></span><br><span class="line">    Entity *actualEnemy = <span class="keyword">new</span> Enemy;</span><br><span class="line">    Entity *actualPlayer = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    Player *p1 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualEnemy);</span><br><span class="line">    Player *p2 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualPlayer);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (p1 == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (p2 == <span class="literal">nullptr</span>) &lt;&lt; std::endl;   <span class="comment">// output: 1, 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换操作符">类型转换操作符</h2><p>  <code>C++</code>中可以为每一个类编写对应的类型转换操作符，考虑如下的代码场景。我们编写了<code>ScopedPtr</code> 类，并且我们动态分配了内存给类内的指针<code>m_Ptr</code>成员变量。按照惯例，我们在分配之后都应该查看是否分配成功。对于一般的指针而言，我们可以直接写<code>if (ptr) &#123;&#125;</code>这类的判断语句。因为一个指针实际上就是一个整数，可以判断整数是否是 0来做决定。但我们将指针包装进了一个类，对于类如何进行布尔判断，编译器并不知道应该怎么处理。我们当然可以编写<code>bool isValid()</code> 函数，调用时写<code>if (scopedPtr.isValid()) &#123;&#125;</code>来判断。但这样太麻烦了，还要调用成员函数。能不能像之前那样只要把实例放进去就好了？答案是可以的，我们需要提供类的布尔运算符，这样后续有需要的话，就会自动调用该运算符将这个类转换成布尔值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(T *ptr) : <span class="built_in">m_Ptr</span>(ptr) &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123; <span class="keyword">delete</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T *<span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ScopedPtr&lt;Entity&gt; e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    Entity *e2 = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左值-lvalue-和右值-rvalue">左值 <code>lvalue</code> 和右值<code>rvalue</code></h2><h3 id="概念">概念</h3><p>  <code>C++</code> 中的数据及表达式等还分为左值 <code>lvalue</code>和右值<code>rvalue</code>，但它们的定义并不是根据它们是在等号的左边还是右边，但大部分情况下也都是符合的。<strong>更多的人是这样认为的：左值是程序运行过程中在内存中明确有存储空间的，而右值则是临时变量，在内存中没有存储空间，使用后不久就会被销毁。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string firstName = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string lastName = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 4</span></span><br><span class="line">    std::string name = firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  例如对于上述代码：</p><ul><li><code>case 1</code> 中显然 <code>i</code> 是在内存有<code>int</code> 型存储空间的，因此是左值，而右边的 <code>10</code>则是个立即数，赋完值后就会消失。显然 <code>10 = i</code>这种写法是大错特错的。</li><li><code>case 2</code> 中 <code>a</code> 和 <code>i</code>都是左值，尽管 <code>i</code> 出现在等号的右边。</li><li><code>case 3</code> 中 <code>firstName</code> 和<code>lastName</code> 都是左值，右边的字符串字面量都是右值。</li><li><code>case 4</code> 中，<code>firstName + lastName</code>这个表达式整体是一个右值，取这两个左值的拼接字符串作为临时变量，用来初始化<code>std::string name</code>。我们显然不会写出<code>firstName + lastName = "xxx"</code> 这种语句。</li></ul><h3 id="与引用-的关系">与引用 <code>&amp;</code> 的关系</h3><p>  <code>C++</code>中有左值引用和右值引用。引用的原理就是取这块内存的地址，只不过不是指针的形式，而是包装成了仍使用原变量符号的形式。因此，我们不能有<code>int&amp; a = 10</code> 这种操作，<strong>这会在编译期间报“非常量引用的初始值必须为左值” 的错误。</strong>因为 <code>10</code>本质上是没有内存空间的。但什么是 “非常量引用”？因为 <code>C++</code>中允许我们对常量进行引用，这时候要用<code>const int&amp; a = 10</code>，这时候就不会报错了，就像是你承诺了我虽然会引用这个数据，但是我不会对此进行修改，我不会把一个常量<code>10</code> 变为 <code>1</code>，因为 <code>10</code> 就是<code>10</code>。   常值引用的作用如下代码所述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  即我们有一个内存占用很大的对象，这里以 <code>string</code>举例。我们要对其进行打印，要把它作为参数传入进去。我们知道由于对象很大，我们肯定不会选择拷贝一份用来打印，理想的方法是使用引用，这样可以避免拷贝复制。但这样就有问题了，这是一个非常量引用，它只能接收左值，例如上述代码，对于<code>print(str)</code> 是可以正常运行的，但<code>print("Hello, world)"</code>就不可以了，因为一个字符串字面量是右值。这时候，我们就可以修改<code>print()</code> 函数的参数类型，改为<code>const std::string &amp;</code>，这也是为什么大多数函数只要不是在内部修改参数的数据，都会选用<code>const type &amp;</code> 的原因。</p><p>  上述讲的都是左值引用，除此之外还有右值引用。一般来说，写函数的时候都会提供两个版本的函数，一个是<code>const type &amp;</code>常量引用版本的，用来处理左值引用，如有必要也可以处理右值引用。另一个版本是<code>type &amp;&amp;</code>，这是专门用来处理右值引用的。那既然有了<code>const type &amp;</code>可以用来处理右值了，那为什么还要提供专门处理右值的版本呢？这主要在于程序的优化。如果我们知道传入的是一个临时对象的话，我们就不需要担心它是否完整，是否拷贝，我们可以简单无虑地使用它的资源，给到特定的对象，或者在其他地方使用它们，而不需要对其后果做考虑，因为反正不久后它也就会被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[lvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;&amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[rvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">[lvalue] Hello, world</span><br><span class="line">[rvalue] Hello, world</span><br></pre></td></tr></table></figure><p>可以看到，对于传入一个右值，<code>type &amp;&amp;</code>的调用优先级是要高于 <code>const type &amp;</code> 的。</p><h2 id="移动语句">移动语句</h2><p>  移动，即将一块内存从一个地方移动到另一个地方。但我们知道，内存就在那个地方，是无法移动的。因此，一种思路是将这块内存的数据搬到另一块内存，然后把原内存中的数据清空，这样就实现了移动的操作。但这种方法的时间复杂度为<span class="math inline">\(O(N)\)</span>。即如果有 <spanclass="math inline">\(N\)</span> 个字节，我们就需要移动 <spanclass="math inline">\(N\)</span>次。<font color="darkred"><strong>其实还有另一种方法，那就是我们把指向新内存的指针搬过来，让它指向旧内存的首地址，这种只是修改了一个指针的指向，因此时间复杂度为<spanclass="math inline">\(O(1)\)</span>。但事情到这里还没有结束，因为此时我们如果要删除旧地址的指针，由于此时它还是指向这一块内存，这样就会顺带把这块内存数据给删去了，那么新的指针也无法工作了。因此，我们还要将旧的指针置为<code>nullptr</code>。</strong></font>这种思路就是移动语句的思想。  因此一般来说，移动构造能够既节约内存（无需开辟新内存，可以将旧的将要废弃的内存直接拿过来用，不用再根据它复制开一块新的内存空间），又能节约时间（无需开辟新内存并复制过来，显然这是一项耗时的操作，而是直接修改一个指针的指向即可）。  下面通过一个具体的例子来讲解移动语句的好处。  我们需要创建两个类：</p><ul><li><strong>其一是自定义的 <code>String</code> 类。</strong><ul><li>我们首先定义了它的构造函数，一种是无参构造，按默认即可；一种是接收<code>const char *</code>字符串字面量来进行构造；还有一种是接收相同类型的<code>const String &amp;</code> 进行拷贝构造。</li><li>其次我们定义一个打印函数<code>Print()</code>，将字符串逐字符打印出来。</li><li>最后是简单的析构函数。</li></ul></li><li><strong>其二是用到 <code>String</code> 类的 <code>Entity</code>类</strong><ul><li>构造函数方面，这里比较简单，<code>Entity</code>类只有实体的名称，它的类型就是<code>String</code>，因此我们只写一个接收字符串的构造函数即可，参数形式为<code>const String &amp;</code>。</li><li>我们也定义了一个打印实体名称的函数，内部调用 <code>String</code>的打印函数实现。</li></ul></li></ul><p>  接下来我们思考我们在 <code>main</code> 函数中定义一个<code>Entity</code> 类的实例<code>Entity e = Entity("Hello, world")</code> 时会发生什么。</p><ol type="1"><li>首先，<code>"Hello, world"</code> 要隐式转换为 <code>String</code>类型，并且我们已经提供了相应的构造函数，此时动态分配了内存，会输出<code>"Created!"</code>。</li><li>然后，调用 <code>Entity</code> 的构造函数，接收<code>const String &amp;</code>，我们知道这是允许接收右值的。之后由其列表初始化功能<code>m_Name(name)</code>，这里又会调用<code>String(const String &amp;)</code> 的构造函数，即用一个<code>String</code> 来初始化另一个 <code>String</code>，由<code>String</code>构造函数内部的代码可知，这里又会进行一次动态内存分配，会输出<code>"Copied!"</code>。</li><li>之后由于 <code>"Hello, world"</code> 是一个右值，临时变量，完成了对<code>Entity</code> 的构造之后，就会被销毁了，调用 <code>String</code>的析构函数，释放这部分内存，输出 <code>"Destroyed"</code>。</li><li>后续作用域结束后，<code>e</code> 调用 <code>Entity</code>的析构函数，释放它的内存。</li></ol><p>  由上述的流程可知，我们为了定义一个 <code>Entity</code>并将其初始化，一共进行了两次的动态内存分配，虽然有一次在初始化完成后就释放了，但复制内存生成新内存的时间是无法挽回的。从结果来看，我们只是动态分配了<code>Entity</code> 里面的一个 <code>String</code>而已，能不能只分配这一次内存呢？答案是可以的，只要用到移动语句即可，而它的思想就是我们在本节最开头加粗说的那样。  为了实现移动功能，我们需要添加一些代码。首先，我们的<code>String</code> 构造函数仍然是正常接收一个 <code>const char *</code>的字符串字面量，仍然正常分配动态内存生成一个<code>String</code>。但是，当用这个 <code>String</code> 来初始化<code>Entity</code>中的实体名字字符串时，我们不能再让他与正常的分配过内存空间的字符串一样走<code>String(const String &amp;str)</code>这个构造函数。因为它实际上是一个右值，我们专门提供<code>String(String &amp;&amp;str)</code> 来处理它。   因为这个<code>String</code> 是一个右值，而所有的 <code>String</code>都是有堆上的内存空间的，所以对于右值，这部分空间很快就要被释放的，我们可以用这块的内存直接来构造调用<code>String(String &amp;&amp;)</code>这个函数的字符串，省去了内存的分配、拷贝等步骤，只是简单的修改指针的朝向，更快速高效。  具体的代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str.m_Data);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = str.m_Size;</span><br><span class="line">        m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">        str.m_Size = <span class="number">0</span>;</span><br><span class="line">        str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> m_Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; m_Data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_Data;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String &amp;name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(String &amp;&amp;name) : <span class="built_in">m_Name</span>((String &amp;&amp;)name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity e = <span class="built_in">Entity</span>(<span class="built_in">String</span>(<span class="string">&quot;Hello, world&quot;</span>));</span><br><span class="line">    e.<span class="built_in">PrintName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意在<code>Entity(String &amp;&amp;name) : m_Name((String &amp;&amp;)name) {}</code>中，列表初始化里还是要显性指定这是一个右值，否则还是会走<code>const String &amp;</code> 常量引用的构造函数！而且比起<code>(String &amp;&amp;)name</code>，更推荐使用<code>std::move(name)</code></strong></p></div><p>  总的来说就是一句话，右值不配拥有动态分配的内存空间，如果有，那可以将这块空间转交给别人继续使用，再留给它也是浪费了（指对于右值，一般存活时间不会很长，很快内存就会被释放）</p><h2 id="stdmove-与移动赋值操作符"><code>std::move</code>与移动赋值操作符</h2><h3 id="stdmove"><code>std::move</code></h3><p>  上一节中重点讲了移动构造，这一节主要讲移动赋值。首先来看一下<code>std::move()</code>。上面也说了，<code>std::move()</code>就是做了一个类型转换，将当前的变量类型标记为右值类型，通过<code>static_cast</code> 实现，以下是 <code>std::move()</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_LIBCPP_NODISCARD_EXT <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt;&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_LIBCPP_LIFETIMEBOUND _Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt; _Up;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  大概能看到 <code>static_cast</code> 和右值符<code>&amp;&amp;</code>，推测中间部分 <code>_Up</code>就是原先变量的类型。当然，在简单情况下我们可以直接自行使用<code>static_cast</code> 转换，但对于复杂数据类型情况尤其是使用了<code>auto</code> 的情况下，既然 <code>C++</code>本身给我们提供了更方便安全的转换函数，我们就安心的用吧！😌</p><h3 id="移动赋值操作符">移动赋值操作符</h3><p>  注意下述代码中的两个 <code>=</code> 是不同的含义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2;</span><br><span class="line">str2 = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>这第一个的 <code>=</code> 实际上是调用了<code>String(const char *)</code>构造函数，因此这是一个构造操作，并不是赋值操作。</li><li>而第二个是调用了无参构造函数，并在后续使用了一个字符串字面量进行赋值操作，这里才是真正的赋值操作，相当于<code>str2.operator=("Hello, world!")</code>。</li></ul><p>  因此要实现移动赋值操作，我们还需要提供<code>String &amp;operator=(String &amp;&amp;str)</code>移动赋值操作符的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String &amp;<span class="keyword">operator</span>=(String &amp;&amp;str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> m_Data;</span><br><span class="line"></span><br><span class="line">            m_Size = str.m_Size;</span><br><span class="line">            m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">            str.m_Size = <span class="number">0</span>;</span><br><span class="line">            str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  在这部分代码中，我们主要做的事情同移动构造函数，都是将当前实例的字符串指针以及长度赋值为右值的，然后把右值的置为空。<font color="darkred"><strong>但是，不同于构造函数是从头从无到有开始构造，赋值操作时当前的字符串可能有了自己的那一块内存，因此我们要先将这一块内存给释放掉，否则，更改了它的指针，这一块内存就无法获取，造成了内存泄漏。</strong></font>  还有一点要注意的是，由于当前的字符串会释放自己之前的内存，<strong>我们要小心传入的右值是否就是当前字符串本身，如果是的话，那删除之后自身也无法获取右值的那些数据了，因为右值就是自己，一块全给删掉啦！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——数据结构</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="vector"><code>vector</code></h2><h3 id="优化部分">优化部分</h3><p>  分析下述代码，找出可以优化的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(std::vector&lt;Data&gt; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; vec[i].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Data&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存分配优化">内存分配优化</h4><p>  首先，我们可以重载全局的<code>void *operator new(size_t size)</code>方法，看一下一共动态分配了多少的内存。篇幅原因，此处的代码略，完整代码整合可以见后文。仅显示运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">Allocating: 4 bytes.</span><br><span class="line">Allocating: 8 bytes.</span><br><span class="line">Allocating: 16 bytes.</span><br><span class="line">Allocating: 32 bytes.</span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 5</span><br></pre></td></tr></table></figure><p>  可以看出，我们一共进行了整整 <strong>5</strong>次的内存分配！理想情况下，应该只有 1 次分配就可以了，因为<code>vector</code> 就是在堆上动态分配内存，因此至少会有 1次。可是这里竟然有 5 次，下面来分析一下：</p><ul><li>首先，我们看到 <code>printVector</code> 函数接收的参数是<code>vector&lt;data&gt;</code>，这里是值传递，因此会发生拷贝，构造一个新的<code>vector</code>供函数内部使用。而这一部分是可以优化的，我们只需要传递一个引用就可以了，改为<code>const vector&lt;data&gt; &amp;</code>。可以看到，修改后我们只有 4次分配啦！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">Allocating: <span class="number">4</span> bytes.</span><br><span class="line">Allocating: <span class="number">8</span> bytes.</span><br><span class="line">Allocating: <span class="number">16</span> bytes.</span><br><span class="line">Allocating: <span class="number">32</span> bytes.</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">Allocating: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>其次，这里涉及到 <code>vector</code>的内部实现原理。如果我们定义了一个<code>vec</code>，但却没有指明要分配多少内存，则默认是 0字节内存，即还没有动态分配内存。可以利用 <code>.capacity()</code>函数验证：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Data&gt; vec;</span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>  输出的结果为 0，并且重写的 <code>new</code>函数在此处并没有被调用，也就是说没有动态分配任何内存。</p><p>  之后我们利用 <code>push_back()</code> 往后追加数据时，内部会比较<code>size + 1</code> 和 <code>capacity</code> 的大小，如果<code>size + 1</code>更大，说明预先分配的大小不够了，因此会重新分配一块更大的内存。那具体分配的是多少呢？不同的编译器实现的不同，有可能是1.5 倍，大多数是 2 倍，可以进入 <code>push_back()</code>的源码进行查看。例如在我的编译器下定位源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Precondition:  __new_size &gt; capacity()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">_LIBCPP_CONSTEXPR_SINCE_CXX20 <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI <span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::size_type</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__recommend(size_type __new_size) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="type">const</span> size_type __ms = <span class="built_in">max_size</span>();</span><br><span class="line">  <span class="keyword">if</span> (__new_size &gt; __ms)</span><br><span class="line">    <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line">  <span class="type">const</span> size_type __cap = <span class="built_in">capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (__cap &gt;= __ms / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> __ms;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>&lt;size_type&gt;(<span class="number">2</span> * __cap, __new_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，是按原先大小的两倍进行分配的。因此上述的 4次就好解释了：</p><ol type="1"><li>开始的 <code>vec</code> 大小是0，要添加新数据，<code>size = 0</code>, <code>capacity = 0</code>,<code>size + 1 &lt; capacity</code>，因此<strong>分配 1次内存</strong>，此时 <code>capacity = 1</code>；</li><li>之后又要添加数据，数据大小来到了 2，但是容量仍是1，因此又要<strong>重新分配一次内存</strong>，<code>capacity = 2</code>；</li><li>之后添加第 3个数据，发现又不够用了，因此<strong>再重新分配一次</strong>，为原来的 2倍，此时 <code>capacity = 4</code>；</li><li>之后添加第 4 个数据，能够正常添加进去；</li><li>添加最后一个数据，容量又不够啦！因此<strong>再重新分配一次</strong>，<code>capacity = 8</code>。</li></ol><p>  数一下，一共分配了 4次内存，与程序的结果一致。我们还可以进行验证，此时的<code>vec.capacity() == 8</code>，此处略。</p><div class="note danger flat"><p><strong>注意这里的重新分配是要重新找一块足够大的内存，然后将原有的数据再原封不动的复制过来，并不是简单地在原先数据的后面接着开辟额外的内存就可以了，因为后面的内存本身就不属于自身所有，可能已经被其他部分使用了。</strong></p></div><p>  为了解决这个问题，我们可以在定义的时候预先指定我们的<code>vector</code> 的大小。这里有两种方法：</p><ul><li>其一，定义时指定 <code>vector&lt;int&gt; vec(n, 0)</code> 可以指定<code>vec</code> 的大小为 <code>n</code>，同时初始化所有值为<code>0</code>。也可以在后续通过 <code>.resize()</code> 函数指定<code>n</code> 和初值。注意这个方法会同时改变 <code>vec</code> 的长度<code>size</code> 和 <code>capacity</code>，也就是 <code>vec</code>中已经有了这么多值了，使用或修改时直接调用 <code>vec[i]</code>即可。</li><li>其二，使用 <code>reserve(n)</code>来预留空间，这相当于是提前霸占了一块内存，“即使我现在还没有用到这么多，但是你们其他谁都不可以动这块内存，它全都是我的”。也就是说<code>vec</code> 的 <code>size</code> 依旧是 0，但是<code>capacity</code> 已经变成 <code>n</code>了，由于只是霸占，内部仍然是空的，因此使用时还需要先用<code>vec.push_back</code> 添加值。</li></ul><p>  经过这两步的修改，我们的动态内存分配成功地来到了只有 1次！！🎉🎉</p><h4 id="拷贝复制优化">拷贝复制优化</h4><p>  嘿嘿，是不是以为结束了。还早呢，孩子！接下来，让我们看一下这里面一共进行了多少次的拷贝操作吧！要查看到这一点，我们需要提供<code>Data(const Data &amp;)</code>拷贝构造函数，并在里面加点统计信息。依旧，代码见最后～输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 5</span><br></pre></td></tr></table></figure><p>  Ohhh! 竟然有 5 次拷贝！为啥会有这么多呢，按理来说应该是 0次的呀。这里就涉及到 <code>push_back</code>的事情了。它有两个重载，一个是接收左值 <code>const reference</code>的，另一个是专门接收右值 <code>&amp;&amp;</code>的。这里调用的是后者。我们每 <code>push_back</code>一个值的时候，都会先构造一个临时的变量<code>Data(i)</code>，之后我们再用它拷贝构造一份到 <code>vec</code>中。<code>C++</code> 在这里已经尽力了，它提供了 <code>push_back</code>的两种接收类型，就是想让我们在如果传入的参数是一个右值的时候，能够“移动” 而非 “拷贝”。以下是节选的 <code>push_back</code>接收右值的实现源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">_LIBCPP_CONSTEXPR_SINCE_CXX20 <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI <span class="type">void</span> vector&lt;_Tp, _Allocator&gt;::<span class="built_in">push_back</span>(value_type&amp;&amp; __x) &#123;</span><br><span class="line">  pointer __end = <span class="keyword">this</span>-&gt;__end_;</span><br><span class="line">  <span class="keyword">if</span> (__end &lt; <span class="keyword">this</span>-&gt;__end_cap()) &#123;</span><br><span class="line">    __construct_one_at_end(std::<span class="built_in">move</span>(__x));</span><br><span class="line">    ++__end;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __end = __push_back_slow_path(std::<span class="built_in">move</span>(__x));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;__end_ = __end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，里面对传入的数据 <code>__x</code> 都是调用了<code>std::move</code>，尽量避免拷贝。但为什么我们还是拷贝了呢？因为我们并没有提供移动构造函数！！所以迫不得已它只能走了常值引用的拷贝构造函数，因为这个函数也是可以接收右值的。因此，只要我们提供了<code>Data(Data &amp;&amp; other)</code>函数，就能够避免复制啦！结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br></pre></td></tr></table></figure><h4 id="移动优化">移动优化</h4><p>  想不到吧，还可以优化！！既然我们提供了移动构造函数，因此我们按照上面所说的，查看一下进行了多少次移动吧！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br><span class="line">Moved!5</span><br></pre></td></tr></table></figure><p>  有 5次！发生在我们每次添加新元素！这时候我们想，能不能把移动次数也减掉呢？考虑我们现在的流程：我们先创建一个临时变量<code>Data(i)</code>，当然这个变量用的内存还是在堆上，之后我们把它<code>push_back</code> 进<code>vector</code>。相比于复制，我们现在实现了移动操作，能够将这部分内存的所有者移动给<code>vec</code>。那我们想，为什么不能一开始就直接归 <code>vec</code>所有，非要先流经他人之手，最后再归到自己的手上呢？   <code>C++</code>给了我们这个机会，那就是 <code>emplace_back()</code> 函数。相比于<code>push_back()</code>，我们要传入的不再是一个 <code>Data</code>类的对象，因为这样的话又会将该内存的所有者暂时给到这个临时变量（当然非要传入的话也没有错，只不过就和<code>push_back</code>没区别了，一样要移动）。我们传入如何构造这个类的参数，让<code>vec</code> 自己在内部构造，这样的话所有值直接就归 <code>vec</code>所有了！   优化后的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br><span class="line">Moved: 0</span><br></pre></td></tr></table></figure><p>  大功告成！</p><h4 id="完整优化后的代码">完整优化后的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> allocating_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> copied_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> moved_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    allocating_number++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data &amp;other) &#123;</span><br><span class="line">        copied_number++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        val = other.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(Data &amp;&amp;other) &#123;</span><br><span class="line">        moved_number++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        val = other.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;Data&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; vec[i].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Data&gt; vec;</span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating: &quot;</span> &lt;&lt; allocating_number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied: &quot;</span> &lt;&lt; copied_number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Moved: &quot;</span> &lt;&lt; moved_number &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array"><code>array</code></h2><p>  与 <code>vector</code> 不同的是，<code>vector</code>是动态分配到堆上的，而 <code>array</code> 是分配到栈上的，因此<code>array</code> 理论上来说访问、修改的速度要比 <code>vector</code>快。而且，<code>array</code>必须在定义时指定具体的大小，因此它的长度是固定的，而 <code>vector</code>则是可以变化的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 6&gt; arr2;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="built_in">printArray</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码展示了 <code>array</code>的基本用法。但是有一个弊端就是对于 <code>printArray</code>这类的如果要将 <code>array</code> 作为一个参数传入函数时，由于<code>array</code> 自身的大小也是构造 <code>array</code>的一个不可或缺的数据，因此我们必须要显性指定出来 <code>array</code>的大小，这里就有问题了。也就是说我们的函数限制了传入的<code>array</code> 长度必须是<code>5</code>，一旦传入其他值就都会因为参数类型不正确而报错。那么如何修改这一点呢？  可以使用模板 <code>template</code> 来帮助我们，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::array&lt;T, N&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 6&gt; arr2;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="built_in">printArray</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器-iterator">迭代器 <code>iterator</code></h2><h3 id="迭代器的使用">迭代器的使用</h3><p>  迭代器用于对一个数据集合进行迭代，可以用来遍历元素，例如如下的代码，通过了三种方法来遍历一个<code>vector</code> 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">        std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : vec)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于有下标索引的数据集合例如 <code>vector</code>，其实不必非要使用<code>iterator</code>来遍历或操作元素。但对于一些没有下标索引的数据类型来说，数据不一定是连续存放的，例如树，无序集合等，这时候还是有必要使用的。示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">    map[<span class="string">&quot;Hello, world&quot;</span>] = <span class="number">23</span>;</span><br><span class="line">    map[<span class="string">&quot;asd&quot;</span>] = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unordered_map&lt;std::string, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;key = it-&gt;first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;value = it-&gt;second;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;key = kv.first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;value = kv.second;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意最后一种方法是 <code>C++17</code> 新引入的 “结构化绑定”特性，确保编译执行时使用的 <code>C++</code> 标准在 <code>C++17</code>及以上！</strong></p></div><h3 id="迭代器的实现">迭代器的实现</h3><h2 id="stdmap-和-stdunordered_map"><code>std::map</code> 和<code>std::unordered_map</code></h2><p>  <code>std::map</code> 和 <code>std::unordered_map</code> 是<code>C++</code>中的键值对容器，模板的第一个参数指定的是键的数据类型，第二个指定的是值的数据类型。添加键值对的时候只需要简单地以键作为索引，用值进行赋值即可。  <code>std::unordered_map</code> 要比 <code>std::map</code>快很多，前者是基于哈希，后续基于红黑树，内部会维持着一定的顺序，因此速度上就会慢一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CityRecord</span> &#123;</span><br><span class="line">    std::string cityName;</span><br><span class="line">    <span class="type">uint64_t</span> population;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    std::unordered_map&lt;std::string, CityRecord&gt; cityMap;</span><br><span class="line">    cityMap[<span class="string">&quot;ak&quot;</span>] = CityRecord &#123; <span class="string">&quot;ak&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;bk&quot;</span>] = CityRecord &#123; <span class="string">&quot;bk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;ck&quot;</span>] = CityRecord &#123; <span class="string">&quot;ck&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;dk&quot;</span>] = CityRecord &#123; <span class="string">&quot;dk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cityMap[<span class="string">&quot;ck&quot;</span>].population &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义键的哈希函数">自定义键的哈希函数</h3><div class="note danger flat"><p>注意，键的类型不能够是自定义的！除非你能够自行提供哈希函数。因为对于自定义的类，<code>C++</code>内部并不知道应该如何对其进行哈希处理，进而进行存储。因此，<strong>如果非要以自定义的类作为键，请使用指针形式，因为指针在本质上只是一个整数，或者自行提供对应的哈希处理函数！</strong></p></div><p>  对于 <code>CityRecord</code>类，如果我们想要用它作为键值，需要自行提供对应的哈希函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CityRecord</span> &#123;</span><br><span class="line">    std::string cityName;</span><br><span class="line">    <span class="type">uint64_t</span> population;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CityRecord&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> CityRecord &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> population &lt; other.population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;CityRecord&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> CityRecord &amp;key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(key.cityName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    std::unordered_map&lt;std::string, CityRecord&gt; cityMap;</span><br><span class="line">    cityMap[<span class="string">&quot;ak&quot;</span>] = CityRecord &#123; <span class="string">&quot;ak&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;bk&quot;</span>] = CityRecord &#123; <span class="string">&quot;bk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;ck&quot;</span>] = CityRecord &#123; <span class="string">&quot;ck&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;dk&quot;</span>] = CityRecord &#123; <span class="string">&quot;dk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cityMap[<span class="string">&quot;ck&quot;</span>].population &lt;&lt; std::endl;</span><br><span class="line">    cityMap.<span class="built_in">erase</span>(<span class="string">&quot;ak&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;CityRecord, std::string&gt; foundedMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cityName, CityRecord] : cityMap) &#123;</span><br><span class="line">        foundedMap[CityRecord] = cityName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : foundedMap) &#123;</span><br><span class="line">        <span class="type">const</span> CityRecord &amp;city = kv.first;</span><br><span class="line">        std::string &amp;name = kv.second;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key.name] &quot;</span> &lt;&lt; city.cityName &lt;&lt; <span class="string">&quot; [val] &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  几个关键点：</p><ol type="1"><li>对应的 <code>CityRecord</code> 类必须重载 <code>operator==</code>运算符，以便 <code>map</code> 知道这个键是否已经插入过了；</li><li>提供的哈希函数可以写在 <code>std</code>命名空间内，这样我们就不要在定义的时候显性提供这个哈希函数；</li><li>哈希函数通常是一个结构体，我们需要重载 <code>operator()</code>方法，并且这个成员函数一定要是 <code>const</code> 的。</li></ol><p>  <font color="red"><strong>注意如果我们用的是 <code>std::map</code>而非 <code>std::unordered_map</code>，这时我们的自定义类必须还要重载<code>operator&lt;</code> 用于排序！如下所示：</strong></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> CityRecord &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> population &lt; other.population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>必须要保证每一个实例的 <code>population</code>属性不能相同，否则就会相互覆盖掉！</p></div><h3 id="插入新键值的不同方法比较">插入新键值的不同方法比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 1</span></span><br><span class="line">CityRecord &amp;city = cityMap[<span class="string">&quot;Berlin&quot;</span>];</span><br><span class="line">city.cityName = <span class="string">&quot;Berlin&quot;</span>;</span><br><span class="line">city.population = <span class="number">5000</span>;</span><br><span class="line">city.x = <span class="number">20</span>;</span><br><span class="line">city.y = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2</span></span><br><span class="line">CityRecord city2;</span><br><span class="line">city<span class="number">2.</span>cityName = <span class="string">&quot;New&quot;</span>;</span><br><span class="line">city<span class="number">2.</span>population = <span class="number">333</span>;</span><br><span class="line">city<span class="number">2.</span>x = <span class="number">30</span>;</span><br><span class="line">city<span class="number">2.</span>y = <span class="number">44</span>;</span><br><span class="line">cityMap[<span class="string">&quot;New&quot;</span>] = city2;</span><br></pre></td></tr></table></figure><p>  以上的两种构建并插入键值的方法，第一种方法会快一些。因为它直接将内存空间建在了<code>cityMap</code> 里面，之后我们引用（<strong>注意一定是引用<code>&amp;</code>，否则后续的赋值无效！</strong>）这段空间，并将里面的相关数据赋上值。而对于第二种方法，它是先在栈上创建一个这个类型，之后完成初始化赋值之后，再在<code>cityMap</code>上创建这样一段内存空间并将栈上的这些数据复制过去，因此就会慢一些。</p><div class="note info flat"><p>注意如果直接使用<code>cityMap["key"]</code>，如果已经有这个键了，那么它会返回对应的值。<strong>但是如果没有这个键，它并不会报错或告知有任何不存在的信息，而是会默认构造一个值，并将这对键值自动插入到<code>cityMap</code> 中！</strong>如果你只是单纯想索引一个<code>map</code> 中是否存在某个键，请使用 <code>.at()</code>方法，这样就不会在不存在的时候默认给你创建并插入了。</p></div><p>  而且如果一个 <code>map</code> 是以 <code>const</code>定义的，那么我们只能使用 <code>.at()</code>方法，而不能使用下标索引方法。原因就像之前所说的，如果不存在给定的键时，使用下标索引会自动创建，而这违反了<code>const</code> 不会修改 <code>map</code> 的本意，因此编译会报错。  在使用 <code>at()</code> 前最好做一下检查，看 <code>map</code>中是否真的存在这个键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cityMap.<span class="built_in">find</span>(<span class="string">&quot;New&quot;</span>) != cityMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; cityMap.<span class="built_in">at</span>(<span class="string">&quot;New&quot;</span>).cityName &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-的遍历方法"><code>map</code> 的遍历方法</h3><p>  一般来说不要对 <code>map</code> 进行遍历操作，我们使用<code>map</code>的原因就是它能够快速给我们一个键对应的值，而不需要我们遍历后才能够得知。但实际上对<code>map</code> 的遍历也是允许的，有两种方法，都是基于<code>iterator</code> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cityName, CityRecord] : cityMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; cityName &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; CityRecord.cityName &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : cityMap) &#123;</span><br><span class="line">    <span class="type">const</span> std::string &amp;name = kv.first;</span><br><span class="line">    CityRecord &amp;city = kv.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意键的类型是 <code>const</code>的，因为我们是不能够修改键的值的。</p><h3 id="map-的删除操作"><code>map</code> 的删除操作</h3><p>  比较简单，只要使用 <code>.erase()</code> 并提供相应的键即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cityMap.<span class="built_in">erase</span>(<span class="string">&quot;ak&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="优先队列-priority_queue">优先队列<code>priority_queue</code></h2><h3 id="优先队列的概述">优先队列的概述</h3><p>  既然是队列，那么使用的时候我们需要引入<code>#include &lt;queue&gt;</code>。与普通的队列 <code>queue</code>不同的是，优先队列能够允许我们自定义数据的优先级，将优先级高的数据放在队列的前面，优先出队。</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>top</code></td><td>访问队头元素</td></tr><tr><td><code>empty</code></td><td>队列是否为空</td></tr><tr><td><code>size</code></td><td>返回队列内元素个数</td></tr><tr><td><code>push</code></td><td>插入元素到队尾 (并排序)</td></tr><tr><td><code>emplace</code></td><td>原地构造一个元素并插入队列</td></tr><tr><td><code>pop</code></td><td>弹出队头元素</td></tr><tr><td><code>swap</code></td><td>交换内容</td></tr></tbody></table><h3 id="优先队列的定义">优先队列的定义</h3><p>  <strong>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></strong></p><ul><li><code>Type</code> 就是数据类型</li><li><code>Container</code> 就是容器类型（<code>Container</code>必须是用数组实现的容器，比如 <code>vector</code>, <code>deque</code>等等，但不能用 <code>list</code>。<code>STL</code> 里面默认用的是<code>vector</code>）</li><li><code>Functional</code>就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</li></ul><p>  示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上式可以简写为</span></span><br><span class="line">std::priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br></pre></td></tr></table></figure><p>  代码使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>&gt; pq2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec2) &#123;</span><br><span class="line">        pq<span class="number">2.</span><span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> value = pq<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        pq<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码很简单的使用了一个简写形式的<code>std::priority_queue&lt;int&gt; pq2;</code>，简写情况下默认使用的是<code>less&lt;int&gt;</code>，即大顶堆。</p><div class="note success flat"><p>关于 <code>less&lt;int&gt;</code> 和 <code>greater&lt;int&gt;</code>到底哪个是大顶堆，哪个生成的是小顶堆，哪个是降序，哪个是升序的巧记：<code>less&lt;int&gt;</code> 内部的实现原理就是<code>(int a, int b) { return a &lt; b; }</code>，也就是如果前面的数<code>a</code> 小于后面的数 <code>b</code>，就会返回<code>true</code>，而返回 <code>true</code>就代表要进行交换，因此<strong>一定不会出现前面的数小于后面的数这种情况</strong>，也就是说这是一个大顶堆，最大的数在最前面，也就是说是降序排列。</p></div><h3 id="自定义比较函数">自定义比较函数</h3><p>  有的时候，我们需要有一些特殊的比较函数，例如对于一个<code>pair&lt;int, int&gt;</code>，我们可能希望按照降序排列<code>pair.first</code>，然后按照升序排列<code>pair.second</code>，或者反过来。总之，我们的需求是多变的，不可能有如此多的库函数能够囊括这一切。这就需要我们自己去定义比较函数，也就是模板参数里的<code>Functional</code>。</p><p>  这里的一种做法是仍然使用例如 <code>less</code> 或<code>greater</code> 这些仿函数，但是我们重载 <code>&lt;</code>运算符，让这个小于运算符按照我们期望的进行运算。这种方法对于我们的优先队列中的数据类型是自定义的时候比较好用，但数据类型如果是我们之前所说的<code>pair&lt;int, int&gt;</code>这种内置的话，重载运算符就会与原本的冲突覆盖了，因此不推荐对内置数据类型使用！</p><p>  另一种方法是我们不使用内置的仿函数，而是自定义函数，也就是重写仿函数。以下是两种写法的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义比较器 comp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p1, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p<span class="number">1.</span>second &gt; p<span class="number">2.</span>second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, comp&gt; pq;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 lambda 表达式结合</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [&amp;](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[a][next[a]] &gt; nums[b][next[b]];</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br></pre></td></tr></table></figure><p><strong>这部分代码原理不是特别清楚，等有时间研究一下 <code>STL</code>标准库对优先队列的实现源码后再来补充说明</strong></p><p>优先队列部分资料参考自<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">这篇文章</a></p><h2 id="有序集合-set">有序集合 <code>set</code></h2><p>  <code>set</code> 是一个关联容器，它包含一组经过排序的<code>Key</code> 类型唯一对象。排序是使用键比较函数 <code>Compare</code>完成的。搜索、删除和插入操作具有对数复杂度。<code>set</code>通常以红黑树的形式实现。</p><p>  在标准库使用 <code>Compare</code>要求的任何地方，唯一性都是通过使用等价关系来确定的。用不精确的术语来说，如果两个对象<code>a</code> 和 <code>b</code>都不小于另一个，则认为它们是等价的：<code>！comp(a, b) &amp;&amp; !comp（b, a）</code>。</p><p>  以下是一个小的例子，展示 <code>set</code> 的创建以及<code>insert()</code>、<code>erase()</code>、<code>count() / contain()</code>等函数的使用，详情可以参考<a href="https://en.cppreference.com/w/cpp/container/set">cppreference</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> std::set&lt;T&gt;&amp; set)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (set.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;&#123; &quot;</span> &lt;&lt; *set.<span class="built_in">begin</span>();</span><br><span class="line">    std::for_each(std::<span class="built_in">next</span>(set.<span class="built_in">begin</span>()), set.<span class="built_in">end</span>(), [&amp;out](<span class="type">const</span> T&amp; element)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot; &#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; set&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; set &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    set.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; set &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    set.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; set &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; keys&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : keys)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="built_in">count</span>(key))</span><br><span class="line">            std::cout &lt;&lt; set &lt;&lt; <span class="string">&quot; does contain &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; set &lt;&lt; <span class="string">&quot; doesn&#x27;t contain &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    std::string_view word = <span class="string">&quot;element&quot;</span>;</span><br><span class="line">    <span class="function">std::set&lt;<span class="type">char</span>&gt; <span class="title">characters</span><span class="params">(word.begin(), word.end())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; characters.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; unique characters in &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">quoted</span>(word) &lt;&lt; <span class="string">&quot;:\n&quot;</span> &lt;&lt; characters &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>std::quoted()</code> 用于给字符串添加引号，这是<code>C++14</code> 引入的新特性。</li><li><code>set.contain()</code> 可以判断 <code>set</code>中是否包含某个元素，但这个函数是 <code>C++20</code>才引入的，如果是之前的版本可以使用 <code>set.count()</code>来代替，<code>count()</code> 的本意是计数，但由于 <code>set</code>每个键唯一，因此计数结果只有 <code>0</code> 和<code>1</code>，因此也可以用来判断集合是否包含某个元素。</li></ul></div><p>  其他在日常中可能会用到的函数（持续更新中）</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><th></th><th>功能</th></tr></thead><tbody><tr><td><code>clear()</code></td><td>清空一个 <code>set</code></td></tr><tr><td><code>empty()</code></td><td>判断一个 <code>set</code> 是否为空</td></tr><tr><td><code>size()</code></td><td>获取当前 <code>set</code> 中元素的个数</td></tr><tr><td><code>find(const T &amp;Key)</code></td><td>返回一个迭代器，查找给定键。</td></tr><tr><td><code>lower_bound(const T &amp;Key)</code></td><td>返回一个迭代器，其指向不小于给定键 <code>Key</code>的第一个元素，如果没有找到，返回 <code>end()</code></td></tr><tr><td><code>upper_bound(const T &amp;Key)</code></td><td>返回一个迭代器，其指向大于给定键 <code>Key</code>的第一个元素，如果没有找到，返回 <code>end()</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——内存</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="多维数组的创建及删除">多维数组的创建及删除</h2><h3 id="维数组的动态分配内存">1 维数组的动态分配内存</h3><p>  直接使用 <code>new</code> 关键字进行分配，指令为<code>int *arr = new int[50]</code>，这会分配一块<strong>连续的</strong>50 个 <code>int</code> 大小的内存空间，并且返回这块内存的首地址给到<code>arr</code>，<code>arr</code> 的类型为 <code>int *</code>。</p><h3 id="维数组的动态内存分配">2 维数组的动态内存分配</h3><p>  首先我们需要分配一块内存空间<code>a</code>，这块内存空间中的每一个值都是一个地址，指向另一块内存空间<code>b_i</code>的首地址，这样，我们便实现了二维数组的创建。例如，对于一个二维数组<code>arr2d[i][j]</code>，首先，我们取 <code>a[i]</code>中的值，这便是一个地址，我们顺着这个地址就能够找到第 <code>i</code>块内存<code>b_i</code>，之后我们锁定了这块内存。而由二维数组可知，这一块内存中每个里面存的便是具体的数据内容了。具体取哪个数据，便取决于<code>j</code> 啦！</p><h3 id="维数组的动态内存分配-1">3 维数组的动态内存分配</h3><p>  对于三维内存，此处就不再赘述了，无非是<code>arr3d[i][j][k]</code>，由 <code>i</code> 锁定第 <code>i</code>个内存块，不同于二维数组，这个内存块上存的仍然是其他内存块的首地址，也就是还是一个指针。我们再在这个基础上锁定其第<code>j</code> 个的地址，顺着找到第 <code>j</code>个内存块，这个内存块里面存的才是具体的数据内容，我们要取哪一个数据值呢？第<code>k</code> 个！</p><h3 id="多维数组的删除">多维数组的删除</h3><p>  多维数组的创建我们是通过一层层 <code>new</code>来实现的。同样的，删除我们也是要一层层来实现的。显然，我们正着创建多维数组，那么删除的时候就要倒着一层层来删除，否则，假设我们将前面的内存块给删了，由于他们保存着其他内存块首地址，删了他们我们就无法访问这些内存块了。因此，我们要先顺藤摸瓜，找到最根源的内存块，再一步步倒回来全部删干净。</p><p>  而删除一个内存块，我们可以使用 <code>delete[] arr</code>来实现。</p><div class="note info flat"><p>关于 <code>delete</code> 和 <code>delete[]</code>的区别以及如何使用：</p><ul><li><code>delete</code> 是用来配合 <code>new</code>来使用的，作用是<strong>删除 <code>new</code> 出来的单个对象<code>object</code></strong>。</li><li>而 <code>delete[]</code> 是用来配合 <code>new[]</code>使用的，作用是<strong>删除一个数组内的所有<code>object</code></strong>。</li></ul><p>而 <code>delete[]</code> 与 <code>new</code> 混用，或者<code>delete</code> 与 <code>new[]</code> 混用，都将导致未定义的行为(undefined behavior)。</p><p align="right">——参考自<a href="https://stackoverflow.com/questions/2425728/what-is-the-difference-between-delete-and-delete">stackoverflow-Whatis the difference between delete and delete[]?</a></p></div><h3 id="c-的具体实现"><code>C++</code> 的具体实现</h3><p>  具体的实现代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-D array</span></span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-D array</span></span><br><span class="line">    <span class="type">int</span> **arr2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr2d[<span class="number">0</span>][<span class="number">40</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-D array</span></span><br><span class="line">    <span class="type">int</span> ***arr3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr3d[i] = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; ++j) &#123;</span><br><span class="line">            arr3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr3d[<span class="number">40</span>][<span class="number">30</span>][<span class="number">20</span>] = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 1-D</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 2-D</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr2d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意的点">注意的点</h3><p>  由上述我们可以知道，每一个内存块内部的数据是连续的，<strong>但是，不同的内存块之间并不一定是连续的。</strong>这取决于操作系统的分配，很大程度上是不会连续的。因此，创建了多维数组之后，后续在索引具体某一个元素的值的时候，可能会出现<code>cache miss</code>，也就是缓存不命中的情况，这会使得我们程序的运行速度变慢。因此，并不推荐使用多维数组。取而代之，我们可以将数组扁平化，例如使用一维数组来代替二维数组，这会使得所有的数据在内存中全部连续，大大加快了读写的速度。例如<code>arr2d[i][j]</code> 可以写作 <code>arr[i * col + j]</code>的形式。</p><h2id="安全编程关于智能指针与原始指针的使用">安全编程，关于智能指针与原始指针的使用</h2><h3 id="智能指针的引入-c11">智能指针的引入 (<code>C++11</code>)</h3><p>  考虑如下的两种在实际编程中经常发生的事情：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> _THROW_BAD_ALLOC </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *ptr = std::<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, std::<span class="type">size_t</span> size)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;free &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_leak1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [[maybe_unused]] std::string *str = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some operation</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_leak2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string *str = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do some operation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// some goes wrong, return early</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this delete will not be implemented!</span></span><br><span class="line">    <span class="keyword">delete</span> str;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mem_leak1</span>();</span><br><span class="line">    <span class="built_in">mem_leak2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，<code>mem_leak1</code> 就是在函数中 <code>new</code>动态分配了内存空间，然后返回时忘记了删除掉。之后这一块内存将无法被再次引用，因为唯一的引用变量<code>std::string *str</code> 会随着函数返回销毁。而<code>mem_leak2</code>考虑到了在函数返回时要进行内存释放，但如果前面会出错、抛出异常等提前返回，那么<code>delete str</code>将不会被执行，因此这一块内存也没有被释放掉。久而久之，随着函数调用次数增多，越来越多的内存分配后未释放，导致了内存泄漏情况，程序占用的内存越来越大。</p><p>  重写 <code>new</code> 和 <code>delete</code>运算符，运行程序，观察程序的内存分配情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ pointer.cpp -o pointer.out -Wall -fsized-deallocation -std=c++17</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./pointer.out                                            </span><br><span class="line">allocating 24 bytes...</span><br><span class="line">allocating 24 bytes...</span><br></pre></td></tr></table></figure><p>  可以看到，程序只有内存的分配，而未有释放！！而智能指针的引入，就是让我们在<code>new</code> 完之后无需显性调用 <code>delete</code>释放内存，它会自动帮助我们做这件事情。智能指针可以分为以下的三种类型（<code>C++98</code>提出的 <code>auto_ptr</code> 已经被 <code>unique_ptr</code> 代替了，因此<code>C++11</code> 标准后不推荐使用了）：</p><h3 id="unique_ptr">unique_ptr</h3><p>  所谓的 <code>unique</code>，是 “唯一”的意思。就是说这块内存只能唯一地由这一个指针来引用，不能有两个及两个以上的指针同时引用这一块内存。为了做到这一点，其实是很简单的，我们只需要在创建这个类的时候把<code>=</code> 运算符以及拷贝构造函数给删除掉就可以了，以下是<code>unique_ptr.h</code> 源码的一部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBCPP_CXX03_LANG</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr <span class="type">const</span>&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>  可以看到，这里删除的只是左值引用的部分，而右值的并没有删除，也就是说可以继续使用。其实稍微思考以下就可以明白这样做的合理性。我们可以移动构造，将原先的指针给移走指向<code>0x0</code>，再把新指针指向这块内存。总的来说，还是只有一个指针引用这块内存，因此是合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">str</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get memory address</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.get(): &quot;</span> &lt;&lt; str.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong! this function has been deleted</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;std::string&gt; str2 = str;</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;std::string&gt; str3(str);</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;std::string&gt; str4 = std::<span class="built_in">move</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.get(): &quot;</span> &lt;&lt; str.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str4.get(): &quot;</span> &lt;&lt; str<span class="number">4.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------ unique_pointer begin</span><br><span class="line">allocating 24 bytes...</span><br><span class="line">str.get(): 0x14ae05e80</span><br><span class="line">str.get(): 0x0              // 此时原先的 unique_ptr 已经被移开指向 0x0 了</span><br><span class="line">str4.get(): 0x14ae05e80</span><br><span class="line">free 24 bytes...</span><br><span class="line">------ unique_pointer end</span><br></pre></td></tr></table></figure><p>  补充一点，我们其实还是可以很聪明地绕过 <code>unique</code>这一特性，使得多个 <code>unique_ptr</code>指向同一块内存，具体做法是我们先定义一个普通指针指向 <code>new</code>出来的内存地址，然后将其赋给 <code>unique_ptr</code>。之后我们再定义一个<code>unique_ptr</code>，再把 <code>new</code>出来的地址赋给它。也就是我们不借助 <code>unique_ptr</code>内部的赋值操作，因为这是已经删除的函数了，这样做肯定是不行的。我们用最原始的方法操作！<del><strong>大道至简</strong></del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_pointer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string *str = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">str2</span><span class="params">(str)</span></span>;</span><br><span class="line">    std::unique_ptr&lt;std::string&gt; str3;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2.get(): &quot;</span> &lt;&lt; str<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3.get(): &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str<span class="number">3.</span><span class="built_in">reset</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2.get(): &quot;</span> &lt;&lt; str<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3.get(): &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是这样的话会报错，因为后续会对同一块内存连续释放两次！运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">------ unique_pointer2 begin</span><br><span class="line">allocating 24 bytes...</span><br><span class="line">str2.get(): 0x14ae05e80</span><br><span class="line">str3.get(): 0x0</span><br><span class="line">str2.get(): 0x14ae05e80</span><br><span class="line">str3.get(): 0x14ae05e80</span><br><span class="line">free 24 bytes...</span><br><span class="line">free 24 bytes...</span><br><span class="line">pointer.out(90433,0x1f6b1cf40) malloc: Double free of object 0x14ae05e80</span><br><span class="line">pointer.out(90433,0x1f6b1cf40) malloc: *** set a breakpoint in malloc_error_break to debug</span><br><span class="line">zsh: abort      ./pointer.out</span><br></pre></td></tr></table></figure><h3 id="shared_ptr">shared_ptr</h3><p>  <code>share</code> 是 “共享” 的意思，与前面的<code>unique_ptr</code>做对比，很容易可以猜测这个指针允许多个指针指向同一块内存空间。那么它是如何管理内存如何释放的呢？是通过引用计数的方法。具体来说，每当有一个指针指向这块内存的时候，<code>shared_ptr</code>的引用计数就会加一，而每销毁一个指针的时候，那么这块内存空间的引用计数就会减一。当引用计数减到0的时候，就说明这块内存已经没有指针引用了，所以是时候应该释放它了！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::string *str = new std::string(&quot;Hello&quot;);</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;str address: &quot; &lt;&lt; str &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;std::string&gt; str2 = std::<span class="built_in">make_shared</span>&lt;std::string&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2.use_count(): &quot;</span> &lt;&lt; str<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;std::string&gt; <span class="title">str3</span><span class="params">(str2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2.use_count(): &quot;</span> &lt;&lt; str<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3.use_count(): &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;std::string&gt; <span class="title">str4</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;Hello&quot;</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str4.get(): &quot;</span> &lt;&lt; str<span class="number">4.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str4.use_count(): &quot;</span> &lt;&lt; str<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------ shared_pointer begin</span><br><span class="line">allocating 48 bytes...</span><br><span class="line">str2.use_count(): 1</span><br><span class="line">str2.use_count(): 2</span><br><span class="line">str3.use_count(): 2</span><br><span class="line">allocating 24 bytes...      // 为 new std::string(&quot;Hello&quot;) 分配内存</span><br><span class="line">allocating 32 bytes...      // 为 shared_ptr 分配所需的内存</span><br><span class="line">str4.get(): 0x139605e80</span><br><span class="line">str4.use_count(): 1</span><br><span class="line">free 24 bytes...</span><br><span class="line">free 32 bytes...</span><br><span class="line">free 48 bytes...</span><br><span class="line">------ shared_pointer end</span><br></pre></td></tr></table></figure><p>  由第一部分，我们可以看出对于<code>shared_ptr</code>，是允许将一个共享指针赋值给另一个的，此时各自的引用计数都会加一，可以使用<code>.use_count()</code> 函数来查看这一点。</p><p>  第二部分想要表达的意思是对于 <code>shared_ptr</code>的初始化问题。我们可以使用普通的 <code>new</code>来进行初始化。此外，我们也可以使用专门的<code>make_shared&lt;&gt;</code>函数来初始化。可以预见，既然有了专用的初始化函数，那么它肯定至少是不会差过直接<code>new</code> 的，甚至会表现的更好。查阅 <code>stackoverflow</code>论坛的解释（<a href="https://stackoverflow.com/questions/18301511/stdshared-ptr-initialization-make-sharedfoo-vs-shared-ptrtnew-foo">此处链接</a>），<code>make_shared&lt;&gt;</code>确实有着更好的表现，它只需要分配一次内存。而使用 <code>new</code>会有两次内存分配，一次是 <code>new</code>构造出传入的这个对象，之后还需要再进行一次内存分配，用于分配<code>shared_ptr</code>运行所需要的引用计数等的块内存。同时，它还避免了任何内存泄漏的可能性，因为永远不会有指向托管对象的原始指针。<strong><em>但它有一个潜在的缺点，即如果仍然有弱指针阻止共享计数被删除，那么在对象销毁时内存将不会被释放？（不太理解）</em></strong></p><p>  使用共享指针可能会存在循环引用的问题。考虑如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_bar</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Bar&gt; &amp;bar)</span> </span>&#123;</span><br><span class="line">        m_bar = bar;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Bar&gt; m_bar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bar&#x27;s constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bar</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bar&#x27;s destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_foo</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Foo&gt; &amp;foo)</span> </span>&#123;</span><br><span class="line">        m_foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Foo&gt; m_foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_pointer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Bar&gt; bar = std::<span class="built_in">make_shared</span>&lt;Bar&gt;();</span><br><span class="line">    std::shared_ptr&lt;Foo&gt; foo = std::<span class="built_in">make_shared</span>&lt;Foo&gt;();</span><br><span class="line">    bar-&gt;<span class="built_in">set_foo</span>(foo);</span><br><span class="line">    foo-&gt;<span class="built_in">set_bar</span>(bar);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bar.use_count(): &quot;</span> &lt;&lt; bar.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo.use_count(): &quot;</span> &lt;&lt; foo.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们声明并定义了两个类 <code>Foo</code> 和<code>Bar</code>，其类中各有彼此的一个智能指针成员变量。之后我们各实例化出一个对象，并将各自赋给对面的成员变量中。这个时候神奇的事情就会发生了——当我们这个函数返回的时候，两个智能指针并没有自动销毁释放内存。这是为什么呢？</p><p>  程序运行结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------ shared_pointer2 begin</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">Bar&#x27;s constructor.</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">Foo&#x27;s constructor.</span><br><span class="line">bar.use_count(): 2</span><br><span class="line">foo.use_count(): 2</span><br><span class="line">------ shared_pointer2 end</span><br></pre></td></tr></table></figure><p>  显然，对于每一块内存的引用计数都是2，这一点是很容易理解的。因为有一个实例对象，以及另一个实例中的一个成员变量都引用了这一块内存。对于上述的代码，我们需要理解的是，<code>bar</code>和 <code>foo</code> 这两个变量都是定义在 <code>shared_pointers()</code>这个函数区域的栈上的。当这个函数返回的时候，这两个变量都要销毁，因此每一块内存的引用计数都会减1，即引用计数变为1。然后…然后就没有然后了。是的，因为两者的引用计数都没有变为1，因此这两块内存都不会被释放。</p><p>  值得注意的是，如果没有出现交叉现象，只是单方面的某一方保存了另一方的引用，则不会发生这个现象。例如我们在上方的代码中将<code>foo-&gt;set_bar(bar);</code>这一句给注释掉，则函数返回后能够正常释放内存，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------ shared_pointer2 begin</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">Bar&#x27;s constructor.</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">Foo&#x27;s constructor.</span><br><span class="line">bar.use_count(): 1</span><br><span class="line">foo.use_count(): 2</span><br><span class="line">Bar&#x27;s destructor.</span><br><span class="line">Foo&#x27;s destructor.</span><br><span class="line">free 40 bytes...</span><br><span class="line">free 40 bytes...</span><br><span class="line">------ shared_pointer2 end</span><br></pre></td></tr></table></figure><p>  这是因为注释掉了 <code>foo-&gt;set_bar(bar);</code>，那么<code>bar</code> 所指向的内存引用计数只有1，因此当函数返回的时候，<code>bar</code> 指向的内存引用计数减 1 变为0，所以 <code>bar</code>这部分的内存会释放掉。而这部分的内存释放掉的时候，就相当于新构造的<code>Bar</code> 实例销毁了，因此会调用 <code>Bar</code>的析构函数，因此会销毁其成员变量 <code>m_foo</code>，所以<code>foo</code> 的内存引用计数减 1。之后，<code>foo</code>这个在函数内创建的变量也会销毁，导致这块内存的引用计数又会减1。因此就会变为 0 了，所以一系列的雪崩式链式反应导致 <code>foo</code>的内存也被释放了。（注意释放的顺序是先 <code>Bar</code> 后<code>Foo</code>，因为只有 <code>Bar</code> 释放了 <code>Foo</code>才会释放）</p><h3 id="weak_ptr">weak_ptr</h3><p>  <code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code>而引入的一种智能指针来协助 <code>shared_ptr</code> 工作, 它只可以从一个<code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 对象构造,它的构造和析构不会引起引用记数的增加或减少。 同时 <code>weak_ptr</code>没有重载 <code>*</code> 和 <code>-&gt;</code> 但可以使用<code>lock</code> 获得一个可用的 <code>shared_ptr</code> 对象。</p><p>  解决循环引用的问题，我们可以让其中一个类中维护另一个类的一个<code>weak_ptr</code> 而非<code>shared_ptr</code>，这样它就不参与引用计数了。修改 <code>Foo</code>和 <code>Bar</code> 为 <code>weak</code> 版本，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeakFoo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WeakFoo</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WeakFoo</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_bar</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;WeakBar&gt; &amp;bar)</span> </span>&#123;</span><br><span class="line">        m_bar = bar;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;WeakBar&gt; m_bar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakBar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WeakBar</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WeakBar&#x27;s constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">WeakBar</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WeakBar&#x27;s destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_foo</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;WeakFoo&gt; &amp;foo)</span> </span>&#123;</span><br><span class="line">        m_foo = foo;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::weak_ptr&lt;WeakFoo&gt; m_foo;       <span class="comment">// 其实只是这里做了修改，使用了 `weak_ptr`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">weak_pointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;WeakBar&gt; bar = std::<span class="built_in">make_shared</span>&lt;WeakBar&gt;();</span><br><span class="line">    std::shared_ptr&lt;WeakFoo&gt; foo = std::<span class="built_in">make_shared</span>&lt;WeakFoo&gt;();</span><br><span class="line">    bar-&gt;<span class="built_in">set_foo</span>(foo);</span><br><span class="line">    foo-&gt;<span class="built_in">set_bar</span>(bar);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bar.use_count(): &quot;</span> &lt;&lt; bar.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo.use_count(): &quot;</span> &lt;&lt; foo.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行上述的 <code>weak_pointer()</code>，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------ weak_pointer begin</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">WeakBar&#x27;s constructor.</span><br><span class="line">allocating 40 bytes...</span><br><span class="line">Foo&#x27;s constructor.</span><br><span class="line">bar.use_count(): 2</span><br><span class="line">foo.use_count(): 1</span><br><span class="line">Foo&#x27;s destructor.</span><br><span class="line">WeakBar&#x27;s destructor.</span><br><span class="line">free 40 bytes...</span><br><span class="line">free 40 bytes...</span><br><span class="line">------ weak_pointer end</span><br></pre></td></tr></table></figure><p>  可以看到，正是由于 <code>WeakBar</code> 中使用了<code>weak_ptr</code> 引用 <code>Foo</code>，因此 <code>foo</code>的引用计数只有 1，因此两者都可以正常释放内存。（注意释放的顺序）</p><h3 id="智能指针使用的陷阱">智能指针使用的陷阱</h3><ul><li><strong>不要把一个原生指针给多个智能指针管理</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="function">unique_ptr&lt; <span class="type">int</span> &gt; <span class="title">up1</span><span class="params">(x)</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt; <span class="type">int</span> &gt; <span class="title">up2</span><span class="params">(x)</span></span>;</span><br><span class="line"><span class="comment">// 警告! 以上代码使up1 up2指向同一个内存,非常危险</span></span><br></pre></td></tr></table></figure><p>  或以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">up<span class="number">1.</span><span class="built_in">reset</span>(x);</span><br><span class="line">up<span class="number">2.</span><span class="built_in">reset</span>(x);</span><br></pre></td></tr></table></figure><ul><li><strong>记得使用 <code>u.release()</code> 的返回值</strong></li></ul><p>  在调用 <code>u.release()</code>时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.</p><ul><li><strong>禁止 <code>delete</code> 智能指针 <code>get</code>函数返回的指针</strong></li></ul><p>  如果我们主动释放掉 <code>get</code>函数获得的指针，那么智能指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果!</p><ul><li><strong>禁止用任何类型智能指针 <code>get</code>函数返回的指针去初始化另外一个智能指针！</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt; <span class="type">int</span> &gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// 一个典型的错误用法 shared_ptr&lt; int &gt; sp4(sp1.get());</span></span><br></pre></td></tr></table></figure><blockquote><p align="right">——智能指针部分参考自<a href="https://blog.csdn.net/cpp_learner/article/details/118912592">C++智能指针 - 全部用法详解</a></p></blockquote><h3 id="总结对比原始指针与智能指针">总结对比原始指针与智能指针</h3><p>  智能指针是对原始指针的包装，能够自动管理内存，在我们不再需要某一块内存时能够自动释放，减少了程序员的工作量，同时避免了因疏忽导致的内存泄漏问题。在进行一些大型或生产项目的时候，推荐使用智能指针进行内存管理。</p><p>  但原始指针使用起来更加方便、简单，只需要一个小小的 <code>*</code>即可。在写一些较小的项目、编程测试时，还是可以使用的。并且，使用原始指针能够让我们对内存管理等有更加清晰深刻的理解。</p><h2 id="跟踪内存分配的简单方法">跟踪内存分配的简单方法</h2><p>  无需借助外部工具，我们可以通过重载 <code>new</code> 和<code>delete</code>来实现跟踪内存分配与释放的情况。以下是一个简单的示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序运行结果：</p><div class="note info flat"><p><strong>注意在 <code>g++</code> 中，默认使用的 <code>delete</code>函数是不带有第二个参数 <code>size_t size</code>的，因为这一信息已经会被内部的内存管理器保留，无需再次传入。但我们要想探测内存释放的情况，还是有必要传入的。我们可以通过对编译时传入参数<code>-fsized-deallocation</code> 来使用这一个版本的 <code>delete</code>函数。</strong></p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">Allocating 32 bytes</span><br><span class="line">Allocating 12 bytes</span><br><span class="line">freeing 12 bytes</span><br></pre></td></tr></table></figure><p>我们可以进一步将其进行包装成一个类或结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics s_AllocationMetrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalAllocated += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalFreed += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintCurrentUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current Usage: &quot;</span> &lt;&lt; s_AllocationMetrics.<span class="built_in">CurrentUsage</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">        <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针">函数指针</h2><h3 id="函数指针的概念">函数指针的概念</h3><p>  “函数指针” 和 “指针函数” 是不同的概念，所谓的 “指针函数”就是指一个返回类型是指针的函数，例如 <code>int *func(int a)</code>返回类型是<code>int *</code>，即一个指针，没啥好讲的，此处略过，重点来看“函数指针”。</p><p>  学过一点计算机体系结构或偏底层的汇编知识应该知道，函数名称其实就是一个地址。每次我们调用函数的时候，实际上就是保存当前帧(frame)的状态，将参数压栈，然后跳到函数名称所指的地址处，将传入的参数弹出使用，执行内部的代码。在<code>C++</code>中，我们可以额外定义变量，来调用使用其他的函数，具体的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[value]: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>);</span><br><span class="line">    func_ptr = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr2)(<span class="type">int</span>) = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr2</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    <span class="type">void</span> *addr = (<span class="type">void</span> *)printValue;</span><br><span class="line">    ((<span class="built_in">void</span> (*)(<span class="type">int</span>))addr)(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addition</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;function address: &quot;</span> &lt;&lt; (<span class="type">void</span> *)printValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; printValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们定义了一个打印值的函数<code>printValue(int)</code>，之后我们定义函数指针<code>func_ptr</code>，我们要指定返回类型，以及参数列表。只要能和它这两者相匹配的，我们便可以对其赋值，并使用这个函数指针来调用函数。  <code>case 1</code>是先定义，然后在后续再赋值使用；<code>case 2</code>是在定义的时候就直接赋值使用了；而 <code>case 3</code>则是我们可以强行取函数的地址，之后再将这个地址强制转成对应的函数指针类型，也是可以正常使用的，不过这样做除了装一下没啥实际意义。</p><div class="note danger flat"><p>注意，我们在取函数的地址的时候，一定要使用 <code>void *</code>进行类型的强制转换，否则仅仅放一个函数指针的话，会执行内部的<code>bool()</code> 运算符，将其转为一个布尔值，并且永远都是<code>true</code>。 警告信息：<strong><em>warning: address of function‘printValue’ will always evaluate to ‘true’[-Wpointer-bool-conversion]</em></strong></p></div><p>  <code>C++</code>内部做了隐式转换，因此无论是下面代码中的哪两种，都是可以正常运行的。函数名在大多数的上下文里都会被隐式转成函数指针。函数名的签名为<code>void printValue(int a)</code>，而函数指针的签名为<code>void (*func_ptr)(int a)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func_ptr = printValue;</span><br><span class="line">func_ptr = &amp;printValue;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line">(*func_ptr)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="函数指针的应用场景">函数指针的应用场景</h3><p>  例如我们现在有了一个 <code>vector</code>，以及一个遍历函数<code>forEach()</code>，我们可以在 <code>forEach()</code>函数中传入一个函数指针，表明我们想在遍历的时候做什么操作，例如最简单的只是打印每个元素，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    forEach(vec, printVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶-lambda-表达式">进阶 —— <code>lambda</code> 表达式</h3><h4 id="lambda-表达式概念"><code>lambda</code> 表达式概念</h4><p>  <code>lambda</code>表达式是一种创建函数的方式，可以使我们不必实际创建函数。也就是这个函数更像是一个变量，而非真正意义上的函数。<strong>在能够使用函数指针的地方，我们都可以使用<code>lambda</code> 表达式。</strong>   我们希望能够将一个函数传递给一个<code>API</code>，以便在将来的某个时候，它能够为我们调用这个函数解决问题。此刻我们不这样做的原因是我们还没有函数执行所需要用到的数据，或者我们只是想推迟函数的执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line">    forEach(vec, lambda);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当捕获列表 <code>[]</code> 为空的时候，<code>C++</code>内部会为我们调用转换函数<code>ClosureType::operator ret(*)(params)()</code> 将<code>lambda</code>表达式转成不同的函数指针，但当捕获列表不为空的时候，我们就不能使用普通的函数指针了，这个时候就需要用到<code>&lt;functional&gt;</code> 库。</p><p>  下面举一个实际能够用到 <code>lambda</code>表达式的例子。例如，我们调用 <code>std::find_if</code> 库，取得一个<code>vector</code> 中第一个大于 3 的数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func_ptr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> val) &#123;<span class="keyword">return</span> val &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获列表形式">捕获列表形式</h4><p>  <code>lambda</code> 表达式的捕获列表形式如下表所示，节选自<a href="https://en.cppreference.com/w/cpp/language/lambda">cppreference</a></p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><th></th><th>explanation</th></tr></thead><tbody><tr><td><code>identifier</code></td><td>simple by-copy capture</td></tr><tr><td><code>identifier ...</code></td><td>simple by-copy capture that is a pack expansion</td></tr><tr><td><code>identifier initializer</code></td><td>by-copy capture with an initializer<font color="darkgreen"><strong>(since C++14)</strong></font></td></tr><tr><td><code>&amp; identifier</code></td><td>simple by-reference capture</td></tr><tr><td><code>&amp; identifier ...</code></td><td>simple by-reference capture that is a pack expansion</td></tr><tr><td><code>&amp; identifier initializer</code></td><td>by-reference capture with an initializer<font color="darkgreen"><strong>(since C++14)</strong></font></td></tr><tr><td><code>this</code></td><td>simple by-reference capture of the current object</td></tr><tr><td><code>* this</code></td><td>simple by-copy capture of the current object<font color="darkgreen"><strong>(since C++17)</strong></font></td></tr><tr><td><code>... identifier initializer</code></td><td>by-copy capture with an initializer that is a pack expansion<font color="darkgreen"><strong>(since C++20)</strong></font></td></tr><tr><td><code>&amp; ... identifier initializer</code></td><td>by-reference capture with an initializer that is a pack expansion<font color="darkgreen"><strong>(since C++20)</strong></font></td></tr></tbody></table><h4 id="lambda-表达式原理"><code>lambda</code> 表达式原理</h4><p>  本质上，<code>lambda</code> 表达式就是一个重载了<code>operator()</code> 的类，我们可以用<a href="https://cppinsights.io/">cppinsights</a>来查看这一点。例如对于下列的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> f = [=](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + a;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们在 <a href="https://cppinsights.io/">cppinsights</a>上运行，得到 insight 后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_7_13</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (x + y) + a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_7_13(__lambda_7_13 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_7_13(<span class="type">int</span> &amp; _a)</span><br><span class="line">    : a&#123;_a&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_7_13 f = __lambda_7_13(__lambda_7_13&#123;a&#125;);</span><br><span class="line">  f.<span class="built_in">operator</span>()(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  通过查看编译后的代码，我们应该对 <code>lambda</code>表达式有了更深的理解。同时，在使用的时候，我们应该发现了，当我们以值传递的形式向捕获列表传值的时候，在<code>lambda</code>函数内部是不允许我们修改它的。例如对于上述的代码，我要想在<code>lambda</code> 表达式中写入 <code>a = 10</code>就会报错。因为通过编译后的代码，我们发现，<code>operator()</code>被声明成了<code>const</code>，也就是不允许在这个函数内部修改类的成员变量。接着看下去，我们会发现<code>lambda</code>这个类的构造函数，就是<strong>接受捕获列表的参数，作为自己的成员变量！！</strong>因此，如果我们不把<code>operator()</code> 声明成<code>const</code>，就会有奇怪的事情发生，也就是我们可以修改类内部的<code>a</code>，让它与外部的 <code>a</code> 不同，此时每次运行<code>f()</code>，就会得到不同的答案，这会是很令人困惑的。例如，用下面代码举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==== epoch 1: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==== epoch 2: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==== epoch 2: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行的结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ test.cpp -o test.out -Wall -std=c++11</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./test.out </span><br><span class="line">==== epoch 1: </span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">==== epoch 2: </span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">==== epoch 2: </span><br><span class="line">10</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>  通过 <code>mutable</code> 关键字，我们可以强制改变<code>operator() const</code>，让内部可以修改值传递的捕获列表参数。可以看到，似乎我们每次调用<code>f()</code>，它会对 <code>x</code>做自增的操作。因为每次调用都会把外部的 <code>x = 10</code>作为参数传入，那么每一轮的输出结果都应该是<code>10 11</code>。但从结果来看，它是有记忆的，第二次在 <code>11</code>的基础上自增变为 <code>12</code>，第三次在 <code>12</code>的基础上自增变为 <code>13</code>。要解释这里，就要看我们前面编译后的<code>lambda</code>表达式，我们可以看到，捕获列表传入的参数，会以成员变量的形式保存在<code>lambda</code> 这个类中，因此，如果我们强制修改 <code>lambda</code>表达式为 <code>mutable</code>，可能会造成一些不易察觉的bug，因此最好不要这么做！就让值传递的 <code>operator()</code> 保持为<code>const</code>！</p><h2 id="栈-stack-vs-堆-heap">栈 <code>stack</code> vs 堆<code>heap</code></h2><p>  尽管堆和栈是不同的概念，但在物理层面，它们是相同的，都是一块<code>RAM</code>内存，只是我们认为将其进行了区分（<strong>因此栈内存分配并不是在<code>CPU</code> 缓存上，而是在计算机的 <code>RAM</code>上的</strong>）每个应用程序运行的时候，操作系统都会给我们分配一定区域的堆栈空间供我们使用。一般情况下，我们直接声明定义的变量都是在栈<code>stack</code> 上的，只有调用 <code>new</code>动态分配内存声明定义的变量才是在堆上的。  在栈上分配内存是十分快捷的，可以在一个指令时间内完成。因为我们所需要做的仅仅只是将栈顶指针指向的空间内赋予有效数据，然后再将栈顶指针进行移动即可。而在堆上分配就会十分的慢了，因为我们要使用<code>new</code> 命令分配内存，然后 <code>new</code> 命令调用<code>malloc</code>函数询问相应的操作系统分配所需大小的内存空间，操作系统再通过查询空闲内存表来确定要分配哪一块内存。因此会涉及到许多的底层操作，分配起来就会很慢。  同时，访问速度上，由上述我们可以得知，栈上分配的内存一般都是连续的，因为我们的栈顶指针<code>SP</code>一直是在连续自增或自减的。因此，我们访问时一般所有的数据都是连续存放在一起的，访问一个数据的同时很容易就能访问到另一个数据，这在我们想要访问不同数据时可以加快访问的速度。对比之下，在堆上就不是这么一回事了，因为我们每次调用<code>malloc</code>，都是取决于操作系统根据空闲内存表决定给我们分配哪一块内存，谁都不能保证两次调用的<code>malloc</code>返回的内存空间是连续在一起的。因此访问起来就会慢很多，涉及到<font color="skyblue"><strong>缓存不命中 (cache missed)</strong></font>问题。  因此，一般来说，我们尽可能要在栈上分配内存，除非我们<strong>想要一个变量的生命周期要比其所在的函数（作用域）长</strong>（因为栈上分配的内存的生命周期都在一个作用域内。例如我们在一个函数<code>f</code>内声明了一个变量，那么当这个函数结束返回的时候，栈顶指针便会直接恢复到之前调用<code>f</code> 之前的位置，也就会造成 <code>f</code>内的栈上变量无效，对应的生命周期结束），或者<strong>实在是有比较大的数据量</strong>，我们会想要在堆上分配内存。  总的来说，造成堆和栈区别的本质原因在于 “分配”。  文章推荐：<a href="https://blog.csdn.net/m0_47324800/article/details/134674765">堆和栈的效率比较</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——线程</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的基本使用">线程的基本使用</h2><p>  线程的作用：优化程序，可以让程序在同一时间能够执行多个指令，加快程序的运行速度。  要使用进程，首先需要引入头文件<code>#include &lt;thread&gt;</code></p><ul><li>创建进程，使用<code>std::thread threadName(functionPointer)</code>，需要传入一个函数指针，表示想要执行的操作的函数。</li><li>让某些指令需要在该线程执行完之后再执行，使用<code>threadName.join()</code>，该函数后面的函数只有在这个进程结束后才会执行。</li><li>在一个进程中，可以使用 <code>std::this_thread</code>来表示当前的进程，可用其中的 <code>get_id()</code> 函数来获取当前进程的id，使用 <code>sleep_for()</code> 来将进程延时，防止某个进程单独消耗 CPU过多的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> isFinished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workingFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isFinished) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(workingFn)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    isFinished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了使用例如 <code>1s</code> 这种一个常值量后面跟一个<code>s</code> 单位表示时间的变量，我们需要使用命名空间<code>std::literals::chrono_literals;</code>，并且该命名空间在<code>C++14</code> 中支持，如果当前的编译器报错，需要显性指定<code>C++</code> 版本，如<code>g++ -std=c++14 main.cpp -o main</code>，或者修改编译器的默认配置。</p><h2 id="计时相关操作">计时相关操作</h2><p>  <code>C++11</code> 中引入了<code>std::chrono</code>，用于一种与平台无关的高精度计时。当然，也可以使用操作系统相关的API，这会提供更多的精度以及其他方面的控制。在一般情况下，<code>std::chrono</code>就已经够用了。   同样，我们应该引入库文件<code>#include &lt;chrono&gt;</code>。</p><ul><li>获取当前时间，使用<code>std::chrono::high_resolution_clock::now()</code>指令，这个函数返回的类型为<code>std::chrono::time_point&lt;std::chrono::steady_clock&gt;</code>，一般情况下，我们可以直接使用<code>auto</code> 关键字。</li><li>两个上述类型的时间相减，有额外的类型用来表示，这就是<code>std::chrono::duration&lt;float&gt;</code>，即初到末的“持续时间”。</li><li>打印输出的时候，要使用 <code>.count()</code>函数获取具体的时间数值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>() &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Timer</span>() &#123;</span><br><span class="line"></span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">        std::chrono::duration&lt;<span class="type">float</span>&gt; duration_ms = duration * <span class="number">1000.0f</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; duration_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Timer timer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用计时来进行基准测试">使用计时来进行基准测试</h2><p>  评测 <code>C++</code>程序运行的性能指标有很多，其中一种便是查看程序从开始到结束运行的总时长，这就可以用到我们上述学到的计时相关内容。例如，我们可以写一个<code>Timer</code>类，构造时获取当前时间开始计时，析构时再次获取当前时间并结算经过的时间总长，这样我们把它放在一个局部的作用于内，就可以用来评测局部作用域内代码执行的总耗时。例如，下述的例子我们评测<code>unique_ptr</code> 和 <code>shared_ptr</code> 以及类型转换与<code>make_unique</code> 这类函数的执行用时。</p><p>  以下是我们用到的计时器的类定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>() &#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(start_time).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(end_time).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> duration_us = end - start;</span><br><span class="line">        <span class="type">double</span> duration_ms = duration_us * <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; duration_us &lt;&lt; <span class="string">&quot;us (&quot;</span> &lt;&lt; duration_ms &lt;&lt; <span class="string">&quot; ms)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  然后是我们的主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#123;   </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared ptr use make_shared()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">make_shared</span>&lt;Vector2&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared ptr use new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">shared_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;unique ptr use make_unique&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; uniquePtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            uniquePtrs[i] = std::<span class="built_in">make_unique</span>&lt;Vector2&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;unique ptr use new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; uniquePtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            uniquePtrs[i] = std::<span class="built_in">unique_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">shared ptr use make_shared()</span><br><span class="line">It took: 2570us (2.57 ms)</span><br><span class="line">shared ptr use new</span><br><span class="line">It took: 2077us (2.077 ms)</span><br><span class="line">unique ptr use make_unique</span><br><span class="line">It took: 747us (0.747 ms)</span><br><span class="line">unique ptr use new</span><br><span class="line">It took: 737us (0.737 ms)</span><br></pre></td></tr></table></figure><p>  可以看到 <code>make_shared</code> 和 <code>make_unique</code>确实是要比 <code>new</code> 之后再进行类型转换要快很多。而且<code>shared_ptr</code> 要比 <code>unique_ptr</code> 慢很多，以下是 GPT解释的原因：</p><p>  <strong>1. 共享所有权</strong>   <code>std::unique_ptr</code>表示对对象的独占所有权。它的实现相对简单，只需管理一个指针。由于没有其他指针指向同一个对象，内存的释放也非常直接和高效。  <code>std::shared_ptr</code> 允许多个 <code>shared_ptr</code>实例共享同一个对象的所有权。为了实现这一点，<code>shared_ptr</code>需要维护一个引用计数（reference count），以跟踪有多少个<code>shared_ptr</code> 实例指向同一个对象。</p><p>  <strong>2. 引用计数的管理</strong>  <strong>引用计数：</strong>每当创建一个 <code>shared_ptr</code>或复制一个 <code>shared_ptr</code> 时，都会增加引用计数；当<code>shared_ptr</code>被销毁或重置时，会减少引用计数。这涉及到原子操作（atomicoperations），以确保在多线程环境中引用计数的安全性和一致性。  <strong>性能开销：</strong>这些原子操作（例如增加或减少计数）引入了一定的性能开销。相比之下，<code>unique_ptr</code>的操作不需要额外的同步机制。</p><p>  <strong>3. 内存管理</strong>  <strong>控制块：</strong><code>shared_ptr</code>还需要一个控制块（controlblock），该控制块存储引用计数和可能的弱引用计数（<code>std::weak_ptr</code>）。这意味着<code>shared_ptr</code> 需要额外的内存开销来管理这些信息。  <strong>内存分配：</strong>每次创建 <code>shared_ptr</code>时，它通常需要分配额外的内存来存储控制块，这增加了内存分配的频率和复杂性。</p><p>  <strong>4. 线程安全</strong>  <strong>线程安全的考虑：</strong>由于 <code>shared_ptr</code>可能在多个线程中共享，必须确保对引用计数的操作是线程安全的。这使得<code>shared_ptr</code> 的实现更复杂，并可能导致性能降低。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——命名空间</title>
      <link href="/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="命名空间-namespace">命名空间 <code>namespace</code></h2><p>  在 <code>C</code>中，我们只能通过给函数名称前加上独有的前缀来避免命名冲突，例如对于<code>GLFW</code> 库，这是一个 <code>C</code> 库，其中的所有函数都是以<code>GLFW</code> 开头，例如 <code>GLFWInit()</code>。同样的还有<code>OpenGL</code> 库，例如 <code>glInit()</code> 等。   在<code>C++</code>中，我们可以通过命名空间来<strong>解决多个相同函数名命名冲突的问题。</strong>  <code>using namespace</code>只在当前作用域中有效。尽量不要乱用，可以仅在一个 <code>if</code>语句中使用，实在不行再考虑加到源文件的开头，但永远不要用在头文件中！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> function &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名空间同样支持赋值操作</span></span><br><span class="line">    <span class="keyword">namespace</span> a = apple::function;</span><br><span class="line">    a::<span class="built_in">print2</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于下面</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> function;</span><br><span class="line">    <span class="built_in">print2</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么不建议使用-using-namespace-std">为什么不建议使用<code>using namespace std</code></h2><p>  因为这样做会污染空间，可能导致自己不知道这个函数或类型究竟是来自哪里，尤其是当自己写的函数与标准库例如<code>std</code>中名称相同时，好的情况下会报错有歧义，但坏的情况可能依据某些规则选择了其中之一，而恰恰这不是我们想要的那一个，大大增加了出bug 的风险。   例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        std::string temp = str;</span><br><span class="line">        std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; temp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    apple::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);      <span class="comment">// output: Hello</span></span><br><span class="line">    orange::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// output: olleH</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);             <span class="comment">// output: olleH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由上面的代码以及输出结果可以看到，<code>print("Hello)</code>并没有报歧义的错误，而是选择了 <code>orange</code>命名空间。这是因为传入的参数 <code>"Hello</code> 本质上是一个<code>const char *</code>，所以 <code>orange</code>不会做类型转换，可以直接调用，而 <code>apple</code>会做一次隐式转换，将其转成 <code>std::string</code>类型。综合来看，会选择 <code>orange</code>。而假如我们期望是使用<code>apple</code>，那么这里就会出 bug 咯。</p><p>  最后，一定要牢记一条：<strong>永远 永远永远不要在头文件里面使用命名空间<code>using namespace</code>，Never！</strong>。头文件的<code>include</code>原理就是直接把文件原封不动地搬过来贴在源文件的开头，也就是一旦在头文件中使用了<code>using namespace</code>，那么所有引入它的源文件都会使用了这个命名空间，出了问题的话，emmmmm……</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录0——杂项</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%950%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%950%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="一图流背景">一图流背景</h2><h2 id="获取网页帧率并显示">获取网页帧率并显示</h2><h3 id="html-.pug-部分">html (.pug) 部分</h3><p>  我们不必新创建一个 pug 文件，可以直接在已有的基础上进行添加。在<code>layout/includes/layout.pug</code> 中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    footer#footer(style=footer_bg)</span><br><span class="line">    !=partial(&#x27;includes/footer&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  </span><br><span class="line">+    #leftside-fps</span><br><span class="line">+      span#leftside-fps-text</span><br><span class="line"></span><br><span class="line">    include ./rightside.pug</span><br><span class="line">    include ./additional-js.pug</span><br></pre></td></tr></table></figure><h3 id="css-.styl-部分">css (.styl) 部分</h3><p>  这一部分没有合适的现成文件了，我们可以手动创建一个<code>leftside-fps.styl</code> 文件，放置在<code>/source/css/_layout/</code>目录下，代码如下，主要是让他固定在页面的左下角，再进行一些美化，例如字体、圆角、背景颜色等等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#leftside-fps</span></span><br><span class="line">  <span class="attribute">position</span>: fixed</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">8px</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">8px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">8</span>)</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span></span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#leftside-fps-text</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br></pre></td></tr></table></figure><h3 id="js-部分">js 部分</h3><p>  写一份获取帧率的 js 代码，命名为<code>getFps.js</code>，放置在自己的 <code>source</code>目录下，原理很简单，代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> frameCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> lastTime = performance.<span class="title function_">now</span>();</span><br><span class="line">    $leftsizeFpsTextEle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;leftside-fps-text&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateFPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = performance.<span class="title function_">now</span>();</span><br><span class="line">        frameCount++;</span><br><span class="line">        <span class="comment">// print the frameCount every second</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            $leftsizeFpsTextEle.<span class="property">innerText</span> = <span class="string">`FPS: <span class="subst">$&#123;frameCount&#125;</span>`</span></span><br><span class="line">            frameCount = <span class="number">0</span>; <span class="comment">// reset</span></span><br><span class="line">            lastTime = currentTime; <span class="comment">// update</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(updateFPS); <span class="comment">// request the next frame</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(updateFPS);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录3——导航栏部分</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%953%E2%80%94%E2%80%94%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%83%A8%E5%88%86/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%953%E2%80%94%E2%80%94%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>这一部分比较多，主要是因为我自己引入了一个音乐播放器的部分。</p><h2 id="导航栏-nav-布局修改">导航栏 <code>nav</code> 布局修改</h2><h3 id="搜索按钮置于右上角">搜索按钮置于右上角</h3><p>  找到<code>layout/includes/nav.pug</code>，让搜索按钮位于最后面，只需要将<code>theme.menu</code> 和 <code>theme.search</code>两段代码交换位置即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#menus</span><br><span class="line">if theme.menu</span><br><span class="line">    != partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    #toggle-menu</span><br><span class="line">    span.site-page</span><br><span class="line">    i.fas.fa-bars.fa-fw</span><br><span class="line">    </span><br><span class="line">if theme.search.use</span><br><span class="line">    #search-button</span><br><span class="line">    span.site-page.social-icon.search</span><br><span class="line">        i.fas.fa-search.fa-fw</span><br><span class="line">        span= &#x27; &#x27; + _p(&#x27;search.title&#x27;)</span><br></pre></td></tr></table></figure><h3 id="菜单栏居中">菜单栏居中</h3><p>  修改导航栏显示菜单居中，样式相关，找到<code>css/_layout/head.styl</code>，修改 <code>menus_item</code>样式如下：<strong>（已被弃用，因为后续要将音乐播放器放置在中间，所以菜单栏依旧让其靠右）</strong></p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menus_items</span></span><br><span class="line">    <span class="attribute">display</span>: inline</span><br><span class="line">+    <span class="attribute">position</span>: absolute</span><br><span class="line">+    <span class="attribute">width</span>: fit-content</span><br><span class="line">+    <span class="attribute">left</span>: <span class="number">50%</span></span><br><span class="line">+    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>)</span><br></pre></td></tr></table></figure><h3 id="菜单栏的选项">菜单栏的选项</h3><p>  这一部分在主题的配置文件 <code>_config.butterfly.yml</code>中修改即可。通过查看源码发现，butterfly仅支持最多二级菜单，并没有嵌套多层菜单功能。目前自己用到的只有主页、学习资料以及常用网站。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">学习资料:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-book</span></span><br><span class="line">  <span class="string">常用网站:</span> <span class="string">/link</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-globe</span></span><br><span class="line">  <span class="comment"># 其他||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br></pre></td></tr></table></figure><h3 id="细节优化">细节优化</h3><p>  对于本地搜索，我发现每次点开搜索弹出搜索框的时候，背景图片都会有些许的缩放。经过分析后发现，为了达到更好的体验效果，在弹出搜索框的时候，butterfly会使主页的 <code>body: overflow</code> 的属性变为<code>hidden</code>，这样主页面就不会有滚动效果了，达到了模态对话框的效果。但滚动条消失了，<code>body</code>元素的宽度就会变大，可能会导致原先的页面布局发生一定的改变。而 butterfly考虑到了这一点，因此在 <code>source/js/utils.js</code>中创建了如下的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">overflowPaddingR</span>: &#123;</span><br><span class="line"><span class="attr">add</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> paddingRight = <span class="variable language_">window</span>.<span class="property">innerWidth</span> - <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paddingRight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">`<span class="subst">$&#123;paddingRight&#125;</span>px`</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;hidden&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> menuElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#page-header.nav-fixed #menus&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (menuElement) &#123;</span><br><span class="line">        menuElement.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">`<span class="subst">$&#123;paddingRight&#125;</span>px`</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">remove</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> menuElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#page-header.nav-fixed #menus&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (menuElement) &#123;</span><br><span class="line">    menuElement.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>  原理就是给 <code>body</code> 添加一个内边距即<code>paddingRight</code> 抵消变化。但是这个函数只是考虑了例如<code>card_widget</code> 这些，我发现它们确实在滚动条消失后是不会有<code>x</code> 方向平移变化的。但背景图就不是这样的。找到主题下的<code>source/css/_global/index.styl</code> 文件，找到<code>#web_bg</code>即背景图片的样式，做如下修改，原理即将背景图片的大小从 <code>100%</code>改为 <code>100vw</code>，因为背景图片的父元素即 <code>body</code>是不包含滚动条的。而改为 <code>100vw</code>则是整个视口的大小，会包含滚动条的大小。这样，即使滚动条消失了，图片的大小依旧是原来的数值，不会发生变化。</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;background&#x27;</span>)</span><br><span class="line"><span class="selector-id">#web_bg</span></span><br><span class="line">    <span class="attribute">position</span>: fixed</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">999</span></span><br><span class="line"></span><br><span class="line">-    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">-    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">+    <span class="attribute">width</span>: <span class="number">100vw</span></span><br><span class="line">+    <span class="attribute">height</span>: <span class="number">100vh</span></span><br><span class="line">    <span class="attribute">background-attachment</span>: local</span><br><span class="line">    <span class="attribute">background-position</span>: center</span><br><span class="line">    <span class="attribute">background-size</span>: cover</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat</span><br></pre></td></tr></table></figure><h2 id="音乐播放器引入">音乐播放器引入</h2><p>  butterfly 有自己的音乐播放插件<code>Aplayer</code>，但我不是特别喜欢，而且也用不太懂，因此干脆自己写一个吧，又不是没有那个石粒！</p><h3 id="html-.pug-部分">html (.pug) 部分</h3><p>  首先是 html 元素引入，在 <code>layout/includes/nav.pug</code> 中<code>#blog-info</code> 后，<code>#menus</code> 前插入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">    span#blog-info</span><br><span class="line">        a.nav-site-title(href=url_for(&#x27;/&#x27;))</span><br><span class="line">        if theme.nav.logo</span><br><span class="line">            img.site-icon(src=url_for(theme.nav.logo) alt=&#x27;Logo&#x27;)</span><br><span class="line">        if theme.nav.display_title</span><br><span class="line">            span.site-name=config.title</span><br><span class="line">        if is_post()</span><br><span class="line">        a.nav-page-title(href=url_for(&#x27;/&#x27;))</span><br><span class="line">            span.site-name=(page.title || config.title)</span><br><span class="line">    </span><br><span class="line">    //- 从这里开始添加</span><br><span class="line">    //- music</span><br><span class="line">    #music-bar</span><br><span class="line">        #music-cover-container</span><br><span class="line">        #music-cover</span><br><span class="line"></span><br><span class="line">        #music-button-container</span><br><span class="line">        #music-button-container-top</span><br><span class="line">            span#music-prev.music-icon.iconfont.icon-shangyishou</span><br><span class="line">            span#music-playOrPause.music-icon.iconfont.icon-bofang</span><br><span class="line">            span#music-next.music-icon.iconfont.icon-xiayishou</span><br><span class="line">            span#music-mode.music-icon.iconfont.icon-liebiaoxunhuan</span><br><span class="line"></span><br><span class="line">        #music-button-container-bottom</span><br><span class="line">            div#music-progressBar</span><br><span class="line">            span#music-currentProgress</span><br><span class="line">            span#music-dot</span><br><span class="line">            span#music-progressText= &quot;00:00 / 00:00&quot;</span><br><span class="line"></span><br><span class="line">        #music-name-container</span><br><span class="line">        span#music-name</span><br><span class="line"></span><br><span class="line">        #music-lyric-container</span><br><span class="line">        span#music-lyric</span><br><span class="line">        </span><br><span class="line">    #menus</span><br><span class="line">        #toggle-menu</span><br><span class="line">        span.site-page</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><h3 id="css-.styl-部分">css (.styl) 部分</h3><p>  这一部分就比较长了，也是花费时间最长的部分之一，主要对 CSS不常用忘记了好多。找到<code>css/_layout/head.styl</code>，在最后添加如下代码（复制粘贴使用时注意缩进！！）：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// music bar</span></span><br><span class="line"><span class="selector-id">#music-bar</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>)</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span></span><br><span class="line">  </span><br><span class="line">  +<span class="built_in">maxWidth1024</span>()</span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-cover-container</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">52px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">display</span>: inline-flex</span><br><span class="line">    <span class="attribute">vertical-align</span>: top</span><br><span class="line">    <span class="attribute">align-items</span>: center</span><br><span class="line">    </span><br><span class="line">    <span class="selector-id">#music-cover</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">44px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">44px</span></span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">0</span> <span class="number">4px</span></span><br><span class="line">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;/img/云烟成雨-cover.webp&quot;</span>)</span><br><span class="line">      <span class="attribute">background-size</span>: contain</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">8px</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-button-container</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="attribute">vertical-align</span>: top</span><br><span class="line">    <span class="comment">// background-color: rgb(3, 84, 3)</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-button-container-top</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">26px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">      <span class="comment">// background-color: rgb(114, 6, 107)</span></span><br><span class="line">      <span class="attribute">display</span>: flex</span><br><span class="line">      <span class="attribute">align-content</span>: center</span><br><span class="line">      <span class="attribute">justify-content</span>: center</span><br><span class="line">      <span class="selector-class">.music-icon</span></span><br><span class="line">        <span class="comment">// background-color: rgb(174, 167, 167)</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">margin</span>: auto <span class="number">2px</span></span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">          <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">31</span>, <span class="number">179</span>, <span class="number">161</span>, <span class="number">1</span>)</span><br><span class="line">          <span class="attribute">cursor</span>: pointer</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-button-container-bottom</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">22px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">      <span class="comment">// background-color: rgb(82, 76, 2)</span></span><br><span class="line">      <span class="attribute">position</span>: relative</span><br><span class="line"></span><br><span class="line">      <span class="selector-id">#music-progressBar</span></span><br><span class="line">        <span class="attribute">position</span>: absolute</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">3px</span></span><br><span class="line">        <span class="attribute">left</span>: <span class="number">50%</span></span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>)</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">4px</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">110px</span></span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">0.8</span>)</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">2.5px</span></span><br><span class="line">        <span class="comment">// overflow: hidden</span></span><br><span class="line"></span><br><span class="line">        <span class="selector-id">#music-currentProgress</span></span><br><span class="line">          <span class="attribute">display</span>: block</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">          <span class="comment">// background-color: rgb(255, 0, 0)</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">2px</span></span><br><span class="line">          <span class="attribute">transition</span>: <span class="number">0.3s</span> ease</span><br><span class="line"></span><br><span class="line">        <span class="selector-id">#music-dot</span></span><br><span class="line">          <span class="attribute">display</span>: block</span><br><span class="line">          <span class="attribute">position</span>: absolute</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">6px</span></span><br><span class="line">          <span class="attribute">height</span>: <span class="number">6px</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">3px</span></span><br><span class="line">          <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">234</span>, <span class="number">151</span>, <span class="number">8</span>)</span><br><span class="line">          <span class="attribute">bottom</span>: -<span class="number">1px</span></span><br><span class="line">          <span class="attribute">left</span>: -<span class="number">3px</span></span><br><span class="line">          <span class="attribute">z-index</span>: <span class="number">999</span></span><br><span class="line">          <span class="attribute">transition</span>: <span class="number">0.3s</span> ease</span><br><span class="line"></span><br><span class="line">        <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">          <span class="attribute">cursor</span>: pointer</span><br><span class="line">          <span class="selector-id">#music-dot</span></span><br><span class="line">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">23</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">0.5</span>); <span class="comment">/* 添加阴影 */</span></span><br><span class="line"></span><br><span class="line">      <span class="selector-id">#music-progressText</span></span><br><span class="line">        <span class="attribute">position</span>: absolute</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">1px</span></span><br><span class="line">        <span class="attribute">right</span>: <span class="number">4px</span></span><br><span class="line">        <span class="attribute">display</span>: block</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">80px</span></span><br><span class="line">        <span class="attribute">height</span>: <span class="number">16px</span></span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">16px</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="attribute">text-align</span>: right</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-name-container</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="comment">// background-color: rgb(127, 0, 0)</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap</span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">70%</span></span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-name</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-lyric-container</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="comment">// background-color: rgb(153, 210, 168)</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap</span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">70%</span></span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-lyric</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br></pre></td></tr></table></figure><h3 id="js-部分">js 部分</h3><p>  最后就到了 <code>js</code>代码部分了，这一部分没有原先的文件可供使用，因此自己可以在 hexo主目录下的 <code>source</code> 中创建一个目录<code>js</code>，在其中创建一个文件 <code>music.js</code>以及用于歌词分割的文件<code>lyricParse.js</code>，由于是单独的文件，此处就不再粘贴出代码了。</p><h3 id="资源文件部分">资源文件部分</h3><ul><li>音乐封面，路径为 <code>/img/</code></li><li>音乐资源，路径为 <code>/music/</code></li><li>音乐歌词，路径为 <code>/lyrics/</code></li></ul><p>例如 <code>music.js</code> 中 <code>MusicPlayer</code>的这三个属性定义为下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">musicList</span> = [<span class="string">&quot;/music/云烟成雨 - 房东的猫.mp3&quot;</span>, <span class="string">&quot;/music/使一颗心免于哀伤 - HOYO-MiX,Chevy,知更鸟.mp3&quot;</span>, <span class="string">&quot;/music/单向箭头 - 双笙 (陈元汐).mp3&quot;</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">coverList</span> = [<span class="string">&quot;/img/云烟成雨-cover.webp&quot;</span>, <span class="string">&quot;/img/使一颗心免于哀伤-cover.jpg&quot;</span>, <span class="string">&quot;/img/单向箭头-cover.webp&quot;</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">lyricList</span> = [<span class="string">&quot;/lyrics/云烟成雨.lrc&quot;</span>, <span class="string">&quot;/lyrics/使一颗心免于哀伤.lrc&quot;</span>, <span class="string">&quot;/lyrics/单向箭头.lrc&quot;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录2——鼠标部分</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%952%E2%80%94%E2%80%94%E9%BC%A0%E6%A0%87%E9%83%A8%E5%88%86/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%952%E2%80%94%E2%80%94%E9%BC%A0%E6%A0%87%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="鼠标样式修改">鼠标样式修改</h2><p>可以在 <code>source/css/</code> 下新建 <code>cursor.css</code>文件来修改鼠标的展示样式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录1——背景飘落特效</title>
      <link href="/2024/11/13/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%951%E2%80%94%E2%80%94%E8%83%8C%E6%99%AF%E9%A3%98%E8%90%BD%E7%89%B9%E6%95%88/"/>
      <url>/2024/11/13/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%951%E2%80%94%E2%80%94%E8%83%8C%E6%99%AF%E9%A3%98%E8%90%BD%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h2 id="樱花雪花飘落特效">樱花/雪花飘落特效</h2><p>  在 <code>sakuraPlus.js</code>中实现。这是很久之前不知道从哪里得到的一份代码，目前网上也十分容易找到，并且用的人也挺多的。将这份代码放置在<code>source/js</code> 文件夹中，可以修改其中的 <code>img.src</code>图片原路径换不同的图片资源，甚至也可以修改 <code>fnx</code>等这些飘落计算公式适配不同的物体飘落逻辑。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/cursor.css&quot;&gt;</span></span><br><span class="line"><span class="attr">bottom:</span></span><br><span class="line"><span class="string">+</span>    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=/js/sakuraPlus.js&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 的使用</title>
      <link href="/2024/11/12/CMake-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/12/CMake-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令">常用命令</h2><ol type="1"><li><p>指定 cmake 的最低版本</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>指定项目名称</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure></p></li><li><p><code>set</code> 命令的使用，例如指定 C++的标准、指定文件输出路径等</p><ul><li><p>指定 C++11 的标准</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>指定制作的库的输出路径，一般放置在项目根目录的 <code>lib</code>文件夹中</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure></p></li><li><p>指定可执行程序的输出路径，一般我们都放置在项目根目录的<code>bin</code> 文件夹中</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure></p></li></ul></li><li><p>搜索文件</p><ul><li><p>方法 1: <code>file</code> 命令</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br></pre></td></tr></table></figure></p><ul><li>参数 1: <code>GLOB</code> 是 <code>file</code>命令的一个参数，表示“全局匹配”，用于根据指定的模式查找文件。</li><li>参数 2: 将查找到的文件保存在该变量中。</li><li>参数 3: 匹配模式，示例中为匹配 <code>CMAKE_CURRENT_SOURCE_DIR</code>宏指定的目录下的所有以 <code>.cpp</code> 结尾的文件。</li></ul></li><li><p>方法 2: 待补充，方法 1 就挺好用</p></li></ul></li><li><p>制作一个库文件</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(calculate STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></p><ul><li>参数 1: 表示生成库的名字，注意这只是省略的写法，真正的库名为<code>libcalculate.lib</code> 这种。</li><li>参数 2: 表示生成库的类型, <code>STATIC</code>表示生成静态库，<code>SHARED</code> 表示生成动态库（共享库）。</li><li>参数 3: 表示用于生成库所需要的源文件。</li></ul></li><li><p>打印信息</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>引用一个库文件：</p><ul><li>首先要包含头文件。因为头文件中有如何使用库文件中的接口，有了头文件才能指导我们里面有什么函数可以使用。</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;../include&quot;</span>)</span><br></pre></td></tr></table></figure></p><ul><li>然后应该告知要去哪里搜索我们的库文件，我们要指定一个具体的搜索目录。</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include library</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure></p><ul><li>最后，我们便可以链接这个目录中的某个具体库使用了～</li></ul><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(calculate)</span><br></pre></td></tr></table></figure></p></li><li><p>生成可执行文件</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(test1 <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>参数 1: 生成可执行文件的名称。 参数 2: 所需要用到的源文件。</p></li></ol><h2 id="常用的宏">常用的宏</h2><table><colgroup><col style="width: 55%" /><col style="width: 44%" /></colgroup><thead><tr><th>宏名称</th><th>解释</th></tr></thead><tbody><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td><strong>当前</strong> <code>CMakeLists.txt</code> 所在的目录</td></tr><tr><td><code>PROJECT_SOURCE_DIR</code></td><td>项目的根目录，注意在多 CMake 嵌套的工程中与<code>CMAKE_CURRENT_SOURCE_DIR</code> 不一定等价</td></tr><tr><td><code>CMAKE_CXX_STANDARD</code></td><td>CMake 要求的 C++ 最低版本</td></tr><tr><td><code>LIBRARY_OUTPUT_PATH</code></td><td>制作的库的输出（保存）路径</td></tr><tr><td><code>EXECUTABLE_OUTPUT_PATH</code></td><td>生成的二进制可执行程序的输出路径</td></tr></tbody></table><h2 id="完整代码">完整代码</h2><h3 id="制作库的参考模板">制作库的参考模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(apue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output path</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># source file to make a library</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;../include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(apue STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="生成可执行程序的参考模板">生成可执行程序的参考模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_NAME main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output path</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># make dynamic library file</span></span><br><span class="line"><span class="comment"># source file to make a library</span></span><br><span class="line"><span class="comment"># file(GLOB LIB_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/hook.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="comment"># include_directories(&quot;./&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add_library(hook SHARED $&#123;LIB_SRC&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include library</span></span><br><span class="line"><span class="comment"># link_directories(&quot;../lib&quot;)</span></span><br><span class="line"><span class="comment"># link_libraries(apue)</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/12/hello-world/"/>
      <url>/2024/11/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
