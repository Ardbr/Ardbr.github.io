<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 学习——关键字</title>
      <link href="/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/11/28/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a><code>auto</code></h2><p>&emsp;&emsp;<code>auto</code> 可以帮助我们自动填补该变量的类型，而不需要我们手动指定，我们只需要在变量前面使用 <code>auto</code> 即可，例如 <code>auto a = 5</code>。对于迭代器或 <code>&lt;chrono&gt;</code> 时间库等一些类型名十分冗长的数据类型来说，<code>auto</code> 十分好用，可以直接为我们指定出应有的类型。<br>&emsp;&emsp;当然，它是一把双刃剑，也会有不好的一面。考虑如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,  world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = <span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = name.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码可以正常运行并输出，<code>name</code> 的类型是 <code>std::string</code>。但是考虑如果我们把 <code>getName()</code> 的返回类型改为 <code>char *</code>，这个时候事情就不一样了。<code>name</code> 的类型被改为了 <code>char *</code>，而后面的 <code>name.size()</code> 是 <code>std::string</code> 才有的成员函数，因此就会报错！<br>&emsp;&emsp;而若我们使用的是 <code>std::string name = getName()</code>，这里就没问题了。因为最坏的情况下你修改了函数的返回值，类型不兼容会报错，我们修改成对应的类型即可。但好的情况编译器会为我们做隐式类型转换，将 <code>char *</code> 转为 <code>std::string</code>，程序依旧能正常运行。<br>&emsp;&emsp;并且 <code>auto</code> 使用过多后我们不方便知道一个变量到底是什么类型，例如上方，我们可能要去查看 <code>getName()</code> 的返回类型，之后才能确定 <code>name</code> 的类型，当然现在大多数的代码编辑器支持鼠标悬停查看类型。但始终也不如直接显性规定变量类型，一眼看上去就知道要来的快。<br>&emsp;&emsp;下面再举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeviceManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;<span class="built_in">getDeivce</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> dm;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; dm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DeviceManager *dm = <span class="keyword">new</span> DeviceManager;</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; &amp;d = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> d2 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;d3 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> deviceType = std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;;</span><br><span class="line">    <span class="type">const</span> deviceType &amp;d4 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; deviceType2;</span><br><span class="line">    <span class="type">const</span> deviceType2 &amp;d5 = dm-&gt;<span class="built_in">getDeivce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，这个 <code>dm</code> 的类型是一个很长很长的类型，我们有以上的几种方法可以来实现对类型的声明。第一种就是正常的写法，全部写出来。第二种和第三种使用 <code>auto</code> 关键字自己确定。第四种使用 <code>using</code> 起类型别名。而第五种则是用 <code>typedef</code> 起类型别名。</p><div class="note danger flat"><p><strong>注意，使用 <code>auto</code> 关键字内部并不会给你自动指定 <code>const</code> 和引用 <code>&amp;</code>，尽管你函数的返回值表明了常量引用。因此上述第二种仅仅只是声明了这个类型，并没有加 <code>const &amp;</code>，第三种才是 <code>auto</code> 的正确写法！</strong></p></div><h2 id="宏-macros"><a href="#宏-macros" class="headerlink" title="宏 macros"></a>宏 <code>macros</code></h2><p>&emsp;&emsp;宏的本质就是替换，在正式执行编译之前，编译器会进行预处理操作，把所有的宏替换成你所在后面定义的语句。这个过程就是纯文本的查找与替换。例如如下例子就能很好的说明这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_CURLY &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> OPEN_CURLY</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码依旧能够正常编译运行。在这段代码中，我们做了一个很疯狂的操作，我们用宏 <code>OPEN_CURLY</code> 来代替左花括号 <code>&#123;</code>，因此，之后在任何能够使用到 <code>&#123;</code> 的地方，我们都可以把它替换成 <code>OPEN_CURLY</code>。</p><p>&emsp;&emsp;当然，这不是宏的正确打开方式！宏至少有以下的几种用法：</p><ul><li>将常用的函数用宏来代替，减少了代码量。注意最好是一些可读性较强的代码，替换成宏之后意义依旧十分明确，否则还要去跟踪宏的定义看看到底实现的是什么功能。因此这一用法尽量少用！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p><strong>一般来说，定义的宏值后面的代码语句不要添加 <code>;</code>，而是在实际使用时在宏的后面添加。</strong>例如 <code>LOG(&quot;&quot;);</code>。因为如果在定义宏的时候添加了 <code>;</code>，那么后续使用的时候如果不加，是正确的做法，但是对于 <code>C++</code> 来说，一般所有的代码语句都要以 <code>;</code> 结尾。因此一个宏后面没有 <code>;</code>，就会显得很突兀。而如果加了的话，就相当于一个语句后面有 2 个 <code>;</code>，造成了一个空语句。</p></div><ul><li>与 <code>#if</code> 配合食用用于快速注释多行代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;HASDF&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的话，<code>#if 0</code> 和 <code>#endif</code> 之间的所有代码都不会被执行。</p><ul><li>切换程序的运行版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PRO_DEBUG == 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(PRO_RELEASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们希望在程序的调试阶段，打印一些运行信息来观察程序执行是否有误。而在发行版本中，就不要打印任何信息。我们可以利用宏来快速完成这一点。也就是说在 <code>DEBUG</code> 阶段，<code>LOG()</code>  函数被定义成一个 <code>std::cout</code> 的实现，而在 <code>RELEASE</code> 下，我们让 <code>LOG()</code> 为空，不要执行任何功能即可。</p><p>&emsp;&emsp;使用 <code>g++ -std=c++17 -DPRO_DEBUG=1 main.cpp -o main &amp;&amp; ./main</code> 来运行上述代码，可以观察到打印出了信息。而当我们使用 <code>g++ -std=c++17 -DPRO_RELEASE main.cpp -o main &amp;&amp; ./main</code>，程序就不会有任何输出。而如果我们不定义这两者之一，程序就会报错，因为找不到 <code>LOG</code> 宏定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main &amp;&amp; ./main              </span><br><span class="line">main.cpp:14:5: error: use of undeclared identifier &#x27;LOG&#x27;</span><br><span class="line">    LOG(&quot;Hello, world&quot;);</span><br><span class="line">    ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><div class="note info flat"><p>使用 <code>g++</code> 时，通过 <code>-D&lt;MACROS&gt;=&lt;VALUE&gt;</code> 的参数可以为我们在编译执行代码的时候往程序里添加一个或多个宏定义。其中 <code>=&lt;VALUE&gt;</code> 部分可选，即我们可以只定义该宏，而不指定其为任何值。</p></div><h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板 template"></a>模板 <code>template</code></h2><h3 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h3><p>&emsp;&emsp;模板 <code>template</code> 指 <code>C++</code> 程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计。<code>C++</code> 的标准库提供许多有用的函数大多结合了模板的观念，如 <code>STL</code> 以及 <code>IO Stream</code>。<br>&emsp;&emsp;例如对于如下的代码，如果我们不使用模板，而我们想对不同的类型，例如 <code>int</code>、<code>std::string</code> 以及 <code>double</code> 写一个函数进行打印，那么就得写多个 <code>Print</code> 函数，其接收的参数不同，因此可以对其进行重载。<br>&emsp;&emsp;可以看到，这种方式要多写很多的代码，明明每个函数内部的代码都是相同的，仅仅是接收的参数类型不同而已。我们能不能将参数的数据类型也指定成为一个参数 <code>T</code>，然后编译的时候由 <code>Print()</code> 函数接收的参数的数据类型对这个参数 <code>T</code> 进行填值，生成对应的 <code>Print</code> 函数呢？答案是可以的，模板就是来干这个的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(std::string value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">double</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>&emsp;&emsp;我们首先需要在要定义的函数前面声明这是一个模板函数，通过 <code>template &lt;typename T&gt;</code> 可以做到这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">Print</span>(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用模板要注意的地方"><a href="#使用模板要注意的地方" class="headerlink" title="使用模板要注意的地方"></a>使用模板要注意的地方</h3><p>&emsp;&emsp;<font color="darkred"><strong>注意，如果并没有调用 <code>Print()</code> 函数，那么 <code>Print()</code> 函数并不会被创建出来。只有调用的时候，编译器才会将对应参数类型的 <code>Print</code> 函数创建出来。例如我们调用了 <code>Print(5)</code>，那么 <code>void Print(int value) &#123;&#125;</code> 这个函数就会被创建出来。而不调用 <code>Print(&quot;hello&quot;)</code> 之前，<code>void Print(const char *value) &#123;&#125;</code> 是不存在的！</strong></font></p><p>&emsp;&emsp;要证明这一点，我们可以通过如下的代码验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很明显 <code>void Print(T value)</code> 函数内部有错误，我们把 <code>value</code> 故意改成了 <code>val</code>，如果这个函数在编译阶段被创建出来了的话，那么编译器会因为找不到 <code>val</code> 变量而报错的。但是我们编译执行，发现并没有错误！因为我们没有任何调用 <code>Print</code> 的地方，因此这个函数并不会被创建出来。</p><div class="note warning flat"><p><strong>注意，普通函数即使不被调用，如果函数内部实现有错误，编译器仍然会报错，因为普通函数即使没有被调用，但也是会被创建出来的。</strong></p></div><p>&emsp;&emsp;因此，模板的实现原理就是：我们有了一个被标记为模板函数的函数，编译器执行到这里的时候并不会将其进行创建，因为编译器也不知道要创建接收什么数据类型的函数。直到我们后续的函数中有了一个使用这个模板函数的地方，编译器便会对传入的参数进行类型推断，比如推断出 <code>5</code> 是一个 <code>int</code>，因此，它会回去<strong>由模板函数创建出一个接收参数为 <code>int</code> 类型的普通函数</strong>。之后又遇见了接收 <code>&quot;hello&quot;</code> 的模板函数，它推断 <code>&quot;hello&quot;</code> 是一个 <code>const char *</code>，因此就会创建一个 <code>void Print(const char *)</code> 的普通函数。</p><p>&emsp;&emsp;由上述我们可以发现，我们传入的参数都是由编译器自己进行推断的。这在大多数情况下都很方便，但有些时候可能与我们所设想的不同。例如，之前我们所传入的 <code>&quot;hello&quot;</code> 我们可能希望它是一个 <code>std::string</code> 而不是 <code>const char *</code>，因为我们可能想在函数内部调一些例如 <code>.size()</code> 等只有 <code>std::string</code> 这些类才有的成员函数。因此，我们可以显性指定要用什么类型的模板函数，只要像 <code>Print&lt;int&gt;(5)</code>、<code>Print&lt;std::string&gt;(&quot;hello&quot;)</code> 这样写即可。</p><h3 id="在类中使用模板"><a href="#在类中使用模板" class="headerlink" title="在类中使用模板"></a>在类中使用模板</h3><p>&emsp;&emsp;在 <code>C++</code> 中，以下的代码是不被允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>因为在普通函数中定义数组时，<code>size</code> 可以是编译时常量或允许的动态大小，视编译器和语言标准而定。而在类中，数组的大小必须<font color="red">在编译时已知</font>，不能使用非静态成员变量来定义，因此需要采用其他方法来管理动态大小数组。</strong></p><p>&emsp;&emsp;例如，以下是几种解决方法：</p><ul><li>动态分配内存：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> s) : <span class="built_in">size</span>(s) &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] array; <span class="comment">// 释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>std::vector</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; array; <span class="comment">// 使用 std::vector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">array</span>(size) &#123;&#125; <span class="comment">// 初始化 vector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在这一节，我们要提出第三种方法，那就是使用模板。因为前面说了，在类中定义数组的时候，其大小必须是编译时可以确定大小的数据。而前前面我们又说了，模板就是在编译期间确定其具体的数据类型。<strong>因此两者完美契合！！！</strong>这里我们可以引申一下，因为模板不仅可以通过 <code>&lt;typename T&gt;</code> 来将数据类型作为参数在编译期间确定，也可以将一些常用类型的变量具体值作为参数。例如 <code>template &lt;int N&gt;</code>，我们就指定了一个 <code>int</code> 类型的变量 <code>N</code>，其大小会编译期间确定下来。所以，我们的 <code>Array</code> 可以像如下代码这样定义和使用（我们同时将 <code>array</code> 的数据类型也从 <code>int</code> 变为模板 <code>T</code>，因此可以接收 <code>std::string</code> 等的类型！此外还实现了一些小功能，例如支持下标索引，打印数组元素等）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[] (<span class="type">int</span> index) &#123; <span class="keyword">return</span> array[index]; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T array[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Array&lt;std::string, <span class="number">5</span>&gt; arr1;</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    arr1[<span class="number">1</span>] = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    arr1[<span class="number">3</span>] = <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    arr1[<span class="number">4</span>] = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; arr<span class="number">1.</span><span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 main.cpp -o main -Wall &amp;&amp; ./main</span><br><span class="line">hello , world ! ? </span><br><span class="line">5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix-1-shell</title>
      <link href="/2024/11/27/Unix-1-shell/"/>
      <url>/2024/11/27/Unix-1-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="查看当前系统下的-shell"><a href="#查看当前系统下的-shell" class="headerlink" title="查看当前系统下的 shell"></a>查看当前系统下的 <code>shell</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat etc/shells</span><br></pre></td></tr></table></figure><h3 id="查看当前使用的-shell"><a href="#查看当前使用的-shell" class="headerlink" title="查看当前使用的 shell"></a>查看当前使用的 <code>shell</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><h3 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h3><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>Ctrl + p</code></td><td>显示上一条命令，同方向键上</td></tr><tr><td><code>Ctrl + n</code></td><td>显示下一条命令，同方向键下</td></tr><tr><td><code>Ctrl + b</code></td><td>光标向后移动一格，同方向键左</td></tr><tr><td><code>Ctrl + f</code></td><td>光标向前移动一格，同方向键右</td></tr><tr><td><code>Ctrl + a</code></td><td>将光标置于最开始的位置</td></tr><tr><td><code>Ctrl + e</code></td><td>将光标置于末尾的位置</td></tr><tr><td><code>Ctrl + u</code></td><td>清空当前写下的命令</td></tr><tr><td><code>Ctrl + d</code></td><td>删除后面的一个字符，同 <code>delete</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——算法</title>
      <link href="/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/26/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>&emsp;&emsp;<code>C++</code> 内部集成了排序算法，即 <code>std::sort()</code>，时间复杂度为 $O(NlogN)$。具体的使用见下面的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());      <span class="comment">// output: 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());     <span class="comment">// outpupt: 6, 5, 4, 3, 2, 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;); <span class="comment">// output: 1, 2, 3, 4, 5, 6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 4</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;        <span class="comment">// output: 2, 3, 4, 5, 6, 1</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> v : vec)</span><br><span class="line">        std::cout &lt;&lt; v;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 对于类似 <code>case 3</code> 中的 <code>lambda</code> 表达式，如果返回值为 <code>true</code>，表示 <code>a</code> 和 <code>b</code> 不交换位置，否则交换位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习——杂项</title>
      <link href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="C-的参数计算顺序"><a href="#C-的参数计算顺序" class="headerlink" title="C++ 的参数计算顺序"></a><code>C++</code> 的参数计算顺序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; (a + b) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sum</span>(value++, value++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">main.cpp:5:1: warning: non-void function does not return a value [-Wreturn-type]</span><br><span class="line">&#125;</span><br><span class="line">^</span><br><span class="line">main.cpp:9:14: warning: multiple unsequenced modifications to &#x27;value&#x27; [-Wunsequenced]</span><br><span class="line">    sum(value++, value++);</span><br><span class="line">             ^        ~~</span><br><span class="line">2 warnings generated.</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">0 + 1 = 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，程序在编译的时候就会报出警告，说对 <code>value</code> 存在多个无序的修改。也就是说这种行为是未定义的 (undefined)，取决于运行的平台以及编译器优化等等。因此并不能给出具体的计算顺序以及结果。</p><div class="note info flat"><p>但是从 <code>C++17</code> 起，规定了后缀表达式必须按顺序进行计算。因为对于上述的两个 <code>value++</code>，如果编译器存在优化，这两个参数很有可能是会并行计算的，也就是两者互不干扰，可能会出现 <code>0 + 0 = 0</code> 的情况。<strong>但 <code>C++17</code> 中明确表示两个后缀表达式必须按顺序进行计算。但是具体是按什么顺序并没有明说，也就是这种行为实际上还是未定义的。</strong></p></div><h2 id="C-中的空指针"><a href="#C-中的空指针" class="headerlink" title="C++ 中的空指针"></a><code>C++</code> 中的空指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity *parent, std::string name) : <span class="built_in">parent</span>(parent), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity *entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="literal">nullptr</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// part 1</span></span><br><span class="line">    std::cout &lt;&lt; entity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">uint64_t</span>)entity &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; ((Entity *)((<span class="type">uint64_t</span>)entity))-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(entity) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// part 2</span></span><br><span class="line">    Entity *e = <span class="literal">nullptr</span>;</span><br><span class="line">    std::cout &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    e-&gt;<span class="built_in">printType</span>();     <span class="comment">// equal to: (*e).printType();</span></span><br><span class="line">    e-&gt;<span class="built_in">printName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的代码中，<code>part 1</code> 是我用来验证自己平台的指针都是 64 位的。<code>part 2</code> 就比较有意思了，如果我们设置 <code>e</code> 为空指针 <code>nullptr</code>，然后调用它的两个成员函数，神奇的是，<code>e-&gt;printType()</code> 能够正常输出 <code>&quot;Entity&quot;</code> 字符串，而 <code>e-&gt;printName()</code> 就会报段错误 <code>Segmentation Fault</code>。为什么会这样呢？两者不都是它的成员函数吗？<br>&emsp;&emsp;首先，一般对于编程语言来说，定义了一个类的实例 <code>e</code>，然后编写它的成员函数 <code>member_fn(arg1, arg2)</code>，自己调用的时候是 <code>e.member_fn(arg1, arg2)</code>，实际上底层处理的时候是这样的——<code>member_fn(e, arg1, arg2)</code>，即并没有谁调用这一说，都是把调用者作为第一个参数传了进去。上述的代码等价于 <code>C</code> 语言时期的下面代码（仅演示在 <code>C</code> 中结构体内部不可声明函数类型的特性）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(Entity *e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">(Entity *e)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; e-&gt;name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这也是 <code>C++</code> 处理后可以得到的代码。因此，对于 <code>printType()</code> 来说，尽管你传入进来了 <code>nullptr</code>，但在内部并没有实际解引用它的值，因此不会引起段错误。而在 <code>printName()</code> 中，你试图对 <code>nullptr</code> 指向的再进行偏移后 <code>name</code> 所在的地址进行解引用，这显然就会引起段错误了。<strong>因此，本质上在于我们对一个非法内存解引用获取成员变量。</strong></p><p>&emsp;&emsp;接下来不妨再来说说 <code>e-&gt;name</code> 这类获取成员变量实现的原理。<br>&emsp;&emsp;<code>e-&gt;name</code> 这类获取成员变量，实际上就是取了一个偏移量。例如，对于下述的代码如果一个 <code>Entity *</code> 指针的指向地址为 <code>0xf0e1b0</code>，那么 <code>parent</code> 变量的地址就是 <code>0xf0e1b0</code>，而 <code>name</code> 的地址就是 <code>0xf0e1b0 + 0x8 = 0xf0e1b8</code>，因为 <code>parent</code> 的大小为 8 字节，我们跳过它就可以了。可以看到，我们此处获取的是绝对地址，那如果我们想获取相对地址，也就是偏移量呢？一种方法是我们减去基地址，例如获取 <code>name</code> 的偏移量，就是它的地址 <code>0xf0e1b8</code> 减去基地址 <code>0xf0e1b0</code> 得到 8 字节，但这种方法还是会涉及减法运算操作，不够高效。</p><p>&emsp;&emsp;其实 <code>C++</code> 内部有 <code>offsetof</code> 函数，它接收两个参数，第一个是类的类型，第二个是类中的成员变量，返回值就是这个成员变量在这个类中的偏移量。它的实现就十分的巧妙了。思想是：<font color="darkred"> <strong>我们仍然用绝对地址，但是我们怎么能够让绝对地址表示的相当于是相对地址呢？没错，我们让它的基地址是 0 就可以了！！</strong> </font> 我们将基地址 <code>0x0</code> 强制转为 <code>Entity *</code> 指针类型，然后取它相应的成员变量，注意一定要取地址，不可解引用！！否则会造成段错误！！这就是这个成员变量的绝对地址，又因为它的基地址是 <code>0x0</code>，因此偏移量就是绝对地址本身啦。两种方法的代码示例见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="built_in">Entity</span>(Entity *parent, std::string name) : <span class="built_in">parent</span>(parent), <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entity *parent;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity *entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(<span class="literal">nullptr</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;parent offset: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Entity, parent) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name offset: &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Entity, name) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 1</span></span><br><span class="line">    std::cout &lt;&lt; ((<span class="type">u_int64_t</span>)&amp;(entity-&gt;name) - (<span class="type">uint64_t</span>)entity) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// solution 2</span></span><br><span class="line">    std::cout &lt;&lt; &amp;(((Entity *)<span class="number">0</span>)-&gt;name) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">u_int64_t</span>)&amp;(((Entity *)<span class="number">0</span>)-&gt;name) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">allocating 32 bytes</span><br><span class="line">parent offset: 0</span><br><span class="line">name offset: 8</span><br><span class="line">8</span><br><span class="line">0x8</span><br><span class="line">8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习——设计模式</title>
      <link href="/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/11/23/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>&emsp;&emsp;单例模式就是在程序运行过程中这个类只能有一个实例，不允许存在多个该类的实例。例如一个随机数生成器，我们只希望在程序初始化的时候利用一个随机数种子初始化一个生成器，之后每次使用随机数只需对该生成器调用例如 <code>get()</code> 函数即可，我们不需要再次实例化一个生成器类。<br>&emsp;&emsp;以下是一个简单的单例模式的模板。可以看到，与普通的类对比，我们要做如下几点：</p><ol><li>我们需要在类中声明一个静态的该类的成员变量；</li><li>我们还需要将类的构造函数设置为 <code>private</code>，这将不允许我们调用构造函数实例化一个类；</li><li>还需要删除拷贝构造函数，否则我们可以使用 <code>Get()</code> 函数获取这个实例，之后利用 <code>Singleton s = Singleton::Get()</code> 来获取一份拷贝，这两份是独立的内存空间，因此我们便绕过构造函数创建了两个实例了；</li><li>我们还需要有要用到的成员变量及对应的访问接口函数；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::singleton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Singleton &amp;s = Singleton::<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; Singleton::<span class="built_in">Get</span>().<span class="built_in">Float</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但这样每次我们调用这个实例的相关结构的时候，总是要写 <code>Singleton::Get().Float()</code> 这么一大长串，十分不便，以下是解决措施：</p><ul><li>首先，我们可以把 <code>Singleton::Get()</code> 引用一下，之后每次在这个引用的变量上调用函数即可：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;s = Singleton::<span class="built_in">Get</span>();</span><br><span class="line">std::cout &lt;&lt; s.<span class="built_in">Float</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>另一种方法是修改类的成员函数，将 <code>Singleton::Get().Float()</code> 再次进行包装，如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;我们将原先的函数作为内部接口，添加前缀 <code>I</code>（仅个人喜好，可任意命名），作为私有成员函数，之后，我们对外开放的 <code>Float</code> 函数可以调用这个函数。</p><p>&emsp;再次改进，我们可以将 <code>static Singleton singleton</code> 移入到 <code>Get()</code> 里面，这样就不需要再在类的外面声明使用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton singleton;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Get</span>().<span class="built_in">IFloat</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">IFloat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> float_num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> float_num = <span class="number">0.5f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——一些新特性</title>
      <link href="/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/11/22/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><p>&emsp;&emsp;这是在 <code>C++17</code> 中新引入的特性，用于处理函数多返回值的问题。在旧版本的 <code>C++</code> 中，如果我们想要处理一个函数具有多返回值，而且返回值的类型可能不同时，我们可以通过结构体、<code>pair</code> 或者 <code>tuple</code> 的形式，但他们都十分地繁琐，不管是对于函数返回类型还是接收部分处理。以下是一个使用 <code>tuple</code> 的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::tuple&lt;std::string, <span class="type">int</span>&gt; person = <span class="built_in">createPerson</span>();</span><br><span class="line">    std::string name = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(person);</span><br><span class="line">    <span class="type">int</span> age = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(person);</span><br><span class="line"></span><br><span class="line">    std::string name2;</span><br><span class="line">    <span class="type">int</span> age2;</span><br><span class="line">    std::<span class="built_in">tie</span>(name2, age2) = <span class="built_in">createPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，如果使用 <code>std::tie</code>，会比使用 <code>std::get&lt;&gt;</code> 要方便许多，但仍然需要 3 行代码。而结构化绑定只需要一行代码！下面是使用结构化绑定修改的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">createPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Cherno&quot;</span>, <span class="number">24</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [name, age] = <span class="built_in">createPerson</span>();</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意这是 <code>C++17</code> 的新特性，确保你的编译器在 <code>C++17</code> 以上。如果使用 <code>g++</code>，可以使用命令 <code>-std=c++17</code> 来指定版本。</strong></p></div><h2 id="std-optional-可选数据"><a href="#std-optional-可选数据" class="headerlink" title="std::optional&lt;&gt; 可选数据"></a><code>std::optional&lt;&gt;</code> 可选数据</h2><p>&emsp;&emsp;在一些情况下，我们需要读取一个文件，但我们怎么知道文件是否存在以及是否被成功读取呢？一般来说，如果成功读取，我们可以返回文件的字符串表示，而失败时，由于返回类型必须一致，我们可以返回一个空字符串 <code>&quot;&quot;</code>。但是这样就有一个问题，如果我们成功读取到了文件内容，但文件中恰恰没有任何内容，也就是我们成功读取了，但返回的内容仍然是 <code>&quot;&quot;</code>。这样我们又该如何分辨到底有没有读取成功呢？<br>&emsp;&emsp;一种解决思路是再引入一个额外的布尔变量 <code>success_flag</code> 专门用于标明是否读取成功。但这样会有额外的开销。能否只用一个变量就能做到呢。这就是 <code>C++17</code> 引入的新特性可选 <code>std::optional&lt;&gt;</code> 可选数据类型。<br>&emsp;&emsp;我们只需要把返回值 <code>string</code> 设置为可选的，读取成功时给它赋值，而失败时留空，不做任何操作。那么我们就可以通过它里面是否有值来判断文件是否读取成功啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">readFileAsString</span><span class="params">(<span class="type">const</span> std::string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">stream</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (stream) &#123;</span><br><span class="line">        std::string result;</span><br><span class="line">        stream.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::optional&lt;std::string&gt; data = <span class="built_in">readFileAsString</span>(<span class="string">&quot;./data2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string str = data.<span class="built_in">value_or</span>(<span class="string">&quot;No present&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>std::optional&lt;&gt;</code> 有成员函数 <code>has_value()</code> 返回布尔值表示是否有值，但类本身也是有布尔运算符的，所以可以直接 <code>if (data)</code> 来进行判断。<br>&emsp;&emsp;<code>value_or()</code> 函数非常有用，作用如其函数名所述，如果本身有值，那么就用本身的值，否则，就用传入的参数作为值，起到了一种 “默认” 值的作用。</p><h2 id="std-variant-单变量存放多数据类型"><a href="#std-variant-单变量存放多数据类型" class="headerlink" title="std::variant 单变量存放多数据类型"></a><code>std::variant</code> 单变量存放多数据类型</h2><h3 id="std-variant-的用法"><a href="#std-variant-的用法" class="headerlink" title="std::variant 的用法"></a><code>std::variant</code> 的用法</h3><p>&emsp;&emsp;<code>std::variant</code> 也是 <code>C++17</code> 引入的新特性，允许我们在一个变量中存放多个类型的值，只需要我们将这些类型在声明变量的时候显性列举出来即可。以下是它的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    data = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(data) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; data.<span class="built_in">index</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access more safely</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> value = std::<span class="built_in">get_if</span>&lt;std::string&gt;(&amp;data)) &#123;</span><br><span class="line">        std::cout &lt;&lt; *value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取对应类型的值，我们可以通过 <code>std::get&lt;type&gt;</code> 来获取，但首先要确保这个变量目前存的值与该类型相匹配，否则会抛出异常！更安全的做法是使用 <code>std::get_if&lt;type&gt;(ptr)</code> 来获取，它接收的该变量的地址，如果类型匹配，返回指向该变量的指针，否则，返回空指针。</li><li><code>data.index()</code> 可以返回当前变量值对应的类型的索引。例如在上述代码中，如果 <code>data</code> 的类型是 <code>std::string</code>，那么会返回 <code>0</code>，如果是 <code>int</code>，会返回 <code>1</code>。</li></ul><h3 id="与-Union-比较"><a href="#与-Union-比较" class="headerlink" title="与 Union 比较"></a>与 <code>Union</code> 比较</h3><p>&emsp;&emsp;两者似乎都是在单一变量中能够存储多个值，但两者有很大的不同，例如在存储方式上。对于 <code>Union</code> 来说，不同的变量占据的是同一块内存，因此 <code>Union</code> 的总大小取决于所包含的所有类型中最大的那一个。<del>而对于 <code>std::variant</code>，它更像是为每一个类型单独分配一个变量来接收，例如在内部类似 <code>std::string data1, int data2</code> 这种。因此它的大小是所有类型的总和。</del><strong>更正：经过后续测试发现，<code>std::variant</code> 的大小并不是各个类型大小之和，而是最大类型的占用大小，再加上额外的 <code>size_t index</code> 的 8 字节大小。似乎不同的平台结果会不同。。。</strong></p><blockquote><p><em><strong>Currently class variant has data members <code>std::size_t type_index</code> and <code>data_type data</code>. Here sizeof(data_type) will be the size of the largest type the variant includes. But together they will be at least sizeof(size_t) &#x3D;&#x3D; 8 larger.</strong></em></p></blockquote><div class="note info flat"><p>使用 <code>g++</code> 编译器，在 <code>macos M3 arm64</code> 架构下，<code>sizeof(std::string) == 24</code>，因为 <code>char * s; size_t capacity; size_t length;</code> 总共需要 <code>3 x 8 = 24</code> 字节。  </p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">u</span> &#123;</span><br><span class="line">    <span class="type">double</span> x1;</span><br><span class="line">    <span class="type">float</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; std::endl;       <span class="comment">// 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; std::endl;        <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(u) &lt;&lt; std::endl;            <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; std::endl;          <span class="comment">// 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(std::string) &lt;&lt; std::endl;  <span class="comment">// 24</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(data) &lt;&lt; std::endl;         <span class="comment">// 32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总体来说，<code>Union</code> 占用的内存大小更少，但 <code>std::variant</code> 在技术上访问起来更加安全。</p><h2 id="std-any-存放任意类型的数据"><a href="#std-any-存放任意类型的数据" class="headerlink" title="std::any 存放任意类型的数据"></a><code>std::any</code> 存放任意类型的数据</h2><h3 id="std-any-的用法"><a href="#std-any-的用法" class="headerlink" title="std::any 的用法"></a><code>std::any</code> 的用法</h3><p>&emsp;&emsp;<code>std::any</code> 是 <code>C++17</code> 引入的新特性，允许我们将一个任意类型的数据存放进一个变量中。下边是它的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::any data;</span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    data = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string str = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(data);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::variant&lt;std::string, <span class="type">int</span>&gt; data2;</span><br><span class="line">    data2 = <span class="number">2</span>;</span><br><span class="line">    data2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(data2);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，上述程序的前半部分会在运行时抛出异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">libc++abi: terminating due to uncaught exception of type std::bad_any_cast: bad any cast</span><br><span class="line">zsh: abort      ./main</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;意思就是 <code>any_cast&lt;&gt;</code> 转换失败，因为我们想要将一个 <code>const char *</code> 的类型转成一个 <code>std::string</code> 类型。可见，这个函数是不支持隐式转换的。而下半部分是用 <code>std::variant</code> 做的对比，这一部分不会抛出异常，因为 <code>get&lt;&gt;</code> 能够做隐式的类型转换。<br>&emsp;&emsp;此外，<code>std::any</code> 的实现原理是如果要存储的类型较小，那么它会像 <code>std::variant</code> 那样工作。而如果要存储的类型较大，那么它会做动态内存分配，这样会导致性能的下降。与之对比，<code>std::variant</code> 就不会做动态内存分配。</p><h3 id="std-any-的应用场景"><a href="#std-any-的应用场景" class="headerlink" title="std::any 的应用场景"></a><code>std::any</code> 的应用场景</h3><p>&emsp;&emsp;emmm…一般来说，<code>std::any</code> 并不像前述的 <code>std::optional</code> 和 <code>std::variant</code> 那样广泛，甚至可以说是基本无用。如果你的程序必须要用一个变量存储多个值，那么你可以使用 <code>std::variant</code>，指定好可能出现的类型，使得编程更加安全。 <code>std::any</code> is just funny.</p><h2 id="string-view-获取字符串"><a href="#string-view-获取字符串" class="headerlink" title="string_view 获取字符串"></a><code>string_view</code> 获取字符串</h2><h3 id="string-view-的用法"><a href="#string-view-的用法" class="headerlink" title="string_view 的用法"></a><code>string_view</code> 的用法</h3><p>&emsp;&emsp;<code>string_view</code> 是在 <code>C++17</code> 中引入的新特性，目的是尽量避免字符串的动态分配操作，加快字符串的操作处理速度。例如我们可以通过以下代码重载全局 <code>new operator</code>，来监测内存的动态分配情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mallocCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocationg &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mallocCnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printString: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string name = <span class="string">&quot;sagsdhgdagsdhgdagsdhgdagsdhgdagsdhgddf sagagsdhgdagsdhgdagsdhgdsdhgd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string firstName = name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>);</span><br><span class="line">    std::string lastName = name.<span class="built_in">substr</span>(<span class="number">40</span>, <span class="number">74</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printString</span>(name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; mallocCnt &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>亲测在 <code>g++</code> 下，<strong>这里的字符串 <code>name</code> 需要一定的长度（大于等于 24 字节，基于 sso（小字符串优化），不同平台长度有所不同）才能够触发动态分配到堆上的操作，否则只是在栈上。</strong></p></div><p>&emsp;&emsp;像上述的代码运行后，一共会进行 4 次动态内存分配。<br>&emsp;&emsp;但是实际上我们知道，<code>firstName</code> 和 <code>lastName</code> 其实根本没有必要重新分配一块内存创建，我们可以简单地从 <code>name</code> 上截取即可。这样我们就可以使用 <code>string_view</code> 类型，仅仅只是 <code>view</code> 观察👀而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mallocCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRING_VIEW</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocationg &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mallocCnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STRING_VIEW</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;printString: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(std::string_view str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;string_view&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string name = <span class="string">&quot;sagsdhgdagsdhgdagsdhgdagsdhgdagsdhgddf sagagsdhgdagsdhgdagsdhgdsdhgd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STRING_VIEW</span></span><br><span class="line">    std::string firstName = name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">    std::string lastName = name.<span class="built_in">substr</span>(<span class="number">41</span>, <span class="number">74</span>);</span><br><span class="line">    <span class="built_in">printString</span>(name.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">37</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">std::string_view <span class="title">firstName</span><span class="params">(name.c_str(), <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string_view <span class="title">lastName</span><span class="params">(name.c_str() + <span class="number">40</span>, <span class="number">74</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    firstName = <span class="string">&quot;ADGAEHTEHEThtenheinirhwrihwihriwhrithwihtiafdiafhdaij&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; firstName &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; mallocCnt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果没有设置 <code>STRING_VIEW</code> 宏的话，同之前的代码，会进行 4 次动态内存分配。而当我们设置 <code>STRING_VIEW</code> 这个宏之后，只有 1 次动态分配了，这 1 次来源于最开始的用字符串字面量来初始化 <code>std::string name</code>。<br>&emsp;&emsp;<code>name.c_str()</code> 用来获取一个 <code>string</code> 类型的 <code>const char *</code> 表示。</p><div class="note danger flat"><p><code>string_view</code> 定义的变量是只读，不可修改的。例如上述代码若执行 <code>firstName[0] = &quot;a&quot;</code> 就会报错 <strong>“必须是可修改的左值”</strong>。<br>但是对 <code>firstName</code> 整体赋一个字符串字面量是允许的，这相当于将 <code>firstName</code> 的指针指向了当前的这个字符串字面量。因为 <code>string_view</code> 本质上就是一个 <code>const char *</code> 指针，加上一个截取的长度 <code>size</code>。并且这部分不会进行动态内存分配。</p></div><h3 id="与-const-string-的比较"><a href="#与-const-string-的比较" class="headerlink" title="与 const string &amp; 的比较"></a>与 <code>const string &amp;</code> 的比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::string_view bar)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; bar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void foo(const std::string &amp;bar) &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; bar &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;Helllllaldsfllasdlflsdfsdfasdlfl lsdfallafs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于以上代码，两个 <code>foo</code> 函数不可以同时出现，否则会有歧义报错。如果我们使用 <code>string_view</code>，不会有内存动态分配操作，而如果我们使用 <code>const string &amp;</code>，则会先将字符串字面量转为 <code>string</code> 类型，这里就会涉及内存的动态分配问题。尽管这部分内存会在该作用域结束后自动销毁，但也是一件比较耗时的操作。<br>&emsp;&emsp;但 <code>string_view</code> 也有自己的缺点，例如同 <code>const string &amp;</code> 一样只是引用了别人的，因此只是一个哑指针指向了其他变量的内存空间，其次，<code>string_view</code> 字符串没有终止符，它的字符串具体是多少只取决于首地址以及长度，是不会给自动添加 <code>&#39;\0&#39;</code> 在末尾的（话说作为只是一个观察者，自己并不拥有实际内存，貌似也无法添加终止符，因为它没有修改这部分内存的权利，实在说的话可以自己在自己类的内部实现一下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(arr)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string_view <span class="title">sv</span><span class="params">(str)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sv: &quot;</span> &lt;&lt; sv &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; sv.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data: &quot;</span> &lt;&lt; sv.<span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string_view sv2 = sv.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sv: &quot;</span> &lt;&lt; sv2 &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; sv<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; data: &quot;</span> &lt;&lt; sv<span class="number">2.</span><span class="built_in">data</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">str: Hello,worldk size: 13</span><br><span class="line">sv: Hello,worldk size: 13 data: Hello,worldk</span><br><span class="line">sv: Hel size: 3 data: Hello,worldk</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，由于我是以数组的形式提供了字符串，必须要显性指定终止符 <code>&#39;\0&#39;</code>，没有的话后续的操作字符串后面就会跟一些奇奇怪怪的字符，因为它只认终止符 <code>&#39;\0&#39;</code>，没有遇到的话之前所有的字符都会算在这个字符串里面！<br>&emsp;&emsp;另一个发现就是 <code>string_view</code> 的 <code>data()</code> 返回的是遇到终止符之前的所有字符，而非仅仅只是 <code>size</code> 长度的。这也就说明了 <code>string_view</code> 是没有终止符的，它之所以能够控制长度，完全是因为 <code>size</code> 的存在，让它知道应该取几个字符。<strong>但如果后续我们把它作为了一个地址用于其他地方，可以预想的是它不一定会按照预期显示 <code>sv</code> 的那几个字符，而是会显示 <code>data()</code> 输出的这些字符！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——编译链接</title>
      <link href="/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;预编译的头文件实际上是让你抓取一堆头文件，并将它们转换成编译器可以使用的格式，而不必一遍又一遍地读取这些头文件。<br>&emsp;&emsp;使用预编译的头文件目的是加快程序的编译速度。我们平常所用的例如 <code>&lt;iostream&gt;</code>、<code>&lt;vector&gt;</code>、<code>&lt;algorithm&gt;</code>，甚至是操作系统层面的例如 <code>Window.h</code> 等这些库在我们每次运行程序（尽管这个程序很小，可能只有 <code>std::cout &lt;&lt; someInfo &lt;&lt; std::end;</code> 这么一段打印的信息）都会全部被包含进来，然后编译、链接运行。因此，为了加快程序的编译速度，我们可以在编译编译主程序之前先将这些头文件编译一次，然后生成二进制文件缓存下来，之后每次读取这个二进制文件作为头文件使用即可。可以预见的是，自己的 <code>main</code> 程序只有寥寥几行代码，而头文件这一堆就可能有几十万行，因此程序的编译速度是会有明显提升的。</p><h3 id="什么样的头文件适合写入-stdafx-h"><a href="#什么样的头文件适合写入-stdafx-h" class="headerlink" title="什么样的头文件适合写入 stdafx.h"></a>什么样的头文件适合写入 <code>stdafx.h</code></h3><p>&emsp;&emsp;为了能够有更快的编译速度，是不是所有的头文件都应该写入 <code>stdafx.h</code>？答案是否定的。因为这个文件首次被编译出来成二进制文件，后面我们就不会再次生成或更新了，都是直接拿过来用。因此，我们频繁修改的头文件不应该写在这里面，不然每次修改都要重新编译，那和没有用预编译没什么区别了。</p><div class="note warning flat"><p><strong>频繁修改的文件不要放入 <code>stdafx.h</code> 中进行预编译！</strong></p></div><h3 id="小小的缺点"><a href="#小小的缺点" class="headerlink" title="小小的缺点"></a>小小的缺点</h3><p>&emsp;&emsp;使用预编译头文件也不是没有缺点，我们对于自己的每一个 <code>.cpp</code> 源文件，此时不用有选择性的只引入自己需要用到的头文件，而是一棍子打死，直接一个 <code>#include &quot;stdafx.h</code> 引入全体了。例如数组相关，我们本来只会引入 <code>&lt;vector&gt;</code>，但现在把 <code>&lt;thread&gt;</code> 也引入进来了。当然这没有什么损失，因为既然 <code>stdafx.h</code> 中有 <code>&lt;thread&gt;</code>，说明它在某些地方肯定能用到。而 <code>stdafx.h</code> 本质是一个巨大的共享库。但这会使得我们对于相关依赖不太清楚了。例如，自己的一个源文件被另一个人拿来用，另一个人不想用预编译头文件，就想用了几个库就引入几个，那么他并不知道究竟这里面具体用到了哪几个库，只能自己查看代码，或根据报错缺失库进行添加。</p><h3 id="C-测试"><a href="#C-测试" class="headerlink" title="C++ 测试"></a><code>C++</code> 测试</h3><p>&emsp;&emsp;在测试目录下新建 3 个文件：</p><ul><li><code>main.cpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>stdafx.cpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><code>stdafx.cpp</code> 只是一个 <code>helper file</code>，没有什么具体的实际意义。</p></div><ul><li><code>stdafx.hpp</code> 内容如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之后我们使用 <code>g++</code> 进行编译测试。（使用 <code>time</code> 可以输出编译所消耗的时间，便于比较）</p><ul><li>预编译头文件：<code>time g++ stdafx.h</code><br>&emsp;&emsp;这会生成一个 <code>stdafx.h.gch</code> 文件，可以看到，这个文件占用空间很大，仅仅包含这几个头文件就有了 <code>11.2 MB</code>。</li><li>编译主源文件：<code>time g++ main.cpp</code><br>&emsp;&emsp;这会生成可执行文件</li></ul><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul><li>不使用预编译头文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.19s user 0.05s system 81% cpu 0.298 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 105% cpu 0.228 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.19s user 0.04s system 103% cpu 0.221 total</span><br></pre></td></tr></table></figure><ul><li>使用预编译头文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ stdafx.hpp </span><br><span class="line">g++ stdafx.hpp  0.21s user 0.04s system 96% cpu 0.256 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp  </span><br><span class="line">g++ main.cpp  0.19s user 0.04s system 103% cpu 0.219 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 105% cpu 0.223 total</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % time g++ main.cpp</span><br><span class="line">g++ main.cpp  0.20s user 0.04s system 107% cpu 0.224 total</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——类与子类</title>
      <link href="/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB/"/>
      <url>/2024/11/21/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>&emsp;&emsp;对于一般成员函数来说，虚函数的意思就是这个函数可以被子类中的其他函数覆写。<strong>但对于析构函数来说，虚析构函数的意思是，不是覆写析构函数，而是加上一个新的析构函数。这是只在一个类具有子类的情况下我们才会要思考的地方。</strong>例如对于如下的代码，我们创建了两个类 <code>Base</code> 和继承自它的类 <code>Derived</code>。可以看到，它们都有对应的构造和析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Destructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Contructor.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    Base *base = <span class="keyword">new</span> Base;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> derived;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Base *c = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序的输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Base Constructor.</span><br><span class="line">Base Destructor.</span><br><span class="line">-------------</span><br><span class="line">Base Constructor.</span><br><span class="line">Derived Constructor.</span><br><span class="line">Derived Contructor.</span><br><span class="line">Base Destructor.</span><br><span class="line">-------------</span><br><span class="line">Base Constructor.</span><br><span class="line">Derived Constructor.</span><br><span class="line">Base Destructor.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>case 1</code> 和 <code>case 2</code> 输出的结果也都符合预期。但对于 <code>case 3</code> 来说，我们发现它没有调用 <code>Derived</code> 类的析构函数，这就会导致内存泄漏，因为一般来说，子类是在父类的基础上延伸拓展的，也就是子类占用的内存都会大于父类，我们只清理了父类那部分内存，专属于子类的那部分内存便泄漏了。造成这种结果的原因便是我们用一个父类类型来接收了一个子类的类型，于是删除的时候，他不知道调用的父类的析构函数层次下可能还会有子类的析构函数没有被调用。而这我们可以通过将父类的析构函数标记为虚函数来解决。<br>&emsp;&emsp;所以，我们只需要将父类的虚构函数改为 <code>virtual ~Base() &#123;...&#125;</code> 便可以解决内存泄漏问题。</p><div class="note warning flat"><p><strong>当我们在写一个要拓展的类或者子类的时候，这一点非常重要。只要你允许一个类拥有子类，那么你百分之一百需要声明父类的析构函数是虚函数！否则没有人能够安全地拓展这个类，因为子类的析构函数永远不会被调用。</strong></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——基本数据类型</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a><code>string</code> 字符串</h2><h3 id="SSO（小字符串优化）"><a href="#SSO（小字符串优化）" class="headerlink" title="SSO（小字符串优化）"></a>SSO（小字符串优化）</h3><p>&emsp;&emsp;众所周知，字符串操作在编程中是十分耗时低效的操作，因为它涉及在堆上动态分配内存，因此许多人宁愿使用 <code>const char *</code>，也要尽量避免使用 <code>std::string</code>。<code>C++</code> 意识到了这一点，因此对于小字符串做了一定的优化。<br>&emsp;&emsp;具体来讲，当字符串的长度小于某个内部的给定值的时候，它不会进行堆上的动态内存分配，而是仅仅分配到缓冲区的栈上，借此来加快程序的运行。这个具体的内部给定参考值依据不同平台有所变化，可能是 15 或 23 或其他值。一旦<strong>严格超过</strong>了这个值，就会触发动态分配 <code>Alloc</code> 机制。</p><h2 id="类型双关"><a href="#类型双关" class="headerlink" title="类型双关"></a>类型双关</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;维基百科对类型双关的定义是这样：类型双关是计算机科学的术语，指任何编程技术能颠覆或者绕过一门程序设计语言的类型系统，以达成在形式语言内部难以甚至不可能实现的效果。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>&emsp;&emsp;首先，下面的这种操作并不是类型双关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = a;   <span class="comment">// equal to: double b = (double)a</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;    <span class="comment">// output: 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为 <code>a</code> 和 <code>b</code> 本质是两段内存，而且里面存的数据并不一样，只是各自能够通过自己的类型解读成相同的数值 <code>50</code>。例如 <code>a</code> 在内存中占用 4 个字节，按小端序为 <code>32 00 00 00</code>，而 <code>b</code> 在另一段内存中占用 8 个字节，小端序为 <code>00 00 00 00 00 00 49 40</code>。</p><p>&emsp;&emsp;真正的“类型双关”是我能够让<strong>同一段数据</strong>既能够按照 <code>int</code> 类型进行读取，也能够按照 <code>double</code> 的类型进行读取，尽管不同读取方式读取出的内容可能不同。</p><p>&emsp;&emsp;那么如何做到这一点呢？使用指针！我们可以先把这个变量取地址，之后我们再对这个地址进行处理，我们让它按照另一个类型的方式取内存地址，之后再解引用，取得该变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> b = *(<span class="type">double</span> *)&amp;a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此处 <code>b</code> 的值并不固定，因为 <code>a</code> 的类型是 <code>int</code>，而 <code>int</code> 一般是占用 4 个字节，而 <code>double</code> 一般占用 8 个字节，因此紧跟在 <code>a</code> 的内存后面还有 4 个字节会被使用到，而每次运行分配的内存不同，后面紧跟的内存中的值也会不同，因此 <code>b</code> 的值不确定。<strong>一般情况下由于引用了未分配定义的额外内存，会导致程序崩溃！</strong></p><p>&emsp;&emsp;掌握了这种方法，对于内存如果有更深刻的理解，我们可以做一些更加 crazy 的操作。例如对于一个结构体 <code>Pos</code> 做下述的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pos</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Pos pos&#123;<span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.x</span></span><br><span class="line">    <span class="type">int</span> pos_x = *(<span class="type">int</span> *)&amp;pos;</span><br><span class="line">    <span class="type">int</span> pos_x2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">0</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_x2 &lt;&lt; std::endl;  <span class="comment">// output: 3, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pos.y</span></span><br><span class="line">    <span class="type">int</span> pos_y = *(<span class="type">int</span> *)((<span class="type">char</span> *)&amp;pos + <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> pos_y2 = ((<span class="type">int</span> *)&amp;pos)[<span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; pos_y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pos_y2 &lt;&lt; std::endl;  <span class="comment">// output: 5, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合体-Union"><a href="#联合体-Union" class="headerlink" title="联合体 Union"></a>联合体 <code>Union</code></h2><p>&emsp;&emsp;多个变量共用同一块内存，改变了其中一个变量的值，其他变量的值同样也会跟随变化。多个变量可以是不同的类型，这样读取的时候就相当于进行了类型双关的操作了。<del>经过 <code>g++</code> 编译器实测，两者的大小不同时也并不会报错，应该也是进行了内存越界访问，与类型双关类似。</del><strong>更正：<code>union</code> 的大小取决于其中最大的那个变量类型。</strong><br>&emsp;&emsp;一般来说 <code>union</code> 是匿名使用的，而匿名 <code>union</code> 不能够有成员函数。<br>&emsp;&emsp;例如对于如下的代码，我们发现其实 <code>Vector4</code> 是可以使用 <code>Vector2</code> 的打印函数 <code>print_vector2</code> 进行打印的，无非是将其分成两个 <code>Vector2</code> 类型即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, w, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么我们如何做到这一点呢？答案是使用 <code>union</code>，我们对 <code>Vector4</code> 内部可以声明一个别名，就是两个 <code>Vector2</code>，它们和正常的那 4 个 <code>int</code> 数据占用的是同一块内存，因此修改其中一方，另一方也会进行修改，并且没有引入额外的内存或副本。当然，我们也可以利用前面刚学习的类型双关技术，强制将 <code>Vector4</code> 转成两个 <code>Vector2</code> 进行读取，此处就不展开了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector4</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// form 1</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">int</span> x, y, w, v;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// form 2</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            Vector2 a, b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_vector2</span><span class="params">(<span class="type">const</span> Vector2 &amp;vec2)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">2.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">2.</span>y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Vector4 vec4&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; vec<span class="number">4.</span>w &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vec<span class="number">4.</span>v &lt;&lt; std::endl;</span><br><span class="line">    vec<span class="number">4.</span>x = <span class="number">500</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>a);</span><br><span class="line">    <span class="built_in">print_vector2</span>(vec<span class="number">4.</span>b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意 <code>struct</code> 和 <code>union</code> 这些匿名使用的时候，只是作为了一种数据结构在使用，由于没有名称，在结构体或类的内部使用时也无法使用 <code>.name.member_var</code> 获取内部的成员变量，可以直接 <code>.member_var</code> 获取。例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Union</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">double</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Union u = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; u.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; u.b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>&emsp;&emsp;<code>C++</code> 是一种强类型语言，每一个变量必须对应有自己的数据类型，但不同的数据类型之间一般是可以进行类型转换的。早在 <code>C</code> 中，我们便可以使用例如如下的代码进行转换，我们称之为 <code>C-style</code> 类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a = <span class="number">5.4</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (int)a = 5</span></span><br><span class="line">    <span class="type">double</span> c = (<span class="type">int</span>)a + b;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; c &lt;&lt; std::endl;    <span class="comment">// output: 10.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而在 <code>C++</code> 中，我们共有四种类型转换的函数可供使用，分别是 <code>static_cast&lt;&gt;</code>、<code>reinterpret_cast&lt;&gt;</code>、<code>dynamic_cast&lt;&gt;</code>、<code>const_cast</code>。</p><div class="note info flat"><p><code>C++</code> 的这些不过只是语法糖，只能能做 <code>C-style</code> 能做的一切而已。它可能会做其他的事情，但实际的结果也只是一个成功的类型转换而已。</p></div><ul><li><code>static_cast&lt;&gt;</code> 为静态类型转换，是最一般的用法，它会做一些编译时检查，看看这种转换是否真的可能。</li><li><code>reinterpret_cast&lt;&gt;</code> 类似类型双关，是要将这一段内存重新解释为其他数据类型。</li><li><code>const_cast&lt;&gt;</code> 移除或添加变量的 <code>const</code> 限定。</li><li><code>dynamic_cast&lt;&gt;</code> 运行时检查某种转换是否能够发生。</li></ul><p>&emsp;&emsp;搞这么多 <code>cast</code> 的好处是，除了可能收到那些编译时检查之外，还可以在代码库中搜索它们，便于全部替换某种类型转换。同时，还能帮助我们减少在尝试类型转换的时候可能会意外犯的错误，例如类型不兼容。</p><p>&emsp;&emsp;对于如下代码，我们显然知道一个 <code>double</code> 数据是不能够转成一个我们自定义的类的，因此使用 <code>static_cast</code> 会直接在编译期间报错。而我们使用 <code>reinterpret_cast</code> 便可以以重新解读该内存的方式进行转换。<br>&emsp;&emsp;对于 <code>dynamic_cast</code>，这是在运行时进行类型检查，它与运行时类型信息 RTTI 紧密相关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">AnotherDerived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">5.23</span>;</span><br><span class="line">    <span class="comment">// wrong</span></span><br><span class="line">    <span class="type">double</span> s = <span class="built_in">static_cast</span>&lt;AnotherDerived&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s2 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(value) + <span class="number">5.1</span>;</span><br><span class="line">    <span class="type">double</span> s3 = <span class="built_in">static_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successs</span></span><br><span class="line">    <span class="type">double</span> s4 = <span class="built_in">reinterpret_cast</span>&lt;AnotherDerived *&gt;(&amp;value) + <span class="number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    Derived *derived = <span class="keyword">new</span> Derived;</span><br><span class="line">    Base *base = derived;</span><br><span class="line"></span><br><span class="line">    AnotherDerived *ad = <span class="built_in">dynamic_cast</span>&lt;AnotherDerived *&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (!ad) std::cout &lt;&lt; <span class="string">&quot;failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;convert successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行上述代码，最后的 <code>ad</code> 为空，输出 <code>failed.</code>。因为它是一个 <code>Derived</code> 类型，我们不能先用父类接收它，然后反手把它转成 <code>AnotherDerived</code> 的。这里并不会在编译阶段报错，我们需要在运行时手动捕获观察。</p><h2 id="dynamic-cast-再探"><a href="#dynamic-cast-再探" class="headerlink" title="dynamic_cast 再探"></a><code>dynamic_cast</code> 再探</h2><p>&emsp;&emsp;<code>dynamic_cast</code> 更像是一个函数，因为它不是在编译时检查，而是在运行时进行类型检查，因此有相关的运行成本。它是专门用于沿继承层次结构进行的强制类型转换，例如从子类到父类，或者从父类到子类的转换。如果是子类转成父类，过程相对简单，甚至不需要 <code>static_cast</code> 也可以隐式转换。但反过来就会有问题了。例如我有一个 <code>Entity</code> 实体类，表示游戏中的所有实体，<code>Enemy</code> 和 <code>Player</code> 都继承自它。那么我现在有一个 <code>Entity</code> 的指针，指向一个实体，我想把它转成 <code>Player</code> 类，是否可以做到？我们知道，这个 <code>Entity</code> 有 3 中可能，可能是 <code>Player</code>，也可能是 <code>Enemy</code>，还有可能是除这两者外的其他实体。因此我们需要判断是否能够进行转换，否则如果我们把一个 <code>Enemy</code> 转成了 <code>Player</code>，访问了 <code>Player</code> 的独有数据，就可能会造成程序的崩溃。</p><p>&emsp;&emsp;如果转换失败，那么会返回 <code>NULL</code>，否则，返回转换后指向这种类型的一个指针。</p><p>&emsp;&emsp;示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Enemy</span> : <span class="keyword">public</span> Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player *player = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it is easy to cast a derived class to base class.</span></span><br><span class="line">    Entity *e = player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong!!</span></span><br><span class="line">    <span class="comment">// Player *p = e;</span></span><br><span class="line"></span><br><span class="line">    Entity *actualEnemy = <span class="keyword">new</span> Enemy;</span><br><span class="line">    Entity *actualPlayer = <span class="keyword">new</span> Player;</span><br><span class="line"></span><br><span class="line">    Player *p1 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualEnemy);</span><br><span class="line">    Player *p2 = <span class="built_in">dynamic_cast</span>&lt;Player *&gt;(actualPlayer);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (p1 == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (p2 == <span class="literal">nullptr</span>) &lt;&lt; std::endl;   <span class="comment">// output: 1, 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h2><p>&emsp;&emsp;<code>C++</code> 中可以为每一个类编写对应的类型转换操作符，考虑如下的代码场景。我们编写了 <code>ScopedPtr</code> 类，并且我们动态分配了内存给类内的指针 <code>m_Ptr</code> 成员变量。按照惯例，我们在分配之后都应该查看是否分配成功。对于一般的指针而言，我们可以直接写 <code>if (ptr) &#123;&#125;</code> 这类的判断语句。因为一个指针实际上就是一个整数，可以判断整数是否是 0 来做决定。但我们将指针包装进了一个类，对于类如何进行布尔判断，编译器并不知道应该怎么处理。我们当然可以编写 <code>bool isValid()</code> 函数，调用时写 <code>if (scopedPtr.isValid()) &#123;&#125;</code> 来判断。但这样太麻烦了，还要调用成员函数。能不能像之前那样只要把实例放进去就好了？答案是可以的，我们需要提供类的布尔运算符，这样后续有需要的话，就会自动调用该运算符将这个类转换成布尔值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(T *ptr) : <span class="built_in">m_Ptr</span>(ptr) &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>() &#123; <span class="keyword">delete</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T *<span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_Ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ScopedPtr&lt;Entity&gt; e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">    Entity *e2 = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左值-lvalue-和右值-rvalue"><a href="#左值-lvalue-和右值-rvalue" class="headerlink" title="左值 lvalue 和右值 rvalue"></a>左值 <code>lvalue</code> 和右值 <code>rvalue</code></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>&emsp;&emsp;<code>C++</code> 中的数据及表达式等还分为左值 <code>lvalue</code> 和右值 <code>rvalue</code>，但它们的定义并不是根据它们是在等号的左边还是右边，但大部分情况下也都是符合的。<strong>更多的人是这样认为的：左值是程序运行过程中在内存中明确有存储空间的，而右值则是临时变量，在内存中没有存储空间，使用后不久就会被销毁。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string firstName = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string lastName = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 4</span></span><br><span class="line">    std::string name = firstName + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如对于上述代码：</p><ul><li><code>case 1</code> 中显然 <code>i</code> 是在内存有 <code>int</code> 型存储空间的，因此是左值，而右边的 <code>10</code> 则是个立即数，赋完值后就会消失。显然 <code>10 = i</code> 这种写法是大错特错的。</li><li><code>case 2</code> 中 <code>a</code> 和 <code>i</code> 都是左值，尽管 <code>i</code> 出现在等号的右边。</li><li><code>case 3</code> 中 <code>firstName</code> 和 <code>lastName</code> 都是左值，右边的字符串字面量都是右值。</li><li><code>case 4</code> 中，<code>firstName + lastName</code> 这个表达式整体是一个右值，取这两个左值的拼接字符串作为临时变量，用来初始化 <code>std::string name</code>。我们显然不会写出 <code>firstName + lastName = &quot;xxx&quot;</code> 这种语句。</li></ul><h3 id="与引用-的关系"><a href="#与引用-的关系" class="headerlink" title="与引用 &amp; 的关系"></a>与引用 <code>&amp;</code> 的关系</h3><p>&emsp;&emsp;<code>C++</code> 中有左值引用和右值引用。引用的原理就是取这块内存的地址，只不过不是指针的形式，而是包装成了仍使用原变量符号的形式。因此，我们不能有 <code>int&amp; a = 10</code> 这种操作，<strong>这会在编译期间报 “非常量引用的初始值必须为左值” 的错误。</strong>因为 <code>10</code> 本质上是没有内存空间的。但什么是 “非常量引用”？因为 <code>C++</code> 中允许我们对常量进行引用，这时候要用 <code>const int&amp; a = 10</code>，这时候就不会报错了，就像是你承诺了我虽然会引用这个数据，但是我不会对此进行修改，我不会把一个常量 <code>10</code> 变为 <code>1</code>，因为 <code>10</code> 就是 <code>10</code>。<br>&emsp;&emsp;常值引用的作用如下代码所述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即我们有一个内存占用很大的对象，这里以 <code>string</code> 举例。我们要对其进行打印，要把它作为参数传入进去。我们知道由于对象很大，我们肯定不会选择拷贝一份用来打印，理想的方法是使用引用，这样可以避免拷贝复制。但这样就有问题了，这是一个非常量引用，它只能接收左值，例如上述代码，对于 <code>print(str)</code> 是可以正常运行的，但 <code>print(&quot;Hello, world)&quot;</code> 就不可以了，因为一个字符串字面量是右值。这时候，我们就可以修改 <code>print()</code> 函数的参数类型，改为 <code>const std::string &amp;</code>，这也是为什么大多数函数只要不是在内部修改参数的数据，都会选用 <code>const type &amp;</code> 的原因。</p><p>&emsp;&emsp;上述讲的都是左值引用，除此之外还有右值引用。一般来说，写函数的时候都会提供两个版本的函数，一个是 <code>const type &amp;</code> 常量引用版本的，用来处理左值引用，如有必要也可以处理右值引用。另一个版本是 <code>type &amp;&amp;</code>，这是专门用来处理右值引用的。那既然有了 <code>const type &amp;</code> 可以用来处理右值了，那为什么还要提供专门处理右值的版本呢？这主要在于程序的优化。如果我们知道传入的是一个临时对象的话，我们就不需要担心它是否完整，是否拷贝，我们可以简单无虑地使用它的资源，给到特定的对象，或者在其他地方使用它们，而不需要对其后果做考虑，因为反正不久后它也就会被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[lvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string &amp;&amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[rvalue] &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">[lvalue] Hello, world</span><br><span class="line">[rvalue] Hello, world</span><br></pre></td></tr></table></figure><p>可以看到，对于传入一个右值，<code>type &amp;&amp;</code> 的调用优先级是要高于 <code>const type &amp;</code> 的。</p><h2 id="移动语句"><a href="#移动语句" class="headerlink" title="移动语句"></a>移动语句</h2><p>&emsp;&emsp;移动，即将一块内存从一个地方移动到另一个地方。但我们知道，内存就在那个地方，是无法移动的。因此，一种思路是将这块内存的数据搬到另一块内存，然后把原内存中的数据清空，这样就实现了移动的操作。但这种方法的时间复杂度为 $O(N)$。即如果有 $N$ 个字节，我们就需要移动 $N$ 次。<font color="darkred"><strong>其实还有另一种方法，那就是我们把指向新内存的指针搬过来，让它指向旧内存的首地址，这种只是修改了一个指针的指向，因此时间复杂度为 $O(1)$。但事情到这里还没有结束，因为此时我们如果要删除旧地址的指针，由于此时它还是指向这一块内存，这样就会顺带把这块内存数据给删去了，那么新的指针也无法工作了。因此，我们还要将旧的指针置为 <code>nullptr</code>。</strong></font>这种思路就是移动语句的思想。<br>&emsp;&emsp;因此一般来说，移动构造能够既节约内存（无需开辟新内存，可以将旧的将要废弃的内存直接拿过来用，不用再根据它复制开一块新的内存空间），又能节约时间（无需开辟新内存并复制过来，显然这是一项耗时的操作，而是直接修改一个指针的指向即可）。<br>&emsp;&emsp;下面通过一个具体的例子来讲解移动语句的好处。<br>&emsp;&emsp;我们需要创建两个类：</p><ul><li><p><strong>其一是自定义的 <code>String</code> 类。</strong></p><ul><li>我们首先定义了它的构造函数，一种是无参构造，按默认即可；一种是接收 <code>const char *</code> 字符串字面量来进行构造；还有一种是接收相同类型的 <code>const String &amp;</code> 进行拷贝构造。</li><li>其次我们定义一个打印函数 <code>Print()</code>，将字符串逐字符打印出来。</li><li>最后是简单的析构函数。</li></ul></li><li><p><strong>其二是用到 <code>String</code> 类的 <code>Entity</code> 类</strong></p><ul><li>构造函数方面，这里比较简单，<code>Entity</code> 类只有实体的名称，它的类型就是 <code>String</code>，因此我们只写一个接收字符串的构造函数即可，参数形式为 <code>const String &amp;</code>。</li><li>我们也定义了一个打印实体名称的函数，内部调用 <code>String</code> 的打印函数实现。</li></ul></li></ul><p>&emsp;&emsp;接下来我们思考我们在 <code>main</code> 函数中定义一个 <code>Entity</code> 类的实例 <code>Entity e = Entity(&quot;Hello, world&quot;)</code> 时会发生什么。</p><ol><li>首先，<code>&quot;Hello, world&quot;</code> 要隐式转换为 <code>String</code> 类型，并且我们已经提供了相应的构造函数，此时动态分配了内存，会输出 <code>&quot;Created!&quot;</code>。</li><li>然后，调用 <code>Entity</code> 的构造函数，接收 <code>const String &amp;</code>，我们知道这是允许接收右值的。之后由其列表初始化功能 <code>m_Name(name)</code>，这里又会调用 <code>String(const String &amp;)</code> 的构造函数，即用一个 <code>String</code> 来初始化另一个 <code>String</code>，由 <code>String</code> 构造函数内部的代码可知，这里又会进行一次动态内存分配，会输出 <code>&quot;Copied!&quot;</code>。</li><li>之后由于 <code>&quot;Hello, world&quot;</code> 是一个右值，临时变量，完成了对 <code>Entity</code> 的构造之后，就会被销毁了，调用 <code>String</code> 的析构函数，释放这部分内存，输出 <code>&quot;Destroyed&quot;</code>。</li><li>后续作用域结束后，<code>e</code> 调用 <code>Entity</code> 的析构函数，释放它的内存。</li></ol><p>&emsp;&emsp;由上述的流程可知，我们为了定义一个 <code>Entity</code> 并将其初始化，一共进行了两次的动态内存分配，虽然有一次在初始化完成后就释放了，但复制内存生成新内存的时间是无法挽回的。从结果来看，我们只是动态分配了 <code>Entity</code> 里面的一个 <code>String</code> 而已，能不能只分配这一次内存呢？答案是可以的，只要用到移动语句即可，而它的思想就是我们在本节最开头加粗说的那样。<br>&emsp;&emsp;为了实现移动功能，我们需要添加一些代码。首先，我们的 <code>String</code> 构造函数仍然是正常接收一个 <code>const char *</code> 的字符串字面量，仍然正常分配动态内存生成一个 <code>String</code>。但是，当用这个 <code>String</code> 来初始化 <code>Entity</code> 中的实体名字字符串时，我们不能再让他与正常的分配过内存空间的字符串一样走 <code>String(const String &amp;str)</code> 这个构造函数。因为它实际上是一个右值，我们专门提供 <code>String(String &amp;&amp;str)</code> 来处理它。<br>&emsp;&emsp;因为这个 <code>String</code> 是一个右值，而所有的 <code>String</code> 都是有堆上的内存空间的，所以对于右值，这部分空间很快就要被释放的，我们可以用这块的内存直接来构造调用 <code>String(String &amp;&amp;)</code> 这个函数的字符串，省去了内存的分配、拷贝等步骤，只是简单的修改指针的朝向，更快速高效。<br>&emsp;&emsp;具体的代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = <span class="built_in">strlen</span>(str.m_Data);</span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_Data, str.m_Data, m_Size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;str) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_Size = str.m_Size;</span><br><span class="line">        m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">        str.m_Size = <span class="number">0</span>;</span><br><span class="line">        str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroyed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> m_Data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_Size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; m_Data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *m_Data;</span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="type">const</span> String &amp;name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(String &amp;&amp;name) : <span class="built_in">m_Name</span>((String &amp;&amp;)name) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_Name.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Entity e = <span class="built_in">Entity</span>(<span class="built_in">String</span>(<span class="string">&quot;Hello, world&quot;</span>));</span><br><span class="line">    e.<span class="built_in">PrintName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意在 <code>Entity(String &amp;&amp;name) : m_Name((String &amp;&amp;)name) {}</code> 中，列表初始化里还是要显性指定这是一个右值，否则还是会走 <code>const String &amp;</code> 常量引用的构造函数！而且比起 <code>(String &amp;&amp;)name</code>，更推荐使用 <code>std::move(name)</code></strong></p></div><p>&emsp;&emsp;总的来说就是一句话，右值不配拥有动态分配的内存空间，如果有，那可以将这块空间转交给别人继续使用，再留给它也是浪费了（指对于右值，一般存活时间不会很长，很快内存就会被释放）</p><h2 id="std-move-与移动赋值操作符"><a href="#std-move-与移动赋值操作符" class="headerlink" title="std::move 与移动赋值操作符"></a><code>std::move</code> 与移动赋值操作符</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a><code>std::move</code></h3><p>&emsp;&emsp;上一节中重点讲了移动构造，这一节主要讲移动赋值。首先来看一下 <code>std::move()</code>。上面也说了，<code>std::move()</code> 就是做了一个类型转换，将当前的变量类型标记为右值类型，通过 <code>static_cast</code> 实现，以下是 <code>std::move()</code> 的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_LIBCPP_NODISCARD_EXT <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt;&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_LIBCPP_LIFETIMEBOUND _Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="type">__libcpp_remove_reference_t</span>&lt;_Tp&gt; _Up;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;大概能看到 <code>static_cast</code> 和右值符 <code>&amp;&amp;</code>，推测中间部分 <code>_Up</code> 就是原先变量的类型。当然，在简单情况下我们可以直接自行使用 <code>static_cast</code> 转换，但对于复杂数据类型情况尤其是使用了 <code>auto</code> 的情况下，既然 <code>C++</code> 本身给我们提供了更方便安全的转换函数，我们就安心的用吧！😌</p><h3 id="移动赋值操作符"><a href="#移动赋值操作符" class="headerlink" title="移动赋值操作符"></a>移动赋值操作符</h3><p>&emsp;&emsp;注意下述代码中的两个 <code>=</code> 是不同的含义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2;</span><br><span class="line">str2 = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>这第一个的 <code>=</code> 实际上是调用了 <code>String(const char *)</code> 构造函数，因此这是一个构造操作，并不是赋值操作。</li><li>而第二个是调用了无参构造函数，并在后续使用了一个字符串字面量进行赋值操作，这里才是真正的赋值操作，相当于 <code>str2.operator=(&quot;Hello, world!&quot;)</code>。</li></ul><p>&emsp;&emsp;因此要实现移动赋值操作，我们还需要提供 <code>String &amp;operator=(String &amp;&amp;str)</code> 移动赋值操作符的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String &amp;<span class="keyword">operator</span>=(String &amp;&amp;str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> m_Data;</span><br><span class="line"></span><br><span class="line">            m_Size = str.m_Size;</span><br><span class="line">            m_Data = str.m_Data;</span><br><span class="line"></span><br><span class="line">            str.m_Size = <span class="number">0</span>;</span><br><span class="line">            str.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这部分代码中，我们主要做的事情同移动构造函数，都是将当前实例的字符串指针以及长度赋值为右值的，然后把右值的置为空。<font color="darkred"><strong>但是，不同于构造函数是从头从无到有开始构造，赋值操作时当前的字符串可能有了自己的那一块内存，因此我们要先将这一块内存给释放掉，否则，更改了它的指针，这一块内存就无法获取，造成了内存泄漏。</strong></font><br>&emsp;&emsp;还有一点要注意的是，由于当前的字符串会释放自己之前的内存，<strong>我们要小心传入的右值是否就是当前字符串本身，如果是的话，那删除之后自身也无法获取右值的那些数据了，因为右值就是自己，一块全给删掉啦！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——数据结构</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a><code>vector</code></h2><h3 id="优化部分"><a href="#优化部分" class="headerlink" title="优化部分"></a>优化部分</h3><p>&emsp;&emsp;分析下述代码，找出可以优化的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(std::vector&lt;Data&gt; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; vec[i].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Data&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存分配优化"><a href="#内存分配优化" class="headerlink" title="内存分配优化"></a>内存分配优化</h4><p>&emsp;&emsp;首先，我们可以重载全局的 <code>void *operator new(size_t size)</code> 方法，看一下一共动态分配了多少的内存。篇幅原因，此处的代码略，完整代码整合可以见后文。仅显示运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">Allocating: 4 bytes.</span><br><span class="line">Allocating: 8 bytes.</span><br><span class="line">Allocating: 16 bytes.</span><br><span class="line">Allocating: 32 bytes.</span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 5</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出，我们一共进行了整整 <strong>5</strong> 次的内存分配！理想情况下，应该只有 1 次分配就可以了，因为 <code>vector</code> 就是在堆上动态分配内存，因此至少会有 1 次。可是这里竟然有 5 次，下面来分析一下：</p><ul><li>首先，我们看到 <code>printVector</code> 函数接收的参数是 <code>vector&lt;data&gt;</code>，这里是值传递，因此会发生拷贝，构造一个新的 <code>vector</code> 供函数内部使用。而这一部分是可以优化的，我们只需要传递一个引用就可以了，改为 <code>const vector&lt;data&gt; &amp;</code>。可以看到，修改后我们只有 4 次分配啦！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">Allocating: <span class="number">4</span> bytes.</span><br><span class="line">Allocating: <span class="number">8</span> bytes.</span><br><span class="line">Allocating: <span class="number">16</span> bytes.</span><br><span class="line">Allocating: <span class="number">32</span> bytes.</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">Allocating: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>其次，这里涉及到 <code>vector</code> 的内部实现原理。如果我们定义了一个 <code>vec</code>，但却没有指明要分配多少内存，则默认是 0 字节内存，即还没有动态分配内存。可以利用 <code>.capacity()</code> 函数验证：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Data&gt; vec;</span><br><span class="line">std::cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出的结果为 0，并且重写的 <code>new</code> 函数在此处并没有被调用，也就是说没有动态分配任何内存。</p><p>&emsp;&emsp;之后我们利用 <code>push_back()</code> 往后追加数据时，内部会比较 <code>size + 1</code> 和 <code>capacity</code> 的大小，如果 <code>size + 1</code> 更大，说明预先分配的大小不够了，因此会重新分配一块更大的内存。那具体分配的是多少呢？不同的编译器实现的不同，有可能是 1.5 倍，大多数是 2 倍，可以进入 <code>push_back()</code> 的源码进行查看。例如在我的编译器下定位源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Precondition:  __new_size &gt; capacity()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">_LIBCPP_CONSTEXPR_SINCE_CXX20 <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI <span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::size_type</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__recommend(size_type __new_size) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="type">const</span> size_type __ms = <span class="built_in">max_size</span>();</span><br><span class="line">  <span class="keyword">if</span> (__new_size &gt; __ms)</span><br><span class="line">    <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line">  <span class="type">const</span> size_type __cap = <span class="built_in">capacity</span>();</span><br><span class="line">  <span class="keyword">if</span> (__cap &gt;= __ms / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> __ms;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">max</span>&lt;size_type&gt;(<span class="number">2</span> * __cap, __new_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，是按原先大小的两倍进行分配的。因此上述的 4 次就好解释了：</p><ol><li>开始的 <code>vec</code> 大小是 0，要添加新数据，<code>size = 0</code>, <code>capacity = 0</code>, <code>size + 1 &lt; capacity</code>，因此<strong>分配 1 次内存</strong>，此时 <code>capacity = 1</code>；</li><li>之后又要添加数据，数据大小来到了 2，但是容量仍是 1，因此又要<strong>重新分配一次内存</strong>，<code>capacity = 2</code>；</li><li>之后添加第 3 个数据，发现又不够用了，因此<strong>再重新分配一次</strong>，为原来的 2 倍，此时 <code>capacity = 4</code>；</li><li>之后添加第 4 个数据，能够正常添加进去；</li><li>添加最后一个数据，容量又不够啦！因此<strong>再重新分配一次</strong>，<code>capacity = 8</code>。</li></ol><p>&emsp;&emsp;数一下，一共分配了 4 次内存，与程序的结果一致。我们还可以进行验证，此时的 <code>vec.capacity() == 8</code>，此处略。</p><div class="note danger flat"><p><strong>注意这里的重新分配是要重新找一块足够大的内存，然后将原有的数据再原封不动的复制过来，并不是简单地在原先数据的后面接着开辟额外的内存就可以了，因为后面的内存本身就不属于自身所有，可能已经被其他部分使用了。</strong></p></div><p>&emsp;&emsp;为了解决这个问题，我们可以在定义的时候预先指定我们的 <code>vector</code> 的大小。这里有两种方法：</p><ul><li>其一，定义时指定 <code>vector&lt;int&gt; vec(n, 0)</code> 可以指定 <code>vec</code> 的大小为 <code>n</code>，同时初始化所有值为 <code>0</code>。也可以在后续通过 <code>.resize()</code> 函数指定 <code>n</code> 和初值。注意这个方法会同时改变 <code>vec</code> 的长度 <code>size</code> 和 <code>capacity</code>，也就是 <code>vec</code> 中已经有了这么多值了，使用或修改时直接调用 <code>vec[i]</code> 即可。</li><li>其二，使用 <code>reserve(n)</code> 来预留空间，这相当于是提前霸占了一块内存，“即使我现在还没有用到这么多，但是你们其他谁都不可以动这块内存，它全都是我的”。也就是说 <code>vec</code> 的 <code>size</code> 依旧是 0，但是 <code>capacity</code> 已经变成 <code>n</code> 了，由于只是霸占，内部仍然是空的，因此使用时还需要先用 <code>vec.push_back</code> 添加值。</li></ul><p>&emsp;&emsp;经过这两步的修改，我们的动态内存分配成功地来到了只有 1 次！！🎉🎉</p><h4 id="拷贝复制优化"><a href="#拷贝复制优化" class="headerlink" title="拷贝复制优化"></a>拷贝复制优化</h4><p>&emsp;&emsp;嘿嘿，是不是以为结束了。还早呢，孩子！接下来，让我们看一下这里面一共进行了多少次的拷贝操作吧！要查看到这一点，我们需要提供 <code>Data(const Data &amp;)</code> 拷贝构造函数，并在里面加点统计信息。依旧，代码见最后～输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">Copied!</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 5</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Ohhh! 竟然有 5 次拷贝！为啥会有这么多呢，按理来说应该是 0 次的呀。这里就涉及到 <code>push_back</code> 的事情了。它有两个重载，一个是接收左值 <code>const reference</code> 的，另一个是专门接收右值 <code>&amp;&amp;</code> 的。这里调用的是后者。我们每 <code>push_back</code> 一个值的时候，都会先构造一个临时的变量 <code>Data(i)</code>，之后我们再用它拷贝构造一份到 <code>vec</code> 中。<code>C++</code> 在这里已经尽力了，它提供了 <code>push_back</code> 的两种接收类型，就是想让我们在如果传入的参数是一个右值的时候，能够 “移动” 而非 “拷贝”。以下是节选的 <code>push_back</code> 接收右值的实现源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">_LIBCPP_CONSTEXPR_SINCE_CXX20 <span class="keyword">inline</span> _LIBCPP_HIDE_FROM_ABI <span class="type">void</span> vector&lt;_Tp, _Allocator&gt;::<span class="built_in">push_back</span>(value_type&amp;&amp; __x) &#123;</span><br><span class="line">  pointer __end = <span class="keyword">this</span>-&gt;__end_;</span><br><span class="line">  <span class="keyword">if</span> (__end &lt; <span class="keyword">this</span>-&gt;__end_cap()) &#123;</span><br><span class="line">    __construct_one_at_end(std::<span class="built_in">move</span>(__x));</span><br><span class="line">    ++__end;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __end = __push_back_slow_path(std::<span class="built_in">move</span>(__x));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;__end_ = __end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，里面对传入的数据 <code>__x</code> 都是调用了 <code>std::move</code>，尽量避免拷贝。但为什么我们还是拷贝了呢？因为我们并没有提供移动构造函数！！所以迫不得已它只能走了常值引用的拷贝构造函数，因为这个函数也是可以接收右值的。因此，只要我们提供了 <code>Data(Data &amp;&amp; other)</code> 函数，就能够避免复制啦！结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br></pre></td></tr></table></figure><h4 id="移动优化"><a href="#移动优化" class="headerlink" title="移动优化"></a>移动优化</h4><p>&emsp;&emsp;想不到吧，还可以优化！！既然我们提供了移动构造函数，因此我们按照上面所说的，查看一下进行了多少次移动吧！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">Moved!</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br><span class="line">Moved!5</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有 5 次！发生在我们每次添加新元素！这时候我们想，能不能把移动次数也减掉呢？考虑我们现在的流程：我们先创建一个临时变量 <code>Data(i)</code>，当然这个变量用的内存还是在堆上，之后我们把它 <code>push_back</code> 进 <code>vector</code>。相比于复制，我们现在实现了移动操作，能够将这部分内存的所有者移动给 <code>vec</code>。那我们想，为什么不能一开始就直接归 <code>vec</code> 所有，非要先流经他人之手，最后再归到自己的手上呢？<br>&emsp;&emsp;<code>C++</code> 给了我们这个机会，那就是 <code>emplace_back()</code> 函数。相比于 <code>push_back()</code>，我们要传入的不再是一个 <code>Data</code> 类的对象，因为这样的话又会将该内存的所有者暂时给到这个临时变量（当然非要传入的话也没有错，只不过就和 <code>push_back</code> 没区别了，一样要移动）。我们传入如何构造这个类的参数，让 <code>vec</code> 自己在内部构造，这样的话所有值直接就归 <code>vec</code> 所有了！<br>&emsp;&emsp;优化后的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                         </span><br><span class="line">Allocating: 20 bytes.</span><br><span class="line">0 1 2 3 4 </span><br><span class="line">Allocating: 1</span><br><span class="line">Copied: 0</span><br><span class="line">Moved: 0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;大功告成！</p><h4 id="完整优化后的代码"><a href="#完整优化后的代码" class="headerlink" title="完整优化后的代码"></a>完整优化后的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> allocating_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> copied_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> moved_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    allocating_number++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data &amp;other) &#123;</span><br><span class="line">        copied_number++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        val = other.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Data</span>(Data &amp;&amp;other) &#123;</span><br><span class="line">        moved_number++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Moved!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        val = other.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> std::vector&lt;Data&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; vec[i].val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Data&gt; vec;</span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating: &quot;</span> &lt;&lt; allocating_number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied: &quot;</span> &lt;&lt; copied_number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Moved: &quot;</span> &lt;&lt; moved_number &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h2><p>&emsp;&emsp;与 <code>vector</code> 不同的是，<code>vector</code> 是动态分配到堆上的，而 <code>array</code> 是分配到栈上的，因此 <code>array</code> 理论上来说访问、修改的速度要比 <code>vector</code> 快。而且，<code>array</code> 必须在定义时指定具体的大小，因此它的长度是固定的，而 <code>vector</code> 则是可以变化的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(std::array&lt;<span class="type">int</span>, <span class="number">5</span>&gt; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 6&gt; arr2;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="built_in">printArray</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码展示了 <code>array</code> 的基本用法。但是有一个弊端就是对于 <code>printArray</code> 这类的如果要将 <code>array</code> 作为一个参数传入函数时，由于 <code>array</code> 自身的大小也是构造 <code>array</code> 的一个不可或缺的数据，因此我们必须要显性指定出来 <code>array</code> 的大小，这里就有问题了。也就是说我们的函数限制了传入的 <code>array</code> 长度必须是 <code>5</code>，一旦传入其他值就都会因为参数类型不正确而报错。那么如何修改这一点呢？<br>&emsp;&emsp;可以使用模板 <code>template</code> 来帮助我们，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::array&lt;T, N&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 6&gt; arr2;</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="built_in">printArray</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 <code>iterator</code></h2><h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><p>&emsp;&emsp;迭代器用于对一个数据集合进行迭代，可以用来遍历元素，例如如下的代码，通过了三种方法来遍历一个 <code>vector</code> 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">        std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : vec)</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于有下标索引的数据集合例如 <code>vector</code>，其实不必非要使用 <code>iterator</code> 来遍历或操作元素。但对于一些没有下标索引的数据类型来说，数据不一定是连续存放的，例如树，无序集合等，这时候还是有必要使用的。示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line">    map[<span class="string">&quot;Hello, world&quot;</span>] = <span class="number">23</span>;</span><br><span class="line">    map[<span class="string">&quot;asd&quot;</span>] = <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unordered_map&lt;std::string, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;key = it-&gt;first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;value = it-&gt;second;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;key = kv.first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;value = kv.second;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key] &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; [value] &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>注意最后一种方法是 <code>C++17</code> 新引入的 “结构化绑定” 特性，确保编译执行时使用的 <code>C++</code> 标准在 <code>C++17</code> 及以上！</strong></p></div><h3 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h3><h2 id="std-map-和-std-unordered-map"><a href="#std-map-和-std-unordered-map" class="headerlink" title="std::map 和 std::unordered_map"></a><code>std::map</code> 和 <code>std::unordered_map</code></h2><p>&emsp;&emsp;<code>std::map</code> 和 <code>std::unordered_map</code> 是 <code>C++</code> 中的键值对容器，模板的第一个参数指定的是键的数据类型，第二个指定的是值的数据类型。添加键值对的时候只需要简单地以键作为索引，用值进行赋值即可。<br>&emsp;&emsp;<code>std::unordered_map</code> 要比 <code>std::map</code> 快很多，前者是基于哈希，后续基于红黑树，内部会维持着一定的顺序，因此速度上就会慢一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CityRecord</span> &#123;</span><br><span class="line">    std::string cityName;</span><br><span class="line">    <span class="type">uint64_t</span> population;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    std::unordered_map&lt;std::string, CityRecord&gt; cityMap;</span><br><span class="line">    cityMap[<span class="string">&quot;ak&quot;</span>] = CityRecord &#123; <span class="string">&quot;ak&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;bk&quot;</span>] = CityRecord &#123; <span class="string">&quot;bk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;ck&quot;</span>] = CityRecord &#123; <span class="string">&quot;ck&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;dk&quot;</span>] = CityRecord &#123; <span class="string">&quot;dk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cityMap[<span class="string">&quot;ck&quot;</span>].population &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义键的哈希函数"><a href="#自定义键的哈希函数" class="headerlink" title="自定义键的哈希函数"></a>自定义键的哈希函数</h3><div class="note danger flat"><p>注意，键的类型不能够是自定义的！除非你能够自行提供哈希函数。因为对于自定义的类，<code>C++</code> 内部并不知道应该如何对其进行哈希处理，进而进行存储。因此，<strong>如果非要以自定义的类作为键，请使用指针形式，因为指针在本质上只是一个整数，或者自行提供对应的哈希处理函数！</strong></p></div><p>&emsp;&emsp;对于 <code>CityRecord</code> 类，如果我们想要用它作为键值，需要自行提供对应的哈希函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CityRecord</span> &#123;</span><br><span class="line">    std::string cityName;</span><br><span class="line">    <span class="type">uint64_t</span> population;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CityRecord&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> CityRecord &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> population &lt; other.population;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;CityRecord&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> CityRecord &amp;key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(key.cityName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    std::unordered_map&lt;std::string, CityRecord&gt; cityMap;</span><br><span class="line">    cityMap[<span class="string">&quot;ak&quot;</span>] = CityRecord &#123; <span class="string">&quot;ak&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;bk&quot;</span>] = CityRecord &#123; <span class="string">&quot;bk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;ck&quot;</span>] = CityRecord &#123; <span class="string">&quot;ck&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    cityMap[<span class="string">&quot;dk&quot;</span>] = CityRecord &#123; <span class="string">&quot;dk&quot;</span>, <span class="number">100000</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cityMap[<span class="string">&quot;ck&quot;</span>].population &lt;&lt; std::endl;</span><br><span class="line">    cityMap.<span class="built_in">erase</span>(<span class="string">&quot;ak&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;CityRecord, std::string&gt; foundedMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cityName, CityRecord] : cityMap) &#123;</span><br><span class="line">        foundedMap[CityRecord] = cityName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : foundedMap) &#123;</span><br><span class="line">        <span class="type">const</span> CityRecord &amp;city = kv.first;</span><br><span class="line">        std::string &amp;name = kv.second;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;[key.name] &quot;</span> &lt;&lt; city.cityName &lt;&lt; <span class="string">&quot; [val] &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;几个关键点：</p><ol><li>对应的 <code>CityRecord</code> 类必须重载 <code>operator==</code> 运算符，以便 <code>map</code> 知道这个键是否已经插入过了；</li><li>提供的哈希函数可以写在 <code>std</code> 命名空间内，这样我们就不要在定义的时候显性提供这个哈希函数；</li><li>哈希函数通常是一个结构体，我们需要重载 <code>operator()</code> 方法，并且这个成员函数一定要是 <code>const</code> 的。</li></ol><p>&emsp;&emsp;<font color="red"><strong>注意如果我们用的是 <code>std::map</code> 而非 <code>std::unordered_map</code>，这时我们的自定义类必须还要重载 <code>operator&lt;</code> 用于排序！如下所示：</strong></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> CityRecord &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> population &lt; other.population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>必须要保证每一个实例的 <code>population</code> 属性不能相同，否则就会相互覆盖掉！</p></div><h3 id="插入新键值的不同方法比较"><a href="#插入新键值的不同方法比较" class="headerlink" title="插入新键值的不同方法比较"></a>插入新键值的不同方法比较</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 1</span></span><br><span class="line">CityRecord &amp;city = cityMap[<span class="string">&quot;Berlin&quot;</span>];</span><br><span class="line">city.cityName = <span class="string">&quot;Berlin&quot;</span>;</span><br><span class="line">city.population = <span class="number">5000</span>;</span><br><span class="line">city.x = <span class="number">20</span>;</span><br><span class="line">city.y = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2</span></span><br><span class="line">CityRecord city2;</span><br><span class="line">city<span class="number">2.</span>cityName = <span class="string">&quot;New&quot;</span>;</span><br><span class="line">city<span class="number">2.</span>population = <span class="number">333</span>;</span><br><span class="line">city<span class="number">2.</span>x = <span class="number">30</span>;</span><br><span class="line">city<span class="number">2.</span>y = <span class="number">44</span>;</span><br><span class="line">cityMap[<span class="string">&quot;New&quot;</span>] = city2;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上的两种构建并插入键值的方法，第一种方法会快一些。因为它直接将内存空间建在了 <code>cityMap</code> 里面，之后我们引用（<strong>注意一定是引用 <code>&amp;</code>，否则后续的赋值无效！</strong>）这段空间，并将里面的相关数据赋上值。而对于第二种方法，它是先在栈上创建一个这个类型，之后完成初始化赋值之后，再在 <code>cityMap</code> 上创建这样一段内存空间并将栈上的这些数据复制过去，因此就会慢一些。</p><div class="note info flat"><p>注意如果直接使用 <code>cityMap[&quot;key&quot;]</code>，如果已经有这个键了，那么它会返回对应的值。<strong>但是如果没有这个键，它并不会报错或告知有任何不存在的信息，而是会默认构造一个值，并将这对键值自动插入到 <code>cityMap</code> 中！</strong>如果你只是单纯想索引一个 <code>map</code> 中是否存在某个键，请使用 <code>.at()</code> 方法，这样就不会在不存在的时候默认给你创建并插入了。</p></div><p>&emsp;&emsp;而且如果一个 <code>map</code> 是以 <code>const</code> 定义的，那么我们只能使用 <code>.at()</code> 方法，而不能使用下标索引方法。原因就像之前所说的，如果不存在给定的键时，使用下标索引会自动创建，而这违反了 <code>const</code> 不会修改 <code>map</code> 的本意，因此编译会报错。<br>&emsp;&emsp;在使用 <code>at()</code> 前最好做一下检查，看 <code>map</code> 中是否真的存在这个键：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cityMap.<span class="built_in">find</span>(<span class="string">&quot;New&quot;</span>) != cityMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; cityMap.<span class="built_in">at</span>(<span class="string">&quot;New&quot;</span>).cityName &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-的遍历方法"><a href="#map-的遍历方法" class="headerlink" title="map 的遍历方法"></a><code>map</code> 的遍历方法</h3><p>&emsp;&emsp;一般来说不要对 <code>map</code> 进行遍历操作，我们使用 <code>map</code> 的原因就是它能够快速给我们一个键对应的值，而不需要我们遍历后才能够得知。但实际上对 <code>map</code> 的遍历也是允许的，有两种方法，都是基于 <code>iterator</code> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cityName, CityRecord] : cityMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; cityName &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; CityRecord.cityName &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv : cityMap) &#123;</span><br><span class="line">    <span class="type">const</span> std::string &amp;name = kv.first;</span><br><span class="line">    CityRecord &amp;city = kv.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意键的类型是 <code>const</code> 的，因为我们是不能够修改键的值的。</p><h3 id="map-的删除操作"><a href="#map-的删除操作" class="headerlink" title="map 的删除操作"></a><code>map</code> 的删除操作</h3><p>&emsp;&emsp;比较简单，只要使用 <code>.erase()</code> 并提供相应的键即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cityMap.<span class="built_in">erase</span>(<span class="string">&quot;ak&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——内存</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="多维数组的创建及删除"><a href="#多维数组的创建及删除" class="headerlink" title="多维数组的创建及删除"></a>多维数组的创建及删除</h2><h3 id="1-维数组的动态分配内存"><a href="#1-维数组的动态分配内存" class="headerlink" title="1 维数组的动态分配内存"></a>1 维数组的动态分配内存</h3><p>&emsp;&emsp;直接使用 <code>new</code> 关键字进行分配，指令为 <code>int *arr = new int[50]</code>，这会分配一块<strong>连续的</strong> 50 个 <code>int</code> 大小的内存空间，并且返回这块内存的首地址给到 <code>arr</code>，<code>arr</code> 的类型为 <code>int *</code>。</p><h3 id="2-维数组的动态内存分配"><a href="#2-维数组的动态内存分配" class="headerlink" title="2 维数组的动态内存分配"></a>2 维数组的动态内存分配</h3><p>&emsp;&emsp;首先我们需要分配一块内存空间 <code>a</code>，这块内存空间中的每一个值都是一个地址，指向另一块内存空间 <code>b_i</code> 的首地址，这样，我们便实现了二维数组的创建。例如，对于一个二维数组 <code>arr2d[i][j]</code>，首先，我们取 <code>a[i]</code> 中的值，这便是一个地址，我们顺着这个地址就能够找到第 <code>i</code> 块内存 <code>b_i</code>，之后我们锁定了这块内存。而由二维数组可知，这一块内存中每个里面存的便是具体的数据内容了。具体取哪个数据，便取决于 <code>j</code> 啦！</p><h3 id="3-维数组的动态内存分配"><a href="#3-维数组的动态内存分配" class="headerlink" title="3 维数组的动态内存分配"></a>3 维数组的动态内存分配</h3><p>&emsp;&emsp;对于三维内存，此处就不再赘述了，无非是 <code>arr3d[i][j][k]</code>，由 <code>i</code> 锁定第 <code>i</code> 个内存块，不同于二维数组，这个内存块上存的仍然是其他内存块的首地址，也就是还是一个指针。我们再在这个基础上锁定其第 <code>j</code> 个的地址，顺着找到第 <code>j</code> 个内存块，这个内存块里面存的才是具体的数据内容，我们要取哪一个数据值呢？第 <code>k</code> 个！</p><h3 id="多维数组的删除"><a href="#多维数组的删除" class="headerlink" title="多维数组的删除"></a>多维数组的删除</h3><p>&emsp;&emsp;多维数组的创建我们是通过一层层 <code>new</code> 来实现的。同样的，删除我们也是要一层层来实现的。显然，我们正着创建多维数组，那么删除的时候就要倒着一层层来删除，否则，假设我们将前面的内存块给删了，由于他们保存着其他内存块首地址，删了他们我们就无法访问这些内存块了。因此，我们要先顺藤摸瓜，找到最根源的内存块，再一步步倒回来全部删干净。<br>&emsp;&emsp;而删除一个内存块，我们可以使用 <code>delete[] arr</code> 来实现。</p><h3 id="C-的具体实现"><a href="#C-的具体实现" class="headerlink" title="C++ 的具体实现"></a><code>C++</code> 的具体实现</h3><p>&emsp;&emsp;具体的实现代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1-D array</span></span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2-D array</span></span><br><span class="line">    <span class="type">int</span> **arr2d = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr2d[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr2d[<span class="number">0</span>][<span class="number">40</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-D array</span></span><br><span class="line">    <span class="type">int</span> ***arr3d = <span class="keyword">new</span> <span class="type">int</span>**[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        arr3d[i] = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; ++j) &#123;</span><br><span class="line">            arr3d[i][j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">50</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr3d[<span class="number">40</span>][<span class="number">30</span>][<span class="number">20</span>] = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 1-D</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete 2-D</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr2d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2d;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><p>&emsp;&emsp;由上述我们可以知道，每一个内存块内部的数据是连续的，<strong>但是，不同的内存块之间并不一定是连续的。</strong>这取决于操作系统的分配，很大程度上是不会连续的。因此，创建了多维数组之后，后续在索引具体某一个元素的值的时候，可能会出现 <code>cache miss</code>，也就是缓存不命中的情况，这会使得我们程序的运行速度变慢。因此，并不推荐使用多维数组。取而代之，我们可以将数组扁平化，例如使用一维数组来代替二维数组，这会使得所有的数据在内存中全部连续，大大加快了读写的速度。例如 <code>arr2d[i][j]</code> 可以写作 <code>arr[i * col + j]</code> 的形式。</p><h2 id="安全编程，关于智能指针与原始指针的使用"><a href="#安全编程，关于智能指针与原始指针的使用" class="headerlink" title="安全编程，关于智能指针与原始指针的使用"></a>安全编程，关于智能指针与原始指针的使用</h2><p>&emsp;&emsp;智能指针是对原始指针的包装，能够自动管理内存，在我们不再需要某一块内存时能够自动释放，减少了程序员的工作量，同时避免了因疏忽导致的内存泄漏问题。在进行一些大型或生产项目的时候，推荐使用智能指针进行内存管理。<br>&emsp;&emsp;但原始指针使用起来更加方便、简单，只需要一个小小的 <code>*</code> 即可。在写一些较小的项目、编程测试时，还是可以使用的。并且，使用原始指针能够让我们对内存管理等有更加清晰深刻的理解。</p><h2 id="跟踪内存分配的简单方法"><a href="#跟踪内存分配的简单方法" class="headerlink" title="跟踪内存分配的简单方法"></a>跟踪内存分配的简单方法</h2><p>&emsp;&emsp;无需借助外部工具，我们可以通过重载 <code>new</code> 和 <code>delete</code> 来实现跟踪内存分配与释放的情况。以下是一个简单的示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序运行结果：</p><div class="note info flat"><p><strong>注意在 <code>g++</code> 中，默认使用的 <code>delete</code> 函数是不带有第二个参数 <code>size_t size</code> 的，因为这一信息已经会被内部的内存管理器保留，无需再次传入。但我们要想探测内存释放的情况，还是有必要传入的。我们可以通过对编译时传入参数 <code>fsized-deallocation</code> 来使用这一个版本的 <code>delete</code> 函数。</strong></p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % g++ -std=c++17 -fsized-deallocation main.cpp -o main</span><br><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main                                              </span><br><span class="line">Allocating 32 bytes</span><br><span class="line">Allocating 12 bytes</span><br><span class="line">freeing 12 bytes</span><br></pre></td></tr></table></figure><p>我们可以进一步将其进行包装成一个类或结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> AllocationMetrics s_AllocationMetrics;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalAllocated += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *memory, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    s_AllocationMetrics.TotalFreed += size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;freeing &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintCurrentUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current Usage: &quot;</span> &lt;&lt; s_AllocationMetrics.<span class="built_in">CurrentUsage</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    std::string s = <span class="string">&quot;ASASDFAsadfasdgdsgsdDFeaf&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;();</span><br><span class="line">        <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintCurrentUsage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针的概念"><a href="#函数指针的概念" class="headerlink" title="函数指针的概念"></a>函数指针的概念</h3><p>&emsp;&emsp;“函数指针” 和 “指针函数” 是不同的概念，所谓的 “指针函数” 就是指一个返回类型是指针的函数，例如 <code>int *func(int a)</code> 返回类型是 <code>int *</code>，即一个指针，没啥好讲的，此处略过，重点来看 “函数指针”。</p><p>&emsp;&emsp;学过一点计算机体系结构或偏底层的汇编知识应该知道，函数名称其实就是一个地址。每次我们调用函数的时候，实际上就是保存当前帧 (frame) 的状态，将参数压栈，然后跳到函数名称所指的地址处，将传入的参数弹出使用，执行内部的代码。在 <code>C++</code> 中，我们可以额外定义变量，来调用使用其他的函数，具体的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[value]: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 1</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr)(<span class="type">int</span>);</span><br><span class="line">    func_ptr = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 2</span></span><br><span class="line">    <span class="built_in">void</span> (*func_ptr2)(<span class="type">int</span>) = &amp;printValue;</span><br><span class="line">    <span class="built_in">func_ptr2</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3</span></span><br><span class="line">    <span class="type">void</span> *addr = (<span class="type">void</span> *)printValue;</span><br><span class="line">    ((<span class="built_in">void</span> (*)(<span class="type">int</span>))addr)(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addition</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;function address: &quot;</span> &lt;&lt; (<span class="type">void</span> *)printValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; printValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们定义了一个打印值的函数 <code>printValue(int)</code>，之后我们定义函数指针 <code>func_ptr</code>，我们要指定返回类型，以及参数列表。只要能和它这两者相匹配的，我们便可以对其赋值，并使用这个函数指针来调用函数。<br>&emsp;&emsp;<code>case 1</code> 是先定义，然后在后续再赋值使用；<code>case 2</code> 是在定义的时候就直接赋值使用了；而 <code>case 3</code> 则是我们可以强行取函数的地址，之后再将这个地址强制转成对应的函数指针类型，也是可以正常使用的，不过这样做除了装一下没啥实际意义。</p><div class="note danger flat"><p>注意，我们在取函数的地址的时候，一定要使用 <code>void *</code> 进行类型的强制转换，否则仅仅放一个函数指针的话，会执行内部的 <code>bool()</code> 运算符，将其转为一个布尔值，并且永远都是 <code>true</code>。<br>警告信息：<em><strong>warning: address of function ‘printValue’ will always evaluate to ‘true’ [-Wpointer-bool-conversion]</strong></em></p></div><p>&emsp;&emsp;<code>C++</code> 内部做了隐式转换，因此无论是下面代码中的哪两种，都是可以正常运行的。函数名在大多数的上下文里都会被隐式转成函数指针。函数名的签名为 <code>void printValue(int a)</code>，而函数指针的签名为 <code>void (*func_ptr)(int a)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func_ptr = printValue;</span><br><span class="line">func_ptr = &amp;printValue;</span><br><span class="line"><span class="built_in">func_ptr</span>(<span class="number">1</span>);</span><br><span class="line">(*func_ptr)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="函数指针的应用场景"><a href="#函数指针的应用场景" class="headerlink" title="函数指针的应用场景"></a>函数指针的应用场景</h3><p>&emsp;&emsp;例如我们现在有了一个 <code>vector</code>，以及一个遍历函数 <code>forEach()</code>，我们可以在 <code>forEach()</code> 函数中传入一个函数指针，表明我们想在遍历的时候做什么操作，例如最简单的只是打印每个元素，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    forEach(vec, printVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶-——-lambda-表达式"><a href="#进阶-——-lambda-表达式" class="headerlink" title="进阶 —— lambda 表达式"></a>进阶 —— <code>lambda</code> 表达式</h3><p>&emsp;&emsp;<code>lambda</code> 表达式是一种创建函数的方式，可以使我们不必实际创建函数。也就是这个函数更像是一个变量，而非真正意义上的函数。<strong>在能够使用函数指针的地方，我们都可以使用 <code>lambda</code> 表达式。</strong><br>&emsp;&emsp;我们希望能够将一个函数传递给一个 <code>API</code>，以便在将来的某个时候，它能够为我们调用这个函数解决问题。此刻我们不这样做的原因是我们还没有函数执行所需要用到的数据，或者我们只是想推迟函数的执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">void</span> (*func_ptr)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line">    forEach(vec, lambda);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当捕获列表 <code>[]</code> 为空的时候，<code>C++</code> 内部会为我们调用转换函数 <code>ClosureType::operator ret(*)(params)()</code> 将 <code>lambda</code> 表达式转成不同的函数指针，但当捕获列表不为空的时候，我们就不能使用普通的函数指针了，这个时候就需要用到 <code>&lt;functional&gt;</code> 库。</p><p>&emsp;&emsp;下面举一个实际能够用到 <code>lambda</code> 表达式的例子。例如，我们调用 <code>std::find_if</code> 库，取得一个 <code>vector</code> 中第一个大于 3 的数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func_ptr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; v : vec) &#123;</span><br><span class="line">        <span class="built_in">func_ptr</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lambda = [=](<span class="type">int</span> val) &#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> val) &#123;<span class="keyword">return</span> val &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>lambda</code> 表达式的捕获列表形式如下表所示，节选自 <a href="https://en.cppreference.com/w/cpp/language/lambda">cpp reference</a></p><table><thead><tr><th>syntax</th><th>explanation</th></tr></thead><tbody><tr><td><code>identifier</code></td><td>simple by-copy capture</td></tr><tr><td><code>identifier ...</code></td><td>simple by-copy capture that is a pack expansion</td></tr><tr><td><code>identifier initializer</code></td><td>by-copy capture with an initializer <font color="darkgreen"><strong>(since C++14)</strong></font></td></tr><tr><td><code>&amp; identifier</code></td><td>simple by-reference capture</td></tr><tr><td><code>&amp; identifier ...</code></td><td>simple by-reference capture that is a pack expansion</td></tr><tr><td><code>&amp; identifier initializer</code></td><td>by-reference capture with an initializer <font color="darkgreen"><strong>(since C++14)</strong></font></td></tr><tr><td><code>this</code></td><td>simple by-reference capture of the current object</td></tr><tr><td><code>* this</code></td><td>simple by-copy capture of the current object <font color="darkgreen"><strong>(since C++17)</strong></font></td></tr><tr><td><code>... identifier initializer</code></td><td>by-copy capture with an initializer that is a pack expansion <font color="darkgreen"><strong>(since C++20)</strong></font></td></tr><tr><td><code>&amp; ... identifier initializer</code></td><td>by-reference capture with an initializer that is a pack expansion <font color="darkgreen"><strong>(since C++20)</strong></font></td></tr></tbody></table><h2 id="栈-stack-vs-堆-heap"><a href="#栈-stack-vs-堆-heap" class="headerlink" title="栈 stack vs 堆 heap"></a>栈 <code>stack</code> vs 堆 <code>heap</code></h2><p>&emsp;&emsp;尽管堆和栈是不同的概念，但在物理层面，它们是相同的，都是一块 <code>RAM</code> 内存，只是我们认为将其进行了区分（<strong>因此栈内存分配并不是在 <code>CPU</code> 缓存上，而是在计算机的 <code>RAM</code> 上的</strong>）每个应用程序运行的时候，操作系统都会给我们分配一定区域的堆栈空间供我们使用。一般情况下，我们直接声明定义的变量都是在栈 <code>stack</code> 上的，只有调用 <code>new</code> 动态分配内存声明定义的变量才是在堆上的。<br>&emsp;&emsp;在栈上分配内存是十分快捷的，可以在一个指令时间内完成。因为我们所需要做的仅仅只是将栈顶指针指向的空间内赋予有效数据，然后再将栈顶指针进行移动即可。而在堆上分配就会十分的慢了，因为我们要使用 <code>new</code> 命令分配内存，然后 <code>new</code> 命令调用 <code>malloc</code> 函数询问相应的操作系统分配所需大小的内存空间，操作系统再通过查询空闲内存表来确定要分配哪一块内存。因此会涉及到许多的底层操作，分配起来就会很慢。<br>&emsp;&emsp;同时，访问速度上，由上述我们可以得知，栈上分配的内存一般都是连续的，因为我们的栈顶指针 <code>SP</code> 一直是在连续自增或自减的。因此，我们访问时一般所有的数据都是连续存放在一起的，访问一个数据的同时很容易就能访问到另一个数据，这在我们想要访问不同数据时可以加快访问的速度。对比之下，在堆上就不是这么一回事了，因为我们每次调用 <code>malloc</code>，都是取决于操作系统根据空闲内存表决定给我们分配哪一块内存，谁都不能保证两次调用的 <code>malloc</code> 返回的内存空间是连续在一起的。因此访问起来就会慢很多，涉及到 <font color="skyblue"><strong>缓存不命中 (cache missed)</strong></font> 问题。<br>&emsp;&emsp;因此，一般来说，我们尽可能要在栈上分配内存，除非我们<strong>想要一个变量的生命周期要比其所在的函数（作用域）长</strong>（因为栈上分配的内存的生命周期都在一个作用域内。例如我们在一个函数 <code>f</code> 内声明了一个变量，那么当这个函数结束返回的时候，栈顶指针便会直接恢复到之前调用 <code>f</code> 之前的位置，也就会造成 <code>f</code> 内的栈上变量无效，对应的生命周期结束），或者<strong>实在是有比较大的数据量</strong>，我们会想要在堆上分配内存。<br>&emsp;&emsp;总的来说，造成堆和栈区别的本质原因在于 “分配”。<br>&emsp;&emsp;文章推荐：<a href="https://blog.csdn.net/m0_47324800/article/details/134674765">堆和栈的效率比较</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——线程</title>
      <link href="/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/11/20/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h2><p>&emsp;&emsp;线程的作用：优化程序，可以让程序在同一时间能够执行多个指令，加快程序的运行速度。<br>&emsp;&emsp;要使用进程，首先需要引入头文件 <code>#include &lt;thread&gt;</code></p><ul><li>创建进程，使用 <code>std::thread threadName(functionPointer)</code>，需要传入一个函数指针，表示想要执行的操作的函数。</li><li>让某些指令需要在该线程执行完之后再执行，使用 <code>threadName.join()</code>，该函数后面的函数只有在这个进程结束后才会执行。</li><li>在一个进程中，可以使用 <code>std::this_thread</code> 来表示当前的进程，可用其中的 <code>get_id()</code> 函数来获取当前进程的 id，使用 <code>sleep_for()</code> 来将进程延时，防止某个进程单独消耗 CPU 过多的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> isFinished = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workingFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isFinished) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(workingFn)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">    isFinished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了使用例如 <code>1s</code> 这种一个常值量后面跟一个 <code>s</code> 单位表示时间的变量，我们需要使用命名空间 <code>std::literals::chrono_literals;</code>，并且该命名空间在 <code>C++14</code> 中支持，如果当前的编译器报错，需要显性指定 <code>C++</code> 版本，如 <code>g++ -std=c++14 main.cpp -o main</code>，或者修改编译器的默认配置。</p><h2 id="计时相关操作"><a href="#计时相关操作" class="headerlink" title="计时相关操作"></a>计时相关操作</h2><p>&emsp;&emsp;<code>C++11</code> 中引入了 <code>std::chrono</code>，用于一种与平台无关的高精度计时。当然，也可以使用操作系统相关的 API，这会提供更多的精度以及其他方面的控制。在一般情况下，<code>std::chrono</code> 就已经够用了。<br>&emsp;&emsp;同样，我们应该引入库文件 <code>#include &lt;chrono&gt;</code>。</p><ul><li>获取当前时间，使用 <code>std::chrono::high_resolution_clock::now()</code> 指令，这个函数返回的类型为 <code>std::chrono::time_point&lt;std::chrono::steady_clock&gt;</code>，一般情况下，我们可以直接使用 <code>auto</code> 关键字。</li><li>两个上述类型的时间相减，有额外的类型用来表示，这就是 <code>std::chrono::duration&lt;float&gt;</code>，即初到末的“持续时间”。</li><li>打印输出的时候，要使用 <code>.count()</code> 函数获取具体的时间数值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Timer</span>() &#123;</span><br><span class="line">        start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Timer</span>() &#123;</span><br><span class="line"></span><br><span class="line">        end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        duration = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">        std::chrono::duration&lt;<span class="type">float</span>&gt; duration_ms = duration * <span class="number">1000.0f</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; duration_ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Timer timer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用计时来进行基准测试"><a href="#使用计时来进行基准测试" class="headerlink" title="使用计时来进行基准测试"></a>使用计时来进行基准测试</h2><p>&emsp;&emsp;评测 <code>C++</code> 程序运行的性能指标有很多，其中一种便是查看程序从开始到结束运行的总时长，这就可以用到我们上述学到的计时相关内容。例如，我们可以写一个 <code>Timer</code> 类，构造时获取当前时间开始计时，析构时再次获取当前时间并结算经过的时间总长，这样我们把它放在一个局部的作用于内，就可以用来评测局部作用域内代码执行的总耗时。例如，下述的例子我们评测 <code>unique_ptr</code> 和 <code>shared_ptr</code> 以及类型转换与 <code>make_unique</code> 这类函数的执行用时。</p><p>&emsp;&emsp;以下是我们用到的计时器的类定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Timer</span>() &#123;</span><br><span class="line">        start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(start_time).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(end_time).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> duration_us = end - start;</span><br><span class="line">        <span class="type">double</span> duration_ms = duration_us * <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It took: &quot;</span> &lt;&lt; duration_us &lt;&lt; <span class="string">&quot;us (&quot;</span> &lt;&lt; duration_ms &lt;&lt; <span class="string">&quot; ms)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后是我们的主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Vector2</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#123;   </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared ptr use make_shared()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">make_shared</span>&lt;Vector2&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared ptr use new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::shared_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; sharedPtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            sharedPtrs[i] = std::<span class="built_in">shared_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;unique ptr use make_unique&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; uniquePtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            uniquePtrs[i] = std::<span class="built_in">make_unique</span>&lt;Vector2&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;unique ptr use new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::array&lt;std::unique_ptr&lt;Vector2&gt;, <span class="number">10000</span>&gt; uniquePtrs;</span><br><span class="line">        Timer timer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            uniquePtrs[i] = std::<span class="built_in">unique_ptr</span>&lt;Vector2&gt;(<span class="keyword">new</span> <span class="built_in">Vector2</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) scy@scydeMacBook-Air leetcode_test % ./main</span><br><span class="line">shared ptr use make_shared()</span><br><span class="line">It took: 2570us (2.57 ms)</span><br><span class="line">shared ptr use new</span><br><span class="line">It took: 2077us (2.077 ms)</span><br><span class="line">unique ptr use make_unique</span><br><span class="line">It took: 747us (0.747 ms)</span><br><span class="line">unique ptr use new</span><br><span class="line">It took: 737us (0.737 ms)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到 <code>make_shared</code> 和 <code>make_unique</code> 确实是要比 <code>new</code> 之后再进行类型转换要快很多。而且 <code>shared_ptr</code> 要比 <code>unique_ptr</code> 慢很多，以下是 GPT 解释的原因：</p><p>&emsp;&emsp;<strong>1. 共享所有权</strong><br>&emsp;&emsp;<code>std::unique_ptr</code> 表示对对象的独占所有权。它的实现相对简单，只需管理一个指针。由于没有其他指针指向同一个对象，内存的释放也非常直接和高效。<br>&emsp;&emsp;<code>std::shared_ptr</code> 允许多个 <code>shared_ptr</code> 实例共享同一个对象的所有权。为了实现这一点，<code>shared_ptr</code> 需要维护一个引用计数（reference count），以跟踪有多少个 <code>shared_ptr</code> 实例指向同一个对象。</p><p>&emsp;&emsp;<strong>2. 引用计数的管理</strong><br>&emsp;&emsp;<strong>引用计数：</strong>每当创建一个 <code>shared_ptr</code> 或复制一个 <code>shared_ptr</code> 时，都会增加引用计数；当 <code>shared_ptr</code> 被销毁或重置时，会减少引用计数。这涉及到原子操作（atomic operations），以确保在多线程环境中引用计数的安全性和一致性。<br>&emsp;&emsp;<strong>性能开销：</strong>这些原子操作（例如增加或减少计数）引入了一定的性能开销。相比之下，<code>unique_ptr</code> 的操作不需要额外的同步机制。</p><p>&emsp;&emsp;<strong>3. 内存管理</strong><br>&emsp;&emsp;<strong>控制块：</strong><code>shared_ptr</code> 还需要一个控制块（control block），该控制块存储引用计数和可能的弱引用计数（<code>std::weak_ptr</code>）。这意味着 <code>shared_ptr</code> 需要额外的内存开销来管理这些信息。<br>&emsp;&emsp;<strong>内存分配：</strong>每次创建 <code>shared_ptr</code> 时，它通常需要分配额外的内存来存储控制块，这增加了内存分配的频率和复杂性。</p><p>&emsp;&emsp;<strong>4. 线程安全</strong><br>&emsp;&emsp;<strong>线程安全的考虑：</strong>由于 <code>shared_ptr</code> 可能在多个线程中共享，必须确保对引用计数的操作是线程安全的。这使得 <code>shared_ptr</code> 的实现更复杂，并可能导致性能降低。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 学习——命名空间</title>
      <link href="/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/11/19/C++-%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 <code>namespace</code></h2><p>&emsp;&emsp;在 <code>C</code> 中，我们只能通过给函数名称前加上独有的前缀来避免命名冲突，例如对于 <code>GLFW</code> 库，这是一个 <code>C</code> 库，其中的所有函数都是以 <code>GLFW</code> 开头，例如 <code>GLFWInit()</code>。同样的还有 <code>OpenGL</code> 库，例如 <code>glInit()</code> 等。<br>&emsp;&emsp;在 <code>C++</code> 中，我们可以通过命名空间来<strong>解决多个相同函数名命名冲突的问题。</strong><br>&emsp;&emsp;<code>using namespace</code> 只在当前作用域中有效。尽量不要乱用，可以仅在一个 <code>if</code> 语句中使用，实在不行再考虑加到源文件的开头，但永远不要用在头文件中！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> function &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名空间同样支持赋值操作</span></span><br><span class="line">    <span class="keyword">namespace</span> a = apple::function;</span><br><span class="line">    a::<span class="built_in">print2</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于下面</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> function;</span><br><span class="line">    <span class="built_in">print2</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么不建议使用-using-namespace-std"><a href="#为什么不建议使用-using-namespace-std" class="headerlink" title="为什么不建议使用 using namespace std"></a>为什么不建议使用 <code>using namespace std</code></h2><p>&emsp;&emsp;因为这样做会污染空间，可能导致自己不知道这个函数或类型究竟是来自哪里，尤其是当自己写的函数与标准库例如 <code>std</code> 中名称相同时，好的情况下会报错有歧义，但坏的情况可能依据某些规则选择了其中之一，而恰恰这不是我们想要的那一个，大大增加了出 bug 的风险。<br>&emsp;&emsp;例如如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> apple &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> orange &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        std::string temp = str;</span><br><span class="line">        std::<span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; temp &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> apple;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> orange;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    apple::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);      <span class="comment">// output: Hello</span></span><br><span class="line">    orange::<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// output: olleH</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);             <span class="comment">// output: olleH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由上面的代码以及输出结果可以看到，<code>print(&quot;Hello)</code> 并没有报歧义的错误，而是选择了 <code>orange</code> 命名空间。这是因为传入的参数 <code>&quot;Hello</code> 本质上是一个 <code>const char *</code>，所以 <code>orange</code> 不会做类型转换，可以直接调用，而 <code>apple</code> 会做一次隐式转换，将其转成 <code>std::string</code> 类型。综合来看，会选择 <code>orange</code>。而假如我们期望是使用 <code>apple</code>，那么这里就会出 bug 咯。</p><p>&emsp;&emsp;最后，一定要牢记一条：<strong>永远 永远 永远不要在头文件里面使用命名空间 <code>using namespace</code>，Never！</strong>。头文件的 <code>include</code> 原理就是直接把文件原封不动地搬过来贴在源文件的开头，也就是一旦在头文件中使用了 <code>using namespace</code>，那么所有引入它的源文件都会使用了这个命名空间，出了问题的话，emmmmm……</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录0——杂项</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%950%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%950%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="一图流背景"><a href="#一图流背景" class="headerlink" title="一图流背景"></a>一图流背景</h2><h2 id="获取网页帧率并显示"><a href="#获取网页帧率并显示" class="headerlink" title="获取网页帧率并显示"></a>获取网页帧率并显示</h2><h3 id="html-pug-部分"><a href="#html-pug-部分" class="headerlink" title="html (.pug) 部分"></a>html (.pug) 部分</h3><p>&emsp;&emsp;我们不必新创建一个 pug 文件，可以直接在已有的基础上进行添加。在 <code>layout/includes/layout.pug</code> 中添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    footer#footer(style=footer_bg)</span><br><span class="line">    !=partial(&#x27;includes/footer&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  </span><br><span class="line">+    #leftside-fps</span><br><span class="line">+      span#leftside-fps-text</span><br><span class="line"></span><br><span class="line">    include ./rightside.pug</span><br><span class="line">    include ./additional-js.pug</span><br></pre></td></tr></table></figure><h3 id="css-styl-部分"><a href="#css-styl-部分" class="headerlink" title="css (.styl) 部分"></a>css (.styl) 部分</h3><p>&emsp;&emsp;这一部分没有合适的现成文件了，我们可以手动创建一个 <code>leftside-fps.styl</code> 文件，放置在 <code>/source/css/_layout/</code> 目录下，代码如下，主要是让他固定在页面的左下角，再进行一些美化，例如字体、圆角、背景颜色等等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#leftside-fps</span></span><br><span class="line">  <span class="attribute">position</span>: fixed</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">8px</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">8px</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">8</span>)</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span></span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#leftside-fps-text</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">    <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br></pre></td></tr></table></figure><h3 id="js-部分"><a href="#js-部分" class="headerlink" title="js 部分"></a>js 部分</h3><p>&emsp;&emsp;写一份获取帧率的 js 代码，命名为 <code>getFps.js</code>，放置在自己的 <code>source</code> 目录下，原理很简单，代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> frameCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> lastTime = performance.<span class="title function_">now</span>();</span><br><span class="line">    $leftsizeFpsTextEle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;leftside-fps-text&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateFPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentTime = performance.<span class="title function_">now</span>();</span><br><span class="line">        frameCount++;</span><br><span class="line">        <span class="comment">// print the frameCount every second</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            $leftsizeFpsTextEle.<span class="property">innerText</span> = <span class="string">`FPS: <span class="subst">$&#123;frameCount&#125;</span>`</span></span><br><span class="line">            frameCount = <span class="number">0</span>; <span class="comment">// reset</span></span><br><span class="line">            lastTime = currentTime; <span class="comment">// update</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">requestAnimationFrame</span>(updateFPS); <span class="comment">// request the next frame</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(updateFPS);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly 魔改记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录3——导航栏部分</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%953%E2%80%94%E2%80%94%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%83%A8%E5%88%86/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%953%E2%80%94%E2%80%94%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>这一部分比较多，主要是因为我自己引入了一个音乐播放器的部分。</p><h2 id="导航栏-nav-布局修改"><a href="#导航栏-nav-布局修改" class="headerlink" title="导航栏 nav 布局修改"></a>导航栏 <code>nav</code> 布局修改</h2><h3 id="搜索按钮置于右上角"><a href="#搜索按钮置于右上角" class="headerlink" title="搜索按钮置于右上角"></a>搜索按钮置于右上角</h3><p>&emsp;&emsp;找到 <code>layout/includes/nav.pug</code>，让搜索按钮位于最后面，只需要将 <code>theme.menu</code> 和 <code>theme.search</code> 两段代码交换位置即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#menus</span><br><span class="line">if theme.menu</span><br><span class="line">    != partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    #toggle-menu</span><br><span class="line">    span.site-page</span><br><span class="line">    i.fas.fa-bars.fa-fw</span><br><span class="line">    </span><br><span class="line">if theme.search.use</span><br><span class="line">    #search-button</span><br><span class="line">    span.site-page.social-icon.search</span><br><span class="line">        i.fas.fa-search.fa-fw</span><br><span class="line">        span= &#x27; &#x27; + _p(&#x27;search.title&#x27;)</span><br></pre></td></tr></table></figure><h3 id="菜单栏居中"><a href="#菜单栏居中" class="headerlink" title="菜单栏居中"></a>菜单栏居中</h3><p>&emsp;&emsp;修改导航栏显示菜单居中，样式相关，找到 <code>css/_layout/head.styl</code>，修改 <code>menus_item</code> 样式如下：<strong>（已被弃用，因为后续要将音乐播放器放置在中间，所以菜单栏依旧让其靠右）</strong></p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menus_items</span></span><br><span class="line">    <span class="attribute">display</span>: inline</span><br><span class="line">+    <span class="attribute">position</span>: absolute</span><br><span class="line">+    <span class="attribute">width</span>: fit-content</span><br><span class="line">+    <span class="attribute">left</span>: <span class="number">50%</span></span><br><span class="line">+    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>)</span><br></pre></td></tr></table></figure><h3 id="菜单栏的选项"><a href="#菜单栏的选项" class="headerlink" title="菜单栏的选项"></a>菜单栏的选项</h3><p>&emsp;&emsp;这一部分在主题的配置文件 <code>_config.butterfly.yml</code> 中修改即可。通过查看源码发现，butterfly 仅支持最多二级菜单，并没有嵌套多层菜单功能。目前自己用到的只有主页、学习资料以及常用网站。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">学习资料:</span> <span class="string">/categories</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-book</span></span><br><span class="line">  <span class="string">常用网站:</span> <span class="string">/link</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-globe</span></span><br><span class="line">  <span class="comment"># 其他||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br></pre></td></tr></table></figure><h3 id="细节优化"><a href="#细节优化" class="headerlink" title="细节优化"></a>细节优化</h3><p>&emsp;&emsp;对于本地搜索，我发现每次点开搜索弹出搜索框的时候，背景图片都会有些许的缩放。经过分析后发现，为了达到更好的体验效果，在弹出搜索框的时候，butterfly 会使主页的 <code>body: overflow</code> 的属性变为 <code>hidden</code>，这样主页面就不会有滚动效果了，达到了模态对话框的效果。但滚动条消失了，<code>body</code> 元素的宽度就会变大，可能会导致原先的页面布局发生一定的改变。而 butterfly 考虑到了这一点，因此在 <code>source/js/utils.js</code> 中创建了如下的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">overflowPaddingR</span>: &#123;</span><br><span class="line"><span class="attr">add</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> paddingRight = <span class="variable language_">window</span>.<span class="property">innerWidth</span> - <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paddingRight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">`<span class="subst">$&#123;paddingRight&#125;</span>px`</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;hidden&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> menuElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#page-header.nav-fixed #menus&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (menuElement) &#123;</span><br><span class="line">        menuElement.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">`<span class="subst">$&#123;paddingRight&#125;</span>px`</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">remove</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> menuElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#page-header.nav-fixed #menus&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (menuElement) &#123;</span><br><span class="line">    menuElement.<span class="property">style</span>.<span class="property">paddingRight</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原理就是给 <code>body</code> 添加一个内边距即 <code>paddingRight</code> 抵消变化。但是这个函数只是考虑了例如 <code>card_widget</code> 这些，我发现它们确实在滚动条消失后是不会有 <code>x</code> 方向平移变化的。但背景图就不是这样的。找到主题下的 <code>source/css/_global/index.styl</code> 文件，找到 <code>#web_bg</code> 即背景图片的样式，做如下修改，原理即将背景图片的大小从 <code>100%</code> 改为 <code>100vw</code>，因为背景图片的父元素即 <code>body</code> 是不包含滚动条的。而改为 <code>100vw</code> 则是整个视口的大小，会包含滚动条的大小。这样，即使滚动条消失了，图片的大小依旧是原来的数值，不会发生变化。</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;background&#x27;</span>)</span><br><span class="line"><span class="selector-id">#web_bg</span></span><br><span class="line">    <span class="attribute">position</span>: fixed</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">999</span></span><br><span class="line"></span><br><span class="line">-    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">-    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">+    <span class="attribute">width</span>: <span class="number">100vw</span></span><br><span class="line">+    <span class="attribute">height</span>: <span class="number">100vh</span></span><br><span class="line">    <span class="attribute">background-attachment</span>: local</span><br><span class="line">    <span class="attribute">background-position</span>: center</span><br><span class="line">    <span class="attribute">background-size</span>: cover</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat</span><br></pre></td></tr></table></figure><h2 id="音乐播放器引入"><a href="#音乐播放器引入" class="headerlink" title="音乐播放器引入"></a>音乐播放器引入</h2><p>&emsp;&emsp;butterfly 有自己的音乐播放插件 <code>Aplayer</code>，但我不是特别喜欢，而且也用不太懂，因此干脆自己写一个吧，又不是没有那个石粒！</p><h3 id="html-pug-部分"><a href="#html-pug-部分" class="headerlink" title="html (.pug) 部分"></a>html (.pug) 部分</h3><p>&emsp;&emsp;首先是 html 元素引入，在 <code>layout/includes/nav.pug</code> 中 <code>#blog-info</code> 后，<code>#menus</code> 前插入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">    span#blog-info</span><br><span class="line">        a.nav-site-title(href=url_for(&#x27;/&#x27;))</span><br><span class="line">        if theme.nav.logo</span><br><span class="line">            img.site-icon(src=url_for(theme.nav.logo) alt=&#x27;Logo&#x27;)</span><br><span class="line">        if theme.nav.display_title</span><br><span class="line">            span.site-name=config.title</span><br><span class="line">        if is_post()</span><br><span class="line">        a.nav-page-title(href=url_for(&#x27;/&#x27;))</span><br><span class="line">            span.site-name=(page.title || config.title)</span><br><span class="line">    </span><br><span class="line">    //- 从这里开始添加</span><br><span class="line">    //- music</span><br><span class="line">    #music-bar</span><br><span class="line">        #music-cover-container</span><br><span class="line">        #music-cover</span><br><span class="line"></span><br><span class="line">        #music-button-container</span><br><span class="line">        #music-button-container-top</span><br><span class="line">            span#music-prev.music-icon.iconfont.icon-shangyishou</span><br><span class="line">            span#music-playOrPause.music-icon.iconfont.icon-bofang</span><br><span class="line">            span#music-next.music-icon.iconfont.icon-xiayishou</span><br><span class="line">            span#music-mode.music-icon.iconfont.icon-liebiaoxunhuan</span><br><span class="line"></span><br><span class="line">        #music-button-container-bottom</span><br><span class="line">            div#music-progressBar</span><br><span class="line">            span#music-currentProgress</span><br><span class="line">            span#music-dot</span><br><span class="line">            span#music-progressText= &quot;00:00 / 00:00&quot;</span><br><span class="line"></span><br><span class="line">        #music-name-container</span><br><span class="line">        span#music-name</span><br><span class="line"></span><br><span class="line">        #music-lyric-container</span><br><span class="line">        span#music-lyric</span><br><span class="line">        </span><br><span class="line">    #menus</span><br><span class="line">        #toggle-menu</span><br><span class="line">        span.site-page</span><br><span class="line">        i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><h3 id="css-styl-部分"><a href="#css-styl-部分" class="headerlink" title="css (.styl) 部分"></a>css (.styl) 部分</h3><p>&emsp;&emsp;这一部分就比较长了，也是花费时间最长的部分之一，主要对 CSS 不常用忘记了好多。找到 <code>css/_layout/head.styl</code>，在最后添加如下代码（复制粘贴使用时注意缩进！！）：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// music bar</span></span><br><span class="line"><span class="selector-id">#music-bar</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.6</span>)</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span></span><br><span class="line">  </span><br><span class="line">  +<span class="built_in">maxWidth1024</span>()</span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-cover-container</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">52px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">display</span>: inline-flex</span><br><span class="line">    <span class="attribute">vertical-align</span>: top</span><br><span class="line">    <span class="attribute">align-items</span>: center</span><br><span class="line">    </span><br><span class="line">    <span class="selector-id">#music-cover</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">44px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">44px</span></span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">0</span> <span class="number">4px</span></span><br><span class="line">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;/img/云烟成雨-cover.webp&quot;</span>)</span><br><span class="line">      <span class="attribute">background-size</span>: contain</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">8px</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-button-container</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="attribute">vertical-align</span>: top</span><br><span class="line">    <span class="comment">// background-color: rgb(3, 84, 3)</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-button-container-top</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">26px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">      <span class="comment">// background-color: rgb(114, 6, 107)</span></span><br><span class="line">      <span class="attribute">display</span>: flex</span><br><span class="line">      <span class="attribute">align-content</span>: center</span><br><span class="line">      <span class="attribute">justify-content</span>: center</span><br><span class="line">      <span class="selector-class">.music-icon</span></span><br><span class="line">        <span class="comment">// background-color: rgb(174, 167, 167)</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">24px</span></span><br><span class="line">        <span class="attribute">margin</span>: auto <span class="number">2px</span></span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">          <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">31</span>, <span class="number">179</span>, <span class="number">161</span>, <span class="number">1</span>)</span><br><span class="line">          <span class="attribute">cursor</span>: pointer</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-button-container-bottom</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">22px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">      <span class="comment">// background-color: rgb(82, 76, 2)</span></span><br><span class="line">      <span class="attribute">position</span>: relative</span><br><span class="line"></span><br><span class="line">      <span class="selector-id">#music-progressBar</span></span><br><span class="line">        <span class="attribute">position</span>: absolute</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">3px</span></span><br><span class="line">        <span class="attribute">left</span>: <span class="number">50%</span></span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>)</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">4px</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">110px</span></span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">35</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">0.8</span>)</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">2.5px</span></span><br><span class="line">        <span class="comment">// overflow: hidden</span></span><br><span class="line"></span><br><span class="line">        <span class="selector-id">#music-currentProgress</span></span><br><span class="line">          <span class="attribute">display</span>: block</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">          <span class="comment">// background-color: rgb(255, 0, 0)</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">2px</span></span><br><span class="line">          <span class="attribute">transition</span>: <span class="number">0.3s</span> ease</span><br><span class="line"></span><br><span class="line">        <span class="selector-id">#music-dot</span></span><br><span class="line">          <span class="attribute">display</span>: block</span><br><span class="line">          <span class="attribute">position</span>: absolute</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">6px</span></span><br><span class="line">          <span class="attribute">height</span>: <span class="number">6px</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">3px</span></span><br><span class="line">          <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">234</span>, <span class="number">151</span>, <span class="number">8</span>)</span><br><span class="line">          <span class="attribute">bottom</span>: -<span class="number">1px</span></span><br><span class="line">          <span class="attribute">left</span>: -<span class="number">3px</span></span><br><span class="line">          <span class="attribute">z-index</span>: <span class="number">999</span></span><br><span class="line">          <span class="attribute">transition</span>: <span class="number">0.3s</span> ease</span><br><span class="line"></span><br><span class="line">        <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">          <span class="attribute">cursor</span>: pointer</span><br><span class="line">          <span class="selector-id">#music-dot</span></span><br><span class="line">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">23</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">0.5</span>); <span class="comment">/* 添加阴影 */</span></span><br><span class="line"></span><br><span class="line">      <span class="selector-id">#music-progressText</span></span><br><span class="line">        <span class="attribute">position</span>: absolute</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">1px</span></span><br><span class="line">        <span class="attribute">right</span>: <span class="number">4px</span></span><br><span class="line">        <span class="attribute">display</span>: block</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">80px</span></span><br><span class="line">        <span class="attribute">height</span>: <span class="number">16px</span></span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">16px</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="attribute">text-align</span>: right</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-name-container</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="comment">// background-color: rgb(127, 0, 0)</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap</span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">70%</span></span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-name</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">24px</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#music-lyric-container</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">    <span class="comment">// background-color: rgb(153, 210, 168)</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap</span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">2px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">70%</span></span><br><span class="line">      <span class="attribute">top</span>: <span class="number">50%</span></span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">139</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#music-lyric</span></span><br><span class="line">      <span class="attribute">display</span>: inline-block</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">48px</span></span><br><span class="line">      <span class="attribute">font</span>: <span class="number">20px</span> <span class="string">&quot;wawati&quot;</span></span><br></pre></td></tr></table></figure><h3 id="js-部分"><a href="#js-部分" class="headerlink" title="js 部分"></a>js 部分</h3><p>&emsp;&emsp;最后就到了 <code>js</code> 代码部分了，这一部分没有原先的文件可供使用，因此自己可以在 hexo 主目录下的 <code>source</code> 中创建一个目录 <code>js</code>，在其中创建一个文件 <code>music.js</code> 以及用于歌词分割的文件 <code>lyricParse.js</code>，由于是单独的文件，此处就不再粘贴出代码了。</p><h3 id="资源文件部分"><a href="#资源文件部分" class="headerlink" title="资源文件部分"></a>资源文件部分</h3><ul><li>音乐封面，路径为 <code>/img/</code></li><li>音乐资源，路径为 <code>/music/</code></li><li>音乐歌词，路径为 <code>/lyrics/</code></li></ul><p>例如 <code>music.js</code> 中 <code>MusicPlayer</code> 的这三个属性定义为下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">musicList</span> = [<span class="string">&quot;/music/云烟成雨 - 房东的猫.mp3&quot;</span>, <span class="string">&quot;/music/使一颗心免于哀伤 - HOYO-MiX,Chevy,知更鸟.mp3&quot;</span>, <span class="string">&quot;/music/单向箭头 - 双笙 (陈元汐).mp3&quot;</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">coverList</span> = [<span class="string">&quot;/img/云烟成雨-cover.webp&quot;</span>, <span class="string">&quot;/img/使一颗心免于哀伤-cover.jpg&quot;</span>, <span class="string">&quot;/img/单向箭头-cover.webp&quot;</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">lyricList</span> = [<span class="string">&quot;/lyrics/云烟成雨.lrc&quot;</span>, <span class="string">&quot;/lyrics/使一颗心免于哀伤.lrc&quot;</span>, <span class="string">&quot;/lyrics/单向箭头.lrc&quot;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly 魔改记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录2——鼠标部分</title>
      <link href="/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%952%E2%80%94%E2%80%94%E9%BC%A0%E6%A0%87%E9%83%A8%E5%88%86/"/>
      <url>/2024/11/19/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%952%E2%80%94%E2%80%94%E9%BC%A0%E6%A0%87%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="鼠标样式修改"><a href="#鼠标样式修改" class="headerlink" title="鼠标样式修改"></a>鼠标样式修改</h2><p>可以在 <code>source/css/</code> 下新建 <code>cursor.css</code> 文件来修改鼠标的展示样式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly 魔改记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-butterfly 魔改记录1——背景飘落特效</title>
      <link href="/2024/11/13/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%951%E2%80%94%E2%80%94%E8%83%8C%E6%99%AF%E9%A3%98%E8%90%BD%E7%89%B9%E6%95%88/"/>
      <url>/2024/11/13/Hexo-butterfly-%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%951%E2%80%94%E2%80%94%E8%83%8C%E6%99%AF%E9%A3%98%E8%90%BD%E7%89%B9%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h2 id="樱花-雪花飘落特效"><a href="#樱花-雪花飘落特效" class="headerlink" title="樱花&#x2F;雪花飘落特效"></a>樱花&#x2F;雪花飘落特效</h2><p>&emsp;&emsp;在 <code>sakuraPlus.js</code> 中实现。这是很久之前不知道从哪里得到的一份代码，目前网上也十分容易找到，并且用的人也挺多的。将这份代码放置在 <code>source/js</code> 文件夹中，可以修改其中的 <code>img.src</code> 图片原路径换不同的图片资源，甚至也可以修改 <code>fnx</code> 等这些飘落计算公式适配不同的物体飘落逻辑。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/cursor.css&quot;&gt;</span></span><br><span class="line"><span class="attr">bottom:</span></span><br><span class="line"><span class="string">+</span>    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=/js/sakuraPlus.js&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo-butterfly 魔改记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 的使用</title>
      <link href="/2024/11/12/CMake-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/12/CMake-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li><p>指定 cmake 的最低版本</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br></pre></td></tr></table></figure></li><li><p>指定项目名称</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>set</code> 命令的使用，例如指定 C++ 的标准、指定文件输出路径等</p><ul><li><p>指定 C++11 的标准</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></li><li><p>指定制作的库的输出路径，一般放置在项目根目录的 <code>lib</code> 文件夹中</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure></li><li><p>指定可执行程序的输出路径，一般我们都放置在项目根目录的 <code>bin</code> 文件夹中</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>搜索文件</p><ul><li><p>方法 1: <code>file</code> 命令</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.cpp)</span><br></pre></td></tr></table></figure><ul><li>参数 1: <code>GLOB</code> 是 <code>file</code> 命令的一个参数，表示“全局匹配”，用于根据指定的模式查找文件。</li><li>参数 2: 将查找到的文件保存在该变量中。</li><li>参数 3: 匹配模式，示例中为匹配 <code>CMAKE_CURRENT_SOURCE_DIR</code> 宏指定的目录下的所有以 <code>.cpp</code> 结尾的文件。</li></ul></li><li><p>方法 2: 待补充，方法 1 就挺好用</p></li></ul></li><li><p>制作一个库文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(calculate STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>参数 1: 表示生成库的名字，注意这只是省略的写法，真正的库名为 <code>libcalculate.lib</code> 这种。</li><li>参数 2: 表示生成库的类型, <code>STATIC</code> 表示生成静态库，<code>SHARED</code> 表示生成动态库（共享库）。</li><li>参数 3: 表示用于生成库所需要的源文件。</li></ul></li><li><p>打印信息</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure></li><li><p>引用一个库文件：</p><ul><li>首先要包含头文件。因为头文件中有如何使用库文件中的接口，有了头文件才能指导我们里面有什么函数可以使用。</li></ul> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;../include&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>然后应该告知要去哪里搜索我们的库文件，我们要指定一个具体的搜索目录。</li></ul> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include library</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure><ul><li>最后，我们便可以链接这个目录中的某个具体库使用了～</li></ul> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(calculate)</span><br></pre></td></tr></table></figure></li><li><p>生成可执行文件</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(test1 <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><p> 参数 1: 生成可执行文件的名称。<br> 参数 2: 所需要用到的源文件。</p></li></ol><h2 id="常用的宏"><a href="#常用的宏" class="headerlink" title="常用的宏"></a>常用的宏</h2><table><thead><tr><th>宏名称</th><th>解释</th></tr></thead><tbody><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td><strong>当前</strong> <code>CMakeLists.txt</code> 所在的目录</td></tr><tr><td><code>PROJECT_SOURCE_DIR</code></td><td>项目的根目录，注意在多 CMake 嵌套的工程中与 <code>CMAKE_CURRENT_SOURCE_DIR</code> 不一定等价</td></tr><tr><td><code>CMAKE_CXX_STANDARD</code></td><td>CMake 要求的 C++ 最低版本</td></tr><tr><td><code>LIBRARY_OUTPUT_PATH</code></td><td>制作的库的输出（保存）路径</td></tr><tr><td><code>EXECUTABLE_OUTPUT_PATH</code></td><td>生成的二进制可执行程序的输出路径</td></tr></tbody></table><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="制作库的参考模板"><a href="#制作库的参考模板" class="headerlink" title="制作库的参考模板"></a>制作库的参考模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(apue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output path</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># source file to make a library</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/*.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;../include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(apue STATIC <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="生成可执行程序的参考模板"><a href="#生成可执行程序的参考模板" class="headerlink" title="生成可执行程序的参考模板"></a>生成可执行程序的参考模板</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the project&#x27;s name</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_NAME fig8.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set project&#x27;s name</span></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include head file</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;../include&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include library</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">&quot;../lib&quot;</span>)</span><br><span class="line"><span class="keyword">link_libraries</span>(apue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/11/12/hello-world/"/>
      <url>/2024/11/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
